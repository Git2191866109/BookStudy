#  尚学堂JAVA高级学习笔记

[TOC]

## 写在前面

学习链接：[Java 视频教程全集](https://www.bilibili.com/video/av59529105/)

课件链接：[Java课件](https://www.sxt.cn/Java_jQuery_in_action/History_Direction.html)

## 第1章 手写webserver

### 1. 灵魂反射

- 反射Reflection：把java类中的各种结构（方法、属性、构造器、类名）映射成一个个的java对象。利用反射技术可以对一个类进行解剖，反射是框架设计的灵魂。

- 获取Class对象（三种方式）：推荐使用Class.forName(“完整路径”)

- 可以动态创建对象：clz.getConstructor().newInstance()

- 练习

  ```java
  package com.sxt.Server_study01;
  
  import java.lang.reflect.InvocationTargetException;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: ReflectTest.java
   * @time: 2019/11/29 14:55
   * @desc:
   */
  
  public class ReflectTest {
      public static void main(String[] args){
          // 1. 对象.getClass() | 买iphone照着做
          Iphone iphone = new Iphone();
          Class clz = iphone.getClass();
          // 2. 类.class()     | 买通工程师给图纸
          clz = Iphone.class;
          // 3. Class.forName("包名.类名")   | 偷图纸
          try {
              clz = Class.forName("com.sxt.Server_study01.Iphone");
          } catch (ClassNotFoundException e) {
              e.printStackTrace();
          }
  
          // 创建对象
          try {
              Iphone iphone2 = (Iphone)clz.newInstance();
              System.out.println(iphone2);
          } catch (InstantiationException | IllegalAccessException e) {
              e.printStackTrace();
          }
          // 创建对象推荐方式
          try {
              Iphone iphone3 = (Iphone)clz.getConstructor().newInstance();
              System.out.println(iphone3);
          } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
              e.printStackTrace();
          }
      }
  }
  
  class Iphone{
      public Iphone(){
      }
  }
  ```

### 2. 高效解析xml

- XML：Extensible Markup Language，可扩展标记语言，作为数据的一种存储格式或用于存储软件的参数，程序解析此配置文件，就可以达到不修改代码就能更改程序的目的。

- 利用Sax解析XML

- xml例子

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <persons>
      <person>
          <name>至尊宝</name>
          <age>9000</age>
      </person>
      <person>
          <name>白晶晶</name>
          <age>7000</age>
      </person>
  </persons>
  ```

- 制作Person类

  ```java
  package com.sxt.Server_study01;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Person.java
   * @time: 2019/11/29 15:29
   * @desc:
   */
  
  public class Person {
      private String name;
      private int age;
  
      public Person() {
      }
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public int getAge() {
          return age;
      }
  
      public void setAge(int age) {
          this.age = age;
      }
  }
  ```

- 熟悉sax解析流程

  ```java
  package com.sxt.Server_study01;
  
  import org.xml.sax.Attributes;
  import org.xml.sax.SAXException;
  import org.xml.sax.helpers.DefaultHandler;
  
  import javax.xml.parsers.ParserConfigurationException;
  import javax.xml.parsers.SAXParser;
  import javax.xml.parsers.SAXParserFactory;
  import java.io.IOException;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: XmlTest01.java
   * @time: 2019/11/29 15:10
   * @desc: 熟悉sax解析流程
   */
  
  public class XmlTest01 {
      public static void main(String[] args) throws ParserConfigurationException, SAXException, IOException {
          // SAX解析
          // 1. 获取解析工厂
          SAXParserFactory factory = SAXParserFactory.newInstance();
          // 2. 从解析工厂获取解析器
          SAXParser parse = null;
          parse = factory.newSAXParser();
          // 3. 加载文档Document注册处理器
          // 4. 编写处理器
          PHandler handler = new PHandler();
          parse.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream("com/sxt/Server_study01/p.xml"), handler);
      }
  }
  
  class PHandler extends DefaultHandler {
      @Override
      public void startDocument() throws SAXException {
          System.out.println("解析文档开始");
      }
  
      @Override
      public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
          System.out.println(qName + "-->解析开始");
      }
  
      @Override
      public void characters(char[] ch, int start, int length) throws SAXException {
          String contents = new String(ch, start, length).trim();
          if(contents.length()>0) {
              System.out.println("内容为：" + contents);
          }else{
              System.out.println("内容为空！");
          }
      }
  
      @Override
      public void endDocument() throws SAXException {
          System.out.println("解析文档结束");
      }
  
      @Override
      public void endElement(String uri, String localName, String qName) throws SAXException {
          System.out.println(qName + "-->解析结束");
      }
  }
  ```

- 获取xml中的内容

  ```java
  package com.sxt.Server_study01;
  
  import org.xml.sax.Attributes;
  import org.xml.sax.SAXException;
  import org.xml.sax.helpers.DefaultHandler;
  
  import javax.xml.parsers.ParserConfigurationException;
  import javax.xml.parsers.SAXParser;
  import javax.xml.parsers.SAXParserFactory;
  import java.io.IOException;
  import java.util.ArrayList;
  import java.util.List;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: XmlTest02.java
   * @time: 2019/11/29 15:31
   * @desc: 获取xml中的内容
   */
  
  public class XmlTest02 {
      public static void main(String[] args) throws ParserConfigurationException, SAXException, IOException {
          // SAX解析
          // 1. 获取解析工厂
          SAXParserFactory factory = SAXParserFactory.newInstance();
          // 2. 从解析工厂获取解析器
          SAXParser parse = null;
          parse = factory.newSAXParser();
          // 3. 加载文档Document注册处理器
          // 4. 编写处理器
          PersonHandler handler = new PersonHandler();
          parse.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream("com/sxt/Server_study01/p.xml"), handler);
          // 5. 获取数据
          List<Person> persons = handler.getPersons();
          for (Person p : persons) {
              System.out.println(p.getName() + "-->" + p.getAge());
          }
      }
  }
  
  class PersonHandler extends DefaultHandler {
      private List<Person> persons;
      private Person person;
      private String tag;     // 存储操作的标签
  
      @Override
      public void startDocument() throws SAXException {
          System.out.println("解析文档开始");
          persons = new ArrayList<>();
      }
  
      @Override
      public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
          if (null != qName) {
              tag = qName;        // 存储标签名
              if (tag.equals("person")) {
                  person = new Person();
              }
          }
      }
  
      @Override
      public void characters(char[] ch, int start, int length) throws SAXException {
          String contents = new String(ch, start, length).trim();
          if (contents.length() > 0) {
              if (tag.equals("name")) {
                  person.setName(contents);
              } else if (tag.equals("age")) {
                  person.setAge(Integer.valueOf(contents));
              }
          }
      }
  
      @Override
      public void endElement(String uri, String localName, String qName) throws SAXException {
          if (qName.equals("person")) {
              persons.add(person);
          }
      }
  
      @Override
      public void endDocument() throws SAXException {
          System.out.println("解析文档结束");
      }
  
      public List<Person> getPersons() {
          return persons;
      }
  }
  ```

### 3. 解析webxml

- webxml例子

  ```java
  <?xml version="1.0" encoding="UTF-8"?>
  <web-app>
      <servlet>
          <servlet-name>login</servlet-name>
          <servlet-class>com.sxt.server.basic.servlet.LoginServlet</servlet-class>
      </servlet>
      <servlet>
          <servlet-name>reg</servlet-name>
          <servlet-class>com.sxt.server.basic.servlet.RegisterServlet</servlet-class>
      </servlet>
      <servlet-mapping>
          <servlet-name>login</servlet-name>
          <url-pattern>/login</url-pattern>
          <url-pattern>/g</url-pattern>
      </servlet-mapping>
      <servlet-mapping>
          <servlet-name>reg</servlet-name>
          <url-pattern>/reg</url-pattern>
      </servlet-mapping>
  </web-app>
  ```

- 解析webxml

  ```java
  package com.sxt.Server_study01.servlet;
  
  import com.sxt.Server_study01.Person;
  import org.xml.sax.Attributes;
  import org.xml.sax.SAXException;
  import org.xml.sax.helpers.DefaultHandler;
  
  import javax.xml.parsers.ParserConfigurationException;
  import javax.xml.parsers.SAXParser;
  import javax.xml.parsers.SAXParserFactory;
  import java.io.IOException;
  import java.util.ArrayList;
  import java.util.List;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: XmlTest02.java
   * @time: 2019/11/29 15:31
   * @desc: 解析Webxml
   */
  
  public class XmlTest02 {
      public static void main(String[] args) throws ParserConfigurationException, SAXException, IOException {
          // SAX解析
          // 1. 获取解析工厂
          SAXParserFactory factory = SAXParserFactory.newInstance();
          // 2. 从解析工厂获取解析器
          SAXParser parse = null;
          parse = factory.newSAXParser();
          // 3. 加载文档Document注册处理器
          // 4. 编写处理器
          WebHandler handler = new WebHandler();
          parse.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream("com/sxt/Server_study01/servlet/web.xml"), handler);
          // 5. 获取数据
          List<Entity> entitys = handler.getEntitys();
          List<Mapping> mappings = handler.getMappings();
          System.out.println(entitys.size());
          System.out.println(mappings.size());
      }
  }
  
  class WebHandler extends DefaultHandler {
      private List<Entity> entitys;
      private List<Mapping> mappings;
      private Entity entity;
      private Mapping mapping;
      private String tag;
      private boolean isMapping = false;
  
      public List<Entity> getEntitys() {
          return entitys;
      }
  
      public void setEntitys(List<Entity> entitys) {
          this.entitys = entitys;
      }
  
      public List<Mapping> getMappings() {
          return mappings;
      }
  
      public void setMappings(List<Mapping> mappings) {
          this.mappings = mappings;
      }
  
      @Override
      public void startDocument() throws SAXException {
          entitys = new ArrayList<>();
          mappings = new ArrayList<>();
      }
  
      @Override
      public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
          if (null != qName) {
              tag = qName;        // 存储标签名
              if (tag.equals("servlet")) {
                  entity = new Entity();
                  isMapping = false;
              } else if (tag.equals("servlet-mapping")) {
                  mapping = new Mapping();
                  isMapping = true;
              }
          }
      }
  
      @Override
      public void characters(char[] ch, int start, int length) throws SAXException {
          String contents = new String(ch, start, length).trim();
          if (contents.length() > 0) {
              if (isMapping) {// 操作servlet-mapping
                  if (tag.equals("servlet-name")) {
                      mapping.setName(contents);
                  } else if (tag.equals("url-pattern")) {
                      mapping.addPattern(contents);
                  }
              } else {// 操作servlet
                  if (tag.equals("servlet-name")) {
                      entity.setName(contents);
                  } else if (tag.equals("servlet-class")) {
                      entity.setClz(contents);
                  }
              }
          }
      }
  
      @Override
      public void endElement(String uri, String localName, String qName) throws SAXException {
          if (qName.equals("servlet")) {
              entitys.add(entity);
          } else if (qName.equals("servlet-mapping")) {
              mappings.add(mapping);
          }
      }
  }
  ```

### 4. 反射webxml

- xml样例

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <web-app>
      <servlet>
          <servlet-name>login</servlet-name>
          <servlet-class>com.sxt.Server_study01.servlet.LoginServlet</servlet-class>
      </servlet>
      <servlet>
          <servlet-name>reg</servlet-name>
          <servlet-class>com.sxt.Server_study01.servlet.RegisterServlet</servlet-class>
      </servlet>
      <servlet-mapping>
          <servlet-name>login</servlet-name>
          <url-pattern>/login</url-pattern>
          <url-pattern>/g</url-pattern>
      </servlet-mapping>
      <servlet-mapping>
          <servlet-name>reg</servlet-name>
          <url-pattern>/reg</url-pattern>
      </servlet-mapping>
  </web-app>
  ```

- 解析xml

  - Entity类

    ```java
    package com.sxt.Server_study01.servlet;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Entity.java
     * @time: 2019/12/2 13:20
     * @desc:
     */
    
    public class Entity {
        private String name;
        private String clz;
    
        public Entity() {
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public String getClz() {
            return clz;
        }
    
        public void setClz(String clz) {
            this.clz = clz;
        }
    }
    ```

  - Mapping类

    ```java
    package com.sxt.Server_study01.servlet;
    
    import java.util.HashSet;
    import java.util.Set;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Mapping.java
     * @time: 2019/12/2 13:21
     * @desc:
     */
    
    public class Mapping {
        private String name;
        private Set<String> patterns;
    
        public Mapping() {
            patterns = new HashSet<>();
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public Set<String> getPatterns() {
            return patterns;
        }
    
        public void setPatterns(Set<String> patterns) {
            this.patterns = patterns;
        }
    
        public void addPattern(String pattern){
            this.patterns.add(pattern);
        }
    }
    ```

  - 通过URL的路径找到了对应的class

    ```java
    package com.sxt.Server_study01.servlet;
    
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: WebContext.java
     * @time: 2019/12/3 10:51
     * @desc:
     */
    
    public class WebContext {
        private List<Entity> entitys = null;
        private List<Mapping> mappings = null;
    
        // key-->servlet-name  value-->servlet-class
        private Map<String, String> mappingMap = new HashMap<>();
        // key-->url-pattern  value-->servlet-name
        private Map<String, String> entityMap = new HashMap<>();
    
        public WebContext(List<Entity> entitys, List<Mapping> mappings) {
            this.entitys = entitys;
            this.mappings = mappings;
    
            // 将entity的List转成了对应的map
            for(Entity entity: entitys){
                entityMap.put(entity.getName(), entity.getClz());
            }
            // 将map的List转成了对应的map
            for(Mapping mapping: mappings){
                for(String pattern: mapping.getPatterns()){
                    mappingMap.put(pattern, mapping.getName());
                }
            }
        }
    
        // 通过URL的路径找到了对应的class
        public String getClz(String pattern) {
            String name = mappingMap.get(pattern);
            return entityMap.get(name);
        }
    }
    ```

  - 核心代码，取出数据

    ```java
    package com.sxt.Server_study01.servlet;
    
    import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;
    import org.xml.sax.Attributes;
    import org.xml.sax.SAXException;
    import org.xml.sax.helpers.DefaultHandler;
    
    import javax.xml.parsers.ParserConfigurationException;
    import javax.xml.parsers.SAXParser;
    import javax.xml.parsers.SAXParserFactory;
    import java.io.IOException;
    import java.util.ArrayList;
    import java.util.List;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: XmlTest02.java
     * @time: 2019/11/29 15:31
     * @desc: 解析Webxml
     */
    
    public class XmlTest02 {
        public static void main(String[] args) throws Exception {
            // SAX解析
            // 1. 获取解析工厂
            SAXParserFactory factory = SAXParserFactory.newInstance();
            // 2. 从解析工厂获取解析器
            SAXParser parse = null;
            parse = factory.newSAXParser();
            // 3. 加载文档Document注册处理器
            // 4. 编写处理器
            WebHandler handler = new WebHandler();
            parse.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream("com/sxt/Server_study01/servlet/web.xml"), handler);
            // 5. 获取数据
            WebContext context = new WebContext(handler.getEntitys(), handler.getMappings());
            // 假设你输入了 /login or /g
            String className = context.getClz("/g");
            Class clz = Class.forName(className);
            Servlet servlet = (Servlet)clz.getConstructor().newInstance();
            System.out.println(servlet);
            servlet.service();
        }
    }
    
    class WebHandler extends DefaultHandler {
        private List<Entity> entitys;
        private List<Mapping> mappings;
        private Entity entity;
        private Mapping mapping;
        private String tag;
        private boolean isMapping = false;
    
        public List<Entity> getEntitys() {
            return entitys;
        }
    
        public void setEntitys(List<Entity> entitys) {
            this.entitys = entitys;
        }
    
        public List<Mapping> getMappings() {
            return mappings;
        }
    
        public void setMappings(List<Mapping> mappings) {
            this.mappings = mappings;
        }
    
        @Override
        public void startDocument() throws SAXException {
            entitys = new ArrayList<>();
            mappings = new ArrayList<>();
        }
    
        @Override
        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
            if (null != qName) {
                tag = qName;        // 存储标签名
                if (tag.equals("servlet")) {
                    entity = new Entity();
                    isMapping = false;
                } else if (tag.equals("servlet-mapping")) {
                    mapping = new Mapping();
                    isMapping = true;
                }
            }
        }
    
        @Override
        public void characters(char[] ch, int start, int length) throws SAXException {
            String contents = new String(ch, start, length).trim();
            if (contents.length() > 0) {
                if (isMapping) {// 操作servlet-mapping
                    if (tag.equals("servlet-name")) {
                        mapping.setName(contents);
                    } else if (tag.equals("url-pattern")) {
                        mapping.addPattern(contents);
                    }
                } else {// 操作servlet
                    if (tag.equals("servlet-name")) {
                        entity.setName(contents);
                    } else if (tag.equals("servlet-class")) {
                        entity.setClz(contents);
                    }
                }
            }
        }
    
        @Override
        public void endElement(String uri, String localName, String qName) throws SAXException {
            if (qName.equals("servlet")) {
                entitys.add(entity);
            } else if (qName.equals("servlet-mapping")) {
                mappings.add(mapping);
            }
        }
    }
    ```

  - Servlet接口

    ```java
    package com.sxt.Server_study01.servlet;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Servlet.java
     * @time: 2019/12/3 15:59
     * @desc:
     */
    
    public interface Servlet {
        void service();
    }
    ```

  - 需要被映射的类：Loginservlet

    ```java
    package com.sxt.Server_study01.servlet;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LoginServlet.java
     * @time: 2019/12/3 15:59
     * @desc:
     */
    
    public class LoginServlet implements Servlet {
        @Override
        public void service() {
            System.out.println("LoginServlet");
        }
    }
    ```

  - 需要被映射的类：RegisterServlet

    ```java
    package com.sxt.Server_study01.servlet;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: RegisterServlet.java
     * @time: 2019/12/3 15:59
     * @desc:
     */
    
    public class RegisterServlet implements Servlet{
        @Override
        public void service() {
            System.out.println("RegisterServlet");
        }
    }
    ```

### 5. 简单易学的html

- HyperText Markup Language ，超文本标记语言，简单理解为浏览器使用的语言。

- name是后端用的，id是前端用的

  ```java
  <html>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <head>
          <title>第一个html登陆</title>
      </head>
      <body>
          <h1>表单的使用</h1>
          <pre>
              post: 提交，基于http协议不同  量大  请求参数url不可见  安全<br/>
              get: 默认，获取，基于http协议不同  量小  请求参数url可见  不安全<br/>
              action: 请求web服务器的资源 URL<br/>
              name: 作为后端使用，区分唯一，请求服务器，必须存在，数据不能提交<br/>
              id: 作为前端使用，区分唯一<br/>
          </pre>
          <form method="post" action="http://localhost:8888/index.html">
              用户名: <input type="text" name="uname" id="uname"/>
              密码: <input type="password" name="pwd" id="pwd"/>
              <input type="submit" value="登陆"/>
          </form>
      </body>
  </html>
  ```

### 6. 不得不提的http协议

- http请求协议

   ![img](https://img-blog.csdnimg.cn/20191204091941174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
   
- http响应协议

    ![img](https://img-blog.csdnimg.cn/20191204092305298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 7. 获取请求协议

- 使用ServerSocket建立与浏览器的连接，获取请求协议

  ```java
  package com.sxt.Server_study02;
  
  import java.io.IOException;
  import java.io.InputStream;
  import java.net.ServerSocket;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Server01.java
   * @time: 2019/12/4 9:26
   * @desc: 使用ServerSocket建立与浏览器的连接，获取请求协议
   */
  
  public class Server01 {
      private ServerSocket serverSocket;
      public static void main(String[] args) {
          Server01 server = new Server01();
          server.start();
      }
  
      // 启动服务
      public void start() {
          try {
              serverSocket = new ServerSocket(8888);
              receive();
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("服务器启动失败...");
          }
      }
  
      // 接受连接处理
      public void receive() {
          try {
              Socket client = serverSocket.accept();
              System.out.println("一个客户端建立了连接...");
              // 获取请求协议
              InputStream is = client.getInputStream();
              byte[] datas = new byte[1024*1024];
              int len = is.read(datas);
              String requstInfo = new String(datas, 0, len);
              System.out.println(requstInfo);
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("客户端错误...");
          }
      }
  
      // 停止服务
      public void stop() {
  
      }
  }
  ```

- 两种请求方法get和post：[GET和POST两种基本请求方法的区别](https://www.cnblogs.com/logsharing/p/8448446.html)，[GET 和 POST 到底有什么区别？]( https://www.zhihu.com/question/28586791?sort=created )

### 8. 返回响应协议

```java
package com.sxt.Server_study02;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Date;

/**
 * @author: Li Tian
 * @contact: litian_cup@163.com
 * @software: IntelliJ IDEA
 * @file: Server02.java
 * @time: 2019/12/4 9:26
 * @desc: 返回响应协议
 */

public class Server02 {
    private ServerSocket serverSocket;
    public static void main(String[] args) {
        Server02 server = new Server02();
        server.start();
    }

    // 启动服务
    public void start() {
        try {
            serverSocket = new ServerSocket(8888);
            receive();
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("服务器启动失败...");
        }
    }

    // 接受连接处理
    public void receive() {
        try {
            Socket client = serverSocket.accept();
            System.out.println("一个客户端建立了连接...");
            // 获取请求协议
            InputStream is = client.getInputStream();
            byte[] datas = new byte[1024*1024];
            int len = is.read(datas);
            String requstInfo = new String(datas, 0, len);
            System.out.println(requstInfo);

            StringBuilder content = new StringBuilder();
            content.append("<html>");
            content.append("<head>");
            content.append("<title>");
            content.append("服务器响应成功");
            content.append("</title>");
            content.append("</head>");
            content.append("<body>");
            content.append("终于回来了...");
            content.append("</body>");
            content.append("</html>");
            int size = content.toString().getBytes().length;
            StringBuilder responseInfo = new StringBuilder();
            String blank = " ";
            String CRLF = "\r\n";
            // 返回
            // 1. 响应行：HTTP/1.1 200 OK
            responseInfo.append("HTTP/1.1").append(blank);
            responseInfo.append(200).append(blank);
            responseInfo.append("OK").append(CRLF);
            // 2. 响应头（最后一行存在空行）：
            responseInfo.append("Date:").append(new Date()).append(CRLF);
            responseInfo.append("Server:").append("shsxt Server/0.0.1;charset=GBK").append(CRLF);
            responseInfo.append("Content-type:text/html").append(CRLF);
            responseInfo.append("Content-length:").append(size).append(CRLF);
            responseInfo.append(CRLF);
            // 3. 正文
            responseInfo.append(content.toString());
            // 写出到客户端
            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
            bw.write(responseInfo.toString());
            bw.flush();
            bw.close();
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("客户端错误...");
        }
    }

    // 停止服务
    public void stop() {

    }
}
```

### 9. 封装响应信息

1. 动态添加内容print

2. 累加字节数的长度

3. 根据状态码拼接响应头协议

4. 根据状态码统一推送出去

   ```java
   package com.sxt.Server_study02;
   
   import java.io.IOException;
   import java.io.InputStream;
   import java.net.ServerSocket;
   import java.net.Socket;
   
   /**
    * @author: Li Tian
    * @contact: litian_cup@163.com
    * @software: IntelliJ IDEA
    * @file: Server03.java
    * @time: 2019/12/4 9:26
    * @desc: 封装响应信息
    */
   
   public class Server03 {
       private ServerSocket serverSocket;
       public static void main(String[] args) {
           Server03 server = new Server03();
           server.start();
       }
   
       // 启动服务
       public void start() {
           try {
               serverSocket = new ServerSocket(8888);
               receive();
           } catch (IOException e) {
               e.printStackTrace();
               System.out.println("服务器启动失败...");
           }
       }
   
       // 接受连接处理
       public void receive() {
           try {
               Socket client = serverSocket.accept();
               System.out.println("一个客户端建立了连接...");
               // 获取请求协议
               InputStream is = client.getInputStream();
               byte[] datas = new byte[1024*1024];
               int len = is.read(datas);
               String requstInfo = new String(datas, 0, len);
               System.out.println(requstInfo);
   
               Response response = new Response(client);
   
               // 关注了内容
               response.print("<html>");
               response.print("<head>");
               response.print("<title>");
               response.print("服务器响应成功");
               response.print("</title>");
               response.print("</head>");
               response.print("<body>");
               response.print("终于回来了...");
               response.print("</body>");
               response.print("</html>");
   
               // 关注了状态码
               response.pushToBrowser(200);
   
           } catch (IOException e) {
               e.printStackTrace();
               System.out.println("客户端错误...");
           }
       }
   
       // 停止服务
       public void stop() {
       }
   }
   ```

   ```java
   package com.sxt.Server_study02;
   
   import java.io.BufferedWriter;
   import java.io.IOException;
   import java.io.OutputStream;
   import java.io.OutputStreamWriter;
   import java.net.Socket;
   import java.util.Date;
   
   /**
    * @author: Li Tian
    * @contact: litian_cup@163.com
    * @software: IntelliJ IDEA
    * @file: Response.java
    * @time: 2019/12/5 9:17
    * @desc:
    */
   
   public class Response {
       private BufferedWriter bw;
       // 正文
       private StringBuilder content;
       // 协议头信息：状态行与请求头、回车
       private StringBuilder headInfo;
       // 正文的字节数
       private int len;
   
       private final String BLANK = " ";
       private final String CRLF = "\r\n";
   
       public Response() {
           content = new StringBuilder();
           headInfo = new StringBuilder();
           len = 0;
       }
   
       public Response(Socket client) {
           this();
           try {
               bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
           } catch (IOException e) {
               e.printStackTrace();
               headInfo = null;
           }
       }
   
       public Response(OutputStream os) {
           this();
           bw = new BufferedWriter(new OutputStreamWriter(os));
       }
       // 动态添加内容
       public Response print(String info){
           content.append(info);
           len += info.getBytes().length;
           return this;
       }
       public Response println(String info){
           content.append(info).append(CRLF);
           len += (info + CRLF).getBytes().length;
           return this;
       }
   
       // 推送响应信息
       public void pushToBrowser(int code) throws IOException {
           if (null == headInfo){
               code = 505;
           }
           createHeadInfo(code);
           bw.append(headInfo);
           bw.append(content);
           bw.flush();
       }
   
       // 构建头信息
       private void createHeadInfo(int code) {
           // 1. 响应行：HTTP/1.1 200 OK
           headInfo.append("HTTP/1.1").append(BLANK);
           headInfo.append(code).append(BLANK);
           switch (code) {
               case 200:
                   headInfo.append("OK").append(CRLF);
                   break;
               case 404:
                   headInfo.append("NOT FOUND").append(CRLF);
                   break;
               case 505:
                   headInfo.append("SERVER ERROR").append(CRLF);
                   break;
           }
   
           // 2. 响应头（最后一行存在空行）：
           headInfo.append("Date:").append(new Date()).append(CRLF);
           headInfo.append("Server:").append("shsxt Server/0.0.1;charset=GBK").append(CRLF);
           headInfo.append("Content-type:text/html").append(CRLF);
           headInfo.append("Content-length:").append(len).append(CRLF);
           headInfo.append(CRLF);
       }
   }
   ```

### 10. 封装请求信息

- 通过分解字符串获取method、URL和请求参数

- POST请求参数可能在请求体中存在

- 分解协议

  ```java
  package com.sxt.Server_study02;
  
  import java.io.IOException;
  import java.io.InputStream;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Request.java
   * @time: 2019/12/5 10:15
   * @desc:
   */
  
  public class Request {
      private String requestInfo;
      // 请求方式
      private String method;
      // 请求url
      private String url;
      // 请求参数
      private String queryStr;
  
      private final String BLANK = " ";
      private final String CRLF = "\r\n";
  
      public Request(Socket client) throws IOException {
          this(client.getInputStream());
      }
  
      public Request(InputStream is) {
          byte[] datas = new byte[1024 * 1024];
          int len;
          try {
              len = is.read(datas);
              this.requestInfo = new String(datas, 0, len);
          } catch (IOException e) {
              e.printStackTrace();
              return;
          }
          // 分解字符串
          parseRequestInfo();
      }
  
      private void parseRequestInfo() {
          System.out.println("---分解---");
          System.out.println("1. 获取请求方式：开头到第一个/");
          this.method = this.requestInfo.substring(0, this.requestInfo.indexOf("/")).toLowerCase().trim();
          System.out.println("2. 获取请求url：第一个/ 到HTTP/");
          System.out.println("可能包含请求参数?前面的url");
          // 1. 获取/的位置
          int startIdx = this.requestInfo.indexOf("/") + 1;
          // 2. 获取HTTP/的位置
          int endIdx = this.requestInfo.indexOf("HTTP/");
          // 3. 分割字符串
          this.url = this.requestInfo.substring(startIdx, endIdx);
          // 4. 获取？的位置
          int queryIdx = this.url.indexOf("?");
          if (queryIdx >= 0) {
              // 表示存在请求参数
              String[] urlArray = this.url.split("\\?");
              this.url = urlArray[0].trim();
              queryStr = urlArray[1].trim();
          }
          System.out.println(this.url);
  
          System.out.println("3. 获取请求参数：若果Get已经获取，如果post可能在请求体中");
          if (method.equals("post")) {
              String qStr = this.requestInfo.substring(this.requestInfo.lastIndexOf(CRLF)).trim();
              if (null == queryStr) {
                  queryStr = qStr;
              } else {
                  queryStr += "&" + qStr;
              }
          }
          queryStr = null == queryStr?"": queryStr;
          System.out.println(method + "-->" + url + "-->" + queryStr);
      }
  }
  ```

  ```java
  package com.sxt.Server_study02;
  
  import java.io.IOException;
  import java.io.InputStream;
  import java.net.ServerSocket;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Server04.java
   * @time: 2019/12/4 9:26
   * @desc: 封装请求协议：获取method uri以及请求参数
   */
  
  public class Server04 {
      private ServerSocket serverSocket;
      public static void main(String[] args) {
          Server04 server = new Server04();
          server.start();
      }
  
      // 启动服务
      public void start() {
          try {
              serverSocket = new ServerSocket(8888);
              receive();
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("服务器启动失败...");
          }
      }
  
      // 接受连接处理
      public void receive() {
          try {
              Socket client = serverSocket.accept();
              System.out.println("一个客户端建立了连接...");
              // 获取请求协议
              Request request = new Request(client);
  
              Response response = new Response(client);
  
              // 关注了内容
              response.print("<html>");
              response.print("<head>");
              response.print("<title>");
              response.print("服务器响应成功");
              response.print("</title>");
              response.print("</head>");
              response.print("<body>");
              response.print("终于回来了...");
              response.print("</body>");
              response.print("</html>");
  
              // 关注了状态码
              response.pushToBrowser(200);
  
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("客户端错误...");
          }
      }
  
      // 停止服务
      public void stop() {
  
      }
  }
  
  ```

- 分解参数

  ```java
  package com.sxt.Server_study02;
  
  import java.io.IOException;
  import java.io.InputStream;
  import java.io.UnsupportedEncodingException;
  import java.net.Socket;
  import java.util.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Request2.java
   * @time: 2019/12/5 10:15
   * @desc: 封装请求协议：封装请求参数为Map
   */
  
  public class Request2 {
      private String requestInfo;
      // 请求方式
      private String method;
      // 请求url
      private String url;
      // 请求参数
      private String queryStr;
      // 存储参数
      private Map<String, List<String>> parameterMap;
  
      private final String BLANK = " ";
      private final String CRLF = "\r\n";
  
      public Request2(Socket client) throws IOException {
          this(client.getInputStream());
      }
  
      public String getMethod() {
          return method;
      }
  
      public String getUrl() {
          return url;
      }
  
      public String getQueryStr() {
          return queryStr;
      }
  
      public Request2(InputStream is) {
          parameterMap = new HashMap<>();
          byte[] datas = new byte[1024 * 1024];
          int len;
          try {
              len = is.read(datas);
              this.requestInfo = new String(datas, 0, len);
          } catch (IOException e) {
              e.printStackTrace();
              return;
          }
          // 分解字符串
          parseRequestInfo();
      }
  
      private void parseRequestInfo() {
          System.out.println("---分解---");
          System.out.println("1. 获取请求方式：开头到第一个/");
          this.method = this.requestInfo.substring(0, this.requestInfo.indexOf("/")).toLowerCase().trim();
          System.out.println("2. 获取请求url：第一个/ 到HTTP/");
          System.out.println("可能包含请求参数?前面的url");
          // 1. 获取/的位置
          int startIdx = this.requestInfo.indexOf("/") + 1;
          // 2. 获取HTTP/的位置
          int endIdx = this.requestInfo.indexOf("HTTP/");
          // 3. 分割字符串
          this.url = this.requestInfo.substring(startIdx, endIdx);
          // 4. 获取？的位置
          int queryIdx = this.url.indexOf("?");
          if (queryIdx >= 0) {
              // 表示存在请求参数
              String[] urlArray = this.url.split("\\?");
              this.url = urlArray[0].trim();
              queryStr = urlArray[1].trim();
          }
          System.out.println(this.url);
  
          System.out.println("3. 获取请求参数：若果Get已经获取，如果post可能在请求体中");
          if (method.equals("post")) {
              String qStr = this.requestInfo.substring(this.requestInfo.lastIndexOf(CRLF)).trim();
              if (null == queryStr) {
                  queryStr = qStr;
              } else {
                  queryStr += "&" + qStr;
              }
          }
          queryStr = null == queryStr?"": queryStr;
          System.out.println(method + "-->" + url + "-->" + queryStr);
          // 转成Map    fav=1&fav=2&uname=shsxt&age=18&other=
          convertMap();
      }
  
      // 处理请求参数为Map
      private void convertMap(){
          // 分割字符串 &
          String[] keyValues = this.queryStr.split("&");
          for(String queryStr: keyValues){
              // 再次分割字符串 =
              String[] kv = queryStr.split("=");
              // 保持两个长度 key 和 value
              kv = Arrays.copyOf(kv, 2);
              // 获取key 和 value
              String key = kv[0];
              String value = kv[1]==null? null: decode(kv[1], "utf-8");
              // 存储在Map中
              if(!parameterMap.containsKey(key)){
                  // 容器里面没有，第一次
                  parameterMap.put(key, new ArrayList<String>());
              }
              parameterMap.get(key).add(value);
          }
      }
  
      // 处理中文
      private String decode(String value, String enc){
          try {
              return java.net.URLDecoder.decode(value, enc);
          } catch (UnsupportedEncodingException e) {
              e.printStackTrace();
              return null;
          }
      }
  
      // 通过name获取对应的多个值
      public String[] getParameterValues(String key){
          List<String> values = this.parameterMap.get(key);
          if(null == values || values.size()<1){
              return null;
          }
          return values.toArray(new String[0]);
      }
  
      // 通过name获取对应的一个值
      public String getParameter(String key){
          String[] values = getParameterValues(key);
          return values == null?null: values[0];
      }
  }
  ```

  ```java
  package com.sxt.Server_study02;
  
  import java.io.IOException;
  import java.net.ServerSocket;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Server05.java
   * @time: 2019/12/4 9:26
   * @desc: 封装请求信息中参数转成map
   */
  
  public class Server05 {
      private ServerSocket serverSocket;
      public static void main(String[] args) {
          Server05 server = new Server05();
          server.start();
      }
  
      // 启动服务
      public void start() {
          try {
              serverSocket = new ServerSocket(8888);
              receive();
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("服务器启动失败...");
          }
      }
  
      // 接受连接处理
      public void receive() {
          try {
              Socket client = serverSocket.accept();
              System.out.println("一个客户端建立了连接...");
              // 获取请求协议
              Request2 request = new Request2(client);
  
              Response response = new Response(client);
  
              // 关注了内容
              response.print("<html>");
              response.print("<head>");
              response.print("<title>");
              response.print("服务器响应成功");
              response.print("</title>");
              response.print("</head>");
              response.print("<body>");
              response.print("终于回来了..." + request.getParameter("uname"));
              response.print("</body>");
              response.print("</html>");
  
              // 关注了状态码
              response.pushToBrowser(200);
  
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("客户端错误...");
          }
      }
  
      // 停止服务
      public void stop() {
  
      }
  }
  ```

### 11. 引入servlet

- 加入了Servlet解耦了业务代码

  ```java
  package com.sxt.Server_study03;
  
  import com.sxt.tcp.Server;
  
  import java.io.IOException;
  import java.net.ServerSocket;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Server06.java
   * @time: 2019/12/4 9:26
   * @desc: 加入了Servlet解耦了业务代码
   */
  
  public class Server06 {
      private ServerSocket serverSocket;
      public static void main(String[] args) {
          Server06 server = new Server06();
          server.start();
      }
  
      // 启动服务
      public void start() {
          try {
              serverSocket = new ServerSocket(8888);
              receive();
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("服务器启动失败...");
          }
      }
  
      // 接受连接处理
      public void receive() {
          try {
              Socket client = serverSocket.accept();
              System.out.println("一个客户端建立了连接...");
              // 获取请求协议
              Request request = new Request(client);
              Response response = new Response(client);
  
              // 关注了内容
              Servlet servlet = null;
              if(request.getUrl().equals("login")){
                  servlet = new LoginServlet();
              }else if (request.getUrl().equals("reg")){
                  servlet = new RegisterServlet();
              }else {
                  // 首页
              }
  
              servlet.service(request, response);
  
  
              // 关注了状态码
              response.pushToBrowser(200);
  
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("客户端错误...");
          }
      }
  
      // 停止服务
      public void stop() {
  
      }
  }
  ```

- Request和Response同上

- Servlet

  ```java
  package com.sxt.Server_study03;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Servlet.java
   * @time: 2019/12/9 12:03
   * @desc: 服务器小脚本接口
   */
  
  public interface Servlet {
      void service(Request request, Response response);
  }
  ```

- RegisterServlet

  ```java
  package com.sxt.Server_study03;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: RegisterServlet.java
   * @time: 2019/12/3 15:59
   * @desc:
   */
  
  public class RegisterServlet implements Servlet{
      @Override
      public void service(Request request, Response response){
          response.print("注册成功...");
      }
  }
  ```

- LoginServlet

  ```java
  package com.sxt.Server_study03;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: LoginServlet.java
   * @time: 2019/12/3 15:59
   * @desc:
   */
  
  public class LoginServlet implements Servlet {
      @Override
      public void service(Request request, Response response) {
          response.print("<html>");
          response.print("<head>");
          response.print("<title>");
          response.print("第一个servlet");
          response.print("</title>");
          response.print("</head>");
          response.print("<body>");
          response.print("欢迎回来..." + request.getParameter("uname"));
          response.print("</body>");
          response.print("</html>");
      }
  }
  ```

### 12. 整合webxml

- 将之前的Mapping，Entity，WebContext，WebHandler拷贝到工程中

- 解析web.xml代码

  ```java
  package com.sxt.Server_study03;
  
  import com.sxt.Server_study01.servlet.WebContext;
  
  import javax.xml.parsers.SAXParser;
  import javax.xml.parsers.SAXParserFactory;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: WebApp.java
   * @time: 2019/12/9 12:37
   * @desc: 解析代码
   */
  
  public class WebApp {
      private static WebContext context;
  
      static {
          try {
              // SAX解析
              // 1. 获取解析工厂
              SAXParserFactory factory = SAXParserFactory.newInstance();
              // 2. 从解析工厂获取解析器
              SAXParser parse = null;
              parse = factory.newSAXParser();
              // 3. 加载文档Document注册处理器
              // 4. 编写处理器
              WebHandler handler = new WebHandler();
              parse.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream("web.xml"), handler);
              // 5. 获取数据
              context = new WebContext(handler.getEntitys(), handler.getMappings());
  
          } catch (Exception e) {
              System.out.println("解析配置文件错误！");
          }
      }
  
      // 通过url获取配置文件对应的servlet
      public static Servlet getServletFromUrl(String url) {
          // 假设你输入了 /login or /g or /reg
          String className = context.getClz("/" + url);
          Class clz = null;
          try {
              clz = Class.forName(className);
              Servlet servlet = (Servlet) clz.getConstructor().newInstance();
              return servlet;
          } catch (Exception e) {
              e.printStackTrace();
          }
          return null;
      }
  }
  ```

- 新增OthersServlet

  ```java
  package com.sxt.Server_study03;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: OthersServlet.java
   * @time: 2019/12/9 13:17
   * @desc: 其他测试页面
   */
  
  public class OthersServlet implements Servlet{
      @Override
      public void service(Request request, Response response) {
          response.print("其他测试页面...");
      }
  }
  ```

- 修改xml

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <web-app>
      <servlet>
          <servlet-name>login</servlet-name>
          <servlet-class>com.sxt.Server_study03.LoginServlet</servlet-class>
      </servlet>
      <servlet>
          <servlet-name>reg</servlet-name>
          <servlet-class>com.sxt.Server_study03.RegisterServlet</servlet-class>
      </servlet>
      <servlet-mapping>
          <servlet-name>login</servlet-name>
          <url-pattern>/login</url-pattern>
          <url-pattern>/g</url-pattern>
      </servlet-mapping>
      <servlet-mapping>
          <servlet-name>reg</servlet-name>
          <url-pattern>/reg</url-pattern>
      </servlet-mapping>
      <servlet>
          <servlet-name>others</servlet-name>
          <servlet-class>com.sxt.Server_study03.OthersServlet</servlet-class>
      </servlet>
      <servlet-mapping>
          <servlet-name>others</servlet-name>
          <url-pattern>/o</url-pattern>
      </servlet-mapping>
  </web-app>
  ```

- 整合配置文件

  ```java
  package com.sxt.Server_study03;
  
  import java.io.IOException;
  import java.net.ServerSocket;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Server06.java
   * @time: 2019/12/4 9:26
   * @desc: 整合配置文件
   */
  
  public class Server07 {
      private ServerSocket serverSocket;
      public static void main(String[] args) {
          Server07 server = new Server07();
          server.start();
      }
  
      // 启动服务
      public void start() {
          try {
              serverSocket = new ServerSocket(8888);
              receive();
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("服务器启动失败...");
          }
      }
  
      // 接受连接处理
      public void receive() {
          try {
              Socket client = serverSocket.accept();
              System.out.println("一个客户端建立了连接...");
              // 获取请求协议
              Request request = new Request(client);
              Response response = new Response(client);
  
              Servlet servlet = WebApp.getServletFromUrl(request.getUrl());
              if(null != servlet){
                  servlet.service(request, response);
                  // 关注了状态码
                  response.pushToBrowser(200);
              }else {
                  // 错误页面...
                  response.pushToBrowser(404);
              }
  
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("客户端错误...");
          }
      }
  
      // 停止服务
      public void stop() {
  
      }
  }
  ```

### 13. 高效分发器

- 多线程处理，加入分发器

  ```java
  package com.sxt.Server_study03;
  
  import java.io.IOException;
  import java.net.ServerSocket;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Server08.java
   * @time: 2019/12/4 9:26
   * @desc: 多线程处理，加入分发器
   */
  
  public class Server08 {
      private ServerSocket serverSocket;
      private boolean isRunning;
  
      public static void main(String[] args) {
          Server08 server = new Server08();
          server.start();
      }
  
      // 启动服务
      public void start() {
          try {
              serverSocket = new ServerSocket(8888);
              isRunning = true;
              receive();
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("服务器启动失败...");
              stop();
          }
      }
  
      // 接受连接处理
      public void receive() {
          while (isRunning) {
              try {
                  Socket client = serverSocket.accept();
                  System.out.println("一个客户端建立了连接...");
                  // 多线程处理
                  new Thread(new Dispatcher(client)).start();
              } catch (IOException e) {
                  e.printStackTrace();
                  System.out.println("客户端错误...");
              }
          }
      }
  
      // 停止服务
      public void stop() {
          isRunning = false;
          try {
              this.serverSocket.close();
              System.out.println("服务器已停止...");
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```

- 分发器

  ```java
  package com.sxt.Server_study03;
  
  import java.io.IOException;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Dispatcher.java
   * @time: 2019/12/12 16:36
   * @desc: 分发器
   */
  
  public class Dispatcher implements Runnable {
      private Socket client;
      private Request request;
      private Response response;
  
      public Dispatcher(Socket client) {
          this.client = client;
          try {
              // 获取请求和响应
              request = new Request(client);
              response = new Response(client);
          } catch (IOException e) {
              e.printStackTrace();
              this.release();
          }
      }
  
      @Override
      public void run() {
          try {
              Servlet servlet = WebApp.getServletFromUrl(request.getUrl());
              if (null != servlet) {
                  servlet.service(request, response);
                  // 关注了状态码
                  response.pushToBrowser(200);
              } else {
                  // 错误页面...
                  response.pushToBrowser(404);
              }
          }catch (Exception e){
              try {
                  response.pushToBrowser(500);
              } catch (IOException ex) {
                  ex.printStackTrace();
              }
          }
          release();
      }
  
      // 释放资源
      private void release() {
          try {
              client.close();
          } catch (IOException ex) {
              ex.printStackTrace();
          }
      }
  }
  ```

### 14. 经典404及首页处理

- 这一部分有问题is.readAllBytes()这里报错，并且也没有找到解决办法

- 分发器

  ```java
  package com.sxt.Server_study03;
  
  import java.io.IOException;
  import java.io.InputStream;
  import java.net.Socket;
  import java.nio.file.Files;
  import java.nio.file.Paths;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Dispatcher.java
   * @time: 2019/12/12 16:36
   * @desc: 分发器
   */
  
  public class Dispatcher implements Runnable {
      private Socket client;
      private Request request;
      private Response response;
  
      public Dispatcher(Socket client) {
          this.client = client;
          try {
              // 获取请求和响应
              request = new Request(client);
              response = new Response(client);
          } catch (IOException e) {
              e.printStackTrace();
              this.release();
          }
      }
  
      @Override
      public void run() {
          try {
              if (null == request.getUrl() || request.getUrl().equals("")) {
                  InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("index.html");
                  response.print(new String(is.readAllBytes()));
                  response.println(new String(Files.readAllBytes(Paths.get("index.html"))));
                  response.pushToBrowser(200);
                  is.close();
                  return;
              }
              Servlet servlet = WebApp.getServletFromUrl(request.getUrl());
              if (null != servlet) {
                  servlet.service(request, response);
                  // 关注了状态码
                  response.pushToBrowser(200);
              } else {
                  InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("error.html");
                  response.print(new String(is.readAllBytes()));
                  response.pushToBrowser(404);
                  is.close();
              }
          } catch (Exception e) {
              try {
                  response.print("你好我不好，我会马上好");
                  response.pushToBrowser(500);
              } catch (IOException ex) {
                  ex.printStackTrace();
              }
          }
          release();
      }
  
      // 释放资源
      private void release() {
          try {
              client.close();
          } catch (IOException ex) {
              ex.printStackTrace();
          }
      }
  }
  ```

- 处理404/505和首页

  ```java
  package com.sxt.Server_study03;
  
  import java.io.IOException;
  import java.net.ServerSocket;
  import java.net.Socket;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Server08.java
   * @time: 2019/12/4 9:26
   * @desc: 处理404/505和首页
   */
  
  public class Server09 {
      private ServerSocket serverSocket;
      private boolean isRunning;
  
      public static void main(String[] args) {
          Server09 server = new Server09();
          server.start();
      }
  
      // 启动服务
      public void start() {
          try {
              serverSocket = new ServerSocket(8888);
              isRunning = true;
              receive();
          } catch (IOException e) {
              e.printStackTrace();
              System.out.println("服务器启动失败...");
              stop();
          }
      }
  
      // 接受连接处理
      public void receive() {
          while (isRunning) {
              try {
                  Socket client = serverSocket.accept();
                  System.out.println("一个客户端建立了连接...");
                  // 多线程处理
                  new Thread(new Dispatcher(client)).start();
              } catch (IOException e) {
                  e.printStackTrace();
                  System.out.println("客户端错误...");
              }
          }
      }
  
      // 停止服务
      public void stop() {
          isRunning = false;
          try {
              this.serverSocket.close();
              System.out.println("服务器已停止...");
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```

## 第2章 注解+反射+字节码+类加载机制

### 1. 内置注解

- Annotation

- 作用

  - 不是程序本身，可以对程序作出解释。
  - 可以被其他程序（比如：编译器等）读取。

- 格式

  - @注解名

  ```java
  package com.sxt.test.annotation;
  
  import java.util.ArrayList;
  import java.util.Date;
  import java.util.List;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Demo01.java
   * @time: 2019/12/16 9:34
   * @desc:
   */
  
  public class Demo01 {
      @Override
      // 重写父类方法
      public String toString() {
          return "";
      }
  
      @Deprecated
      // 该方法不建议使用
      public static void test1() {
          System.out.println("你大爷");
      }
  
      @SuppressWarnings("all")
      // 不显示所有警告信息
      public static void test2() {
          List list = new ArrayList();
      }
  
      @SuppressWarnings(value = {"unchecked", "deprecation"})
      // 不显示某几个警告信息
      public static void main(String[] args) {
          test1();
      }
  }
  ```

### 2. 自定义注解

- 使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口
- 要点
  - interface用来声明一个注解
  - 格式为：public @interface 注解名 {定义体}
- 其中的每一个方法实际上是声明了一个配置参数
  - 方法的名称就是参数的名称
  - 返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。
  - 可以通过default来声明参数的默认值
  - 如果只有一个参数成员，一般参数名为value
- 元注解
  - 负责注解其他注解。
  - @Target：用于描述注解的使用范围
  - @Retention：表示需要在什么级别保存该注解信息，用于描述注解的生命周期
  - @Documented
  - @Inherited

### 3. 反射机制读取注解

- ORM：Object Relationship Mapping，对象关系映射

  - 类和表结构对应
  - 属性和字段对应
  - 对象和记录对应

- 使用注解完成类和表结构的映射关系

  - 类注解

    ```java
    package com.sxt.test.annotation;
    
    import java.lang.annotation.ElementType;
    import java.lang.annotation.Retention;
    import java.lang.annotation.RetentionPolicy;
    import java.lang.annotation.Target;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LTTable.java
     * @time: 2019/12/16 12:44
     * @desc:
     */
    
    @Target(value = {ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface LTTable {
        String value();
    }
    ```

  - 属性注解

    ```java
    package com.sxt.test.annotation;
    
    import java.lang.annotation.ElementType;
    import java.lang.annotation.Retention;
    import java.lang.annotation.RetentionPolicy;
    import java.lang.annotation.Target;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LTField.java
     * @time: 2019/12/16 12:46
     * @desc: 说明属性的特征
     */
    
    @Target(value = {ElementType.FIELD})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface LTField {
        String columnName();
        String type();
        int length();
    }
    ```

  - 学生类

    ```java
    package com.sxt.test.annotation;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Student.java
     * @time: 2019/12/16 12:43
     * @desc:
     */
    
    @LTTable("tb_student")
    public class Student {
    
        @LTField(columnName = "id", type = "int", length = 10)
        private int id;
        @LTField(columnName = "sname", type = "varchar", length = 10)
        private String studentName;
        @LTField(columnName = "age", type = "int", length = 3)
        private int age;
    
        public int getId() {
            return id;
        }
    
        public void setId(int id) {
            this.id = id;
        }
    
        public String getStudentName() {
            return studentName;
        }
    
        public void setStudentName(String studentName) {
            this.studentName = studentName;
        }
    
        public int getAge() {
            return age;
        }
    
        public void setAge(int age) {
            this.age = age;
        }
    }
    ```

  - 使用反射读取注解的信息，模拟处理注解信息的流程

    ```java
    package com.sxt.test.annotation;
    
    import java.lang.annotation.Annotation;
    import java.lang.reflect.Field;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Demo03.java
     * @time: 2019/12/16 12:49
     * @desc: 使用反射读取注解的信息，模拟处理注解信息的流程
     */
    
    public class Demo03 {
        public static void main(String[] args) {
            try {
                Class clazz = Class.forName("com.sxt.test.annotation.Student");
    
                // 获得类的所有有效注解
                Annotation[] annotations = clazz.getAnnotations();
                for (Annotation a : annotations) {
                    System.out.println(a);
                }
    
                // 获得类的指定的注解
                LTTable st = (LTTable) clazz.getAnnotation(LTTable.class);
                System.out.println(st.value());
    
                // 获得类的属性的注解
                Field f = clazz.getDeclaredField("studentName");
                LTField ltField = f.getAnnotation(LTField.class);
                System.out.println(ltField.columnName()+"-->"+ltField.type()+"-->"+ltField.length());
    
                // 根据获得的表明、字段的信息，拼出DDL语句，然后使用JDBC执行这个SQL，在数据库中生成相关的表
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    ```

### 4. 反射机制

- 介绍+Class对象获取

  - 动态语言：程序运行时，可以改变程序结构或变态类型。（如python、javascript）

  - Java不是动态语言，但可以称为“准动态语言”。Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。

  - 反射机制

    - 指的是可以于运行时加载、探知、使用编译期间完全未知的类。

  - 测试各种类型对应的java.lang.Class对象的获取方式

    ```java
    package com.sxt.test.reflection;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Demo01.java
     * @time: 2019/12/17 18:59
     * @desc: 测试各种类型对应的java.lang.Class对象的获取方式
     */
    
    public class Demo01 {
        public static void main(String[] args) {
            String path = "com.sxt.test.bean.User";
            try {
                Class clazz = Class.forName(path);
                // 对象是表示或封装一些数据。一个类被加载后，JVM会创建一个对应该类的Class对象，
                // 类的整个结构信息会放到对应的Class对象中。这个Class对象就像一面镜子一样，
                // 通过这面镜子我们可以看到对应类的全部信息。
                System.out.println(clazz);
                System.out.println(clazz.hashCode());
    
                // 一个类只对应一个Class对象
                Class clazz2 = Class.forName(path);
                System.out.println(clazz2.hashCode());
    
                Class strClazz = String.class;
                Class strClazz2 = path.getClass();
                // 获得的都是String的Class对象
                System.out.println(strClazz==strClazz2);
    
                Class intClazz = int.class;
                System.out.println(intClazz.hashCode());
    
                // 数组跟维度、类型都有关
                int[] arr01 = new int[10];
                int[] arr02 = new int[30];
                int[][] arr03 = new int[10][10];
                double[] arr04 = new double[10];
                System.out.println(arr01.getClass().hashCode() == arr02.getClass().hashCode());
                System.out.println(arr01.getClass().hashCode() == arr03.getClass().hashCode());
                System.out.println(arr01.getClass().hashCode() == arr04.getClass().hashCode());
    
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    ```

- 动态操作+构造器+方法+属性

  - 应用反射的API获取类的信息（类的名字、属性、方法、构造器等）

    ```java
    package com.sxt.test.reflection;
    
    import java.lang.reflect.Constructor;
    import java.lang.reflect.Field;
    import java.lang.reflect.Method;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Demo02.java
     * @time: 2020/1/7 14:33
     * @desc: 应用反射的API获取类的信息（类的名字、属性、方法、构造器等）
     */
    
    public class Demo02 {
        public static void main(String[] args) {
            String path = "com.sxt.test.bean.User";
            try {
                Class clazz = Class.forName(path);
    
                // 获取类的全名
                System.out.println(clazz.getName());
                // 获取类的包名+全名
                System.out.println(clazz.getSimpleName());
    
                // 获取属性信息
                // 只能获得public的field
                // Field[] fields = clazz.getFields();
                // 返回所有的field
                Field[] fields = clazz.getDeclaredFields();
                System.out.println(fields.length);
                for(Field temp: fields){
                    System.out.println("属性：" + temp);
                }
    
                // 通过名称获取属性
                Field f = clazz.getDeclaredField("uname");
                System.out.println(f);
    
                // 获取方法信息
                Method[] methods = clazz.getDeclaredMethods();
                Method m1 = clazz.getDeclaredMethod("getUname");
                Method m2 = clazz.getDeclaredMethod("setUname", String.class);
                for(Method temp: methods){
                    System.out.println("方法：" + temp);
                }
    
                // 获取构造器信息
                Constructor[] constructors = clazz.getDeclaredConstructors();
                for(Constructor temp: constructors){
                    System.out.println("构造器：" + temp);
                }
                // 获取某个特定的构造器
                Constructor c1 = clazz.getDeclaredConstructor();
                System.out.println("无参构造器：" + c1);
                Constructor c2 = clazz.getDeclaredConstructor(int.class, int.class, String.class);
                System.out.println("有参构造器：" + c2);
    
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    ```

  - 通过反射API动态的操作：构造器、方法、属性

    ```java
    package com.sxt.test.reflection;
    
    import com.sxt.test.bean.User;
    
    import java.lang.reflect.Constructor;
    import java.lang.reflect.Field;
    import java.lang.reflect.Method;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Demo3.java
     * @time: 2020/1/8 17:03
     * @desc: 通过反射API动态的操作：构造器、方法、属性
     */
    
    public class Demo3 {
        public static void main(String[] args) {
            String path = "com.sxt.test.bean.User";
            try {
                Class<User> clazz = (Class<User>) Class.forName(path);
    
                // 通过反射API调用构造方法，构造对象
                // 其实是调用了User的无参构造方法
                User u = clazz.newInstance();
                System.out.println(u);
    
                // 指定构造器的调用
                Constructor<User> c = clazz.getDeclaredConstructor(int.class, int.class, String.class);
                User u2 = c.newInstance(1001, 18, "李英俊");
                System.out.println(u2.getUname());
    
                // 通过反射API调用普通方法
                User u3 = clazz.newInstance();
                u3.setUname("李不羁");
                // 上一句用反射来写如下
                Method method = clazz.getDeclaredMethod("setUname", String.class);
                method.invoke(u3, "李不羁");
                System.out.println(u3.getUname());
    
                // 通过反射API操作属性
                User u4 = clazz.newInstance();
                Field f = clazz.getDeclaredField("uname");
                // 这个属性不需要做安全检查了，可以直接访问
                f.setAccessible(true);
                // 通过反射直接写属性
                f.set(u4, "李傻瓜");
                System.out.println(u4.getUname());
                // 通过反射直接读属性的值
                System.out.println(f.get(u4));
    
    
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    ```

- 提高反射效率+操作泛型+操作注解

  - setAccessible

    - 启用和禁用访问安全检查的开关，值为true则指示反射的对象在使用时应该取消java语言访问检查。值为false则指示反射的对象应该实施java语言访问检查。并不是为true就能访问，为false就不能访问。
    - 禁止安全检查，可以提高反射的运行速度。

  - 反射操作泛型（Generic）

    - java采用泛型擦除的机制来引入泛型。java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的麻烦。但是，一旦变异完成，所有的和泛型有关的类型全部擦除。
    - 为了通过反射操作这些类型以迎合实际开发的需要，java就新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型

  - 操作泛型

    ```java
    package com.sxt.test.reflection;
    
    import com.sxt.test.bean.User;
    
    import java.lang.reflect.Method;
    import java.lang.reflect.ParameterizedType;
    import java.lang.reflect.Type;
    import java.util.List;
    import java.util.Map;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Demo4.java
     * @time: 2020/1/9 10:44
     * @desc: 操作泛型
     */
    
    public class Demo4 {
        public void test01(Map<String, User> map, List<User> list){
            System.out.println("Demo04.test01()");
        }
    
        public Map<Integer, User> test02(){
            System.out.println("Demo04.test02()");
            return null;
        }
    
        public static void main(String[] args){
            try{
                // 获得指定方法参数泛型信息
                Method m = Demo4.class.getMethod("test01", Map.class, List.class);
                Type[] t = m.getGenericParameterTypes();
                for (Type paramType: t){
                    System.out.println("#" + paramType);
                    if(paramType instanceof ParameterizedType){
                        Type[] genericTypes = ((ParameterizedType) paramType).getActualTypeArguments();
                        for (Type genericType: genericTypes){
                            System.out.println("泛型类型：" + genericType);
                        }
                    }
                }
    
                // 获得指定方法返回值泛型信息
                Method m2 = Demo4.class.getMethod("test02");
                Type returnType = m2.getGenericReturnType();
                if(returnType instanceof ParameterizedType){
                    Type[] genericTypes = ((ParameterizedType) returnType).getActualTypeArguments();
    
                    for (Type genericType: genericTypes){
                            System.out.println("返回值，泛型类型：" + genericType);
                        }
                }
            } catch (NoSuchMethodException e) {
                e.printStackTrace();
            }
        }
    }
    ```

  - 操作注解

    ```java
    package com.sxt.test.annotation;
    
    import java.lang.annotation.Annotation;
    import java.lang.reflect.Field;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Demo5.java
     * @time: 2020/1/9 10:57
     * @desc: 操作注解
     */
    
    public class Demo5 {
        public static void main(String[] args) {
            try {
                Class clazz = Class.forName("com.sxt.test.annotation.Student");
    
                // 获得类的所有有效注解
                Annotation[] annotations = clazz.getAnnotations();
                for (Annotation a : annotations) {
                    System.out.println(a);
                }
    
                // 获得类指定的注解
                LTTable st = (LTTable) clazz.getAnnotation(LTTable.class);
                System.out.println(st.value());
    
                // 获得类的属性的注解
                Field f = clazz.getDeclaredField("studentName");
                LTField ltField = f.getAnnotation(LTField.class);
                System.out.println(ltField.columnName() + "--" + ltField.type() + "--" + ltField.length());
    
                // 根据获得的表名、字段的信息，拼出DDL语句，然后，使用JDBC执行这个SQL，在数据库中生成相关的表
    
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    ```

### 5. 动态编译

- 通过JavaCompiler动态编译

  ```java
  public static int compileFile(String sourceFile){
  	// 动态编译
  	JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
  	int result = compiler.run(null, null, null, sourceFile);
  	System.out.println(result==0?"编译成功": "编译失败");
  	return result;
  }
  ```

  - 参数1：为java编译器提供参数
  - 参数2：得到Java编译器的输出信息
  - 参数3：接受编译器的错误信息
  - 参数4：可变参数（是一个String数组）能传入一个或多个java源文件
  - 返回值：0表示编译成功，非0表示编译失败

  ```java
  package com.sxt.test.testDynamicCompile;
  
  import javax.tools.JavaCompiler;
  import javax.tools.ToolProvider;
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.lang.reflect.Method;
  import java.net.URL;
  import java.net.URLClassLoader;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Demo1.java
   * @time: 2020/1/9 14:38
   * @desc: 动态编译
   */
  
  public class Demo1 {
      public static void main(String[] args) throws IOException {
  
          // 如果是给的字符串的话，可以
          // 通过IO流操作，将字符串存储成一个临时文件，然后调用动态编译方法！
          // 如果是文件的话，就按下面的方法
          JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
          int result = compiler.run(null, null, null, "D:\\java_test\\HelloWorld.java");
          System.out.println(result == 0 ? "编译成功" : "编译失败");
  
          // 上面只是进行了编译，下面还要进行动态运行编译好的类
          
          // 1. 通过Runtime调用执行类
          Runtime run = Runtime.getRuntime();
          Process process = run.exec("java -cp D:\\java_test HelloWorld");
          InputStream in = process.getInputStream();
          BufferedReader reader = new BufferedReader(new InputStreamReader(in));
          String info = "";
          while ((info = reader.readLine()) != null) {
              System.out.println(info);
          }
  
          // 2. 通过反射调用执行类
          try {
              URL[] urls = new URL[]{new URL("file:/" + "D:\\java_test\\")};
              URLClassLoader loader = new URLClassLoader(urls);
              Class c = loader.loadClass("HelloWorld");
              // 调用加载类的main方法
              Method m = c.getMethod("main", String[].class);
              // 如果这里不用Object强制转型的话，invoke后面传入的就不是一个String
              // 的字符串数组，而是两个字符串，认为是两个参数，于是就会发生参数个数不匹配的问题
              m.invoke(null, (Object) new String[]{});
  
          } catch (Exception e) {
              e.printStackTrace();
          }
      }
  }
  ```

### 6. 脚本引擎执行JavaScript代码__Rhino引擎

- JAVA脚本引擎是从JDK6.0之后添加的新功能
  - 使得Java应用程序可以通过一套固定的借口与各种脚本引擎交互，从而达到在Java平台上调用各种脚本语言的目的。
  - Java脚本API是连通Java平台和脚本语言的桥梁。
  - 可以把一些复杂异变的业务逻辑交给脚本语言处理，这又大大提高了开发效率。
  
- 在写Demo的时候存在一些报错的情况，这是因为JDK6.0的语法在JDK8.0中已经过时了
  - println报错：改成print
  - importPackage报错：改成不导入包，后面直接使用java.util.Arrays.asList
  
  ```javascript
  function test(){
      var a = 3;
      var b = 4;
      print("invoke js file: " + (a+b));
  }
  
  // 执行test方法
  test();
  ```
  
  ```java
  package com.sxt.test.testRhino;
  
  import javax.script.Invocable;
  import javax.script.ScriptEngine;
  import javax.script.ScriptEngineManager;
  import java.io.FileReader;
  import java.net.URL;
  import java.util.List;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Demo01.java
   * @time: 2020/1/13 15:58
   * @desc: 测试脚本引擎执行JavaScript代码
   */
  
  public class Demo01 {
      public static void main(String[] args) throws Exception {
          // 获得脚本引擎的对象
          ScriptEngineManager sem = new ScriptEngineManager();
          ScriptEngine engine = sem.getEngineByName("javascript");
  
          // 定义变量，存储到引擎上下文中
          engine.put("msg", "liyingjun is g good man!");
          String str = "var user = {name: 'litian', age: 18, schools: ['清华大学', '北京尚学堂']};";
          str += "print(user.name);";
  
          // 执行脚本
          engine.eval(str);
          engine.eval("msg = 'sxt is a good school!'");
          System.out.println(engine.get("msg"));
          System.out.println("########################");
  
          // 定义函数
          engine.eval("function add(a, b){var sum = a + b; return sum;}");
          // 取得调用接口
          Invocable jsInvoke = (Invocable) engine;
          // 执行脚本中定义的方法
          Object result1 = jsInvoke.invokeFunction("add", new Object[]{13, 20});
          System.out.println(result1);
  
          // 导入其他java包，使用其他包中的java类
          String jsCode = "var list=java.util.Arrays.asList([\"北京尚学堂\", \"清华大学\", \"中国石油大学\"]);";
          engine.eval(jsCode);
  
          List<String> list2 = (List<String>) engine.get("list");
          for (String temp : list2) {
              System.out.println(temp);
          }
  
          // 执行一个js文件
          URL url = Demo01.class.getClassLoader().getResource("com/sxt/test/testRhino/test.js");
          FileReader fr = new FileReader(url.getPath());
          engine.eval(fr);
          fr.close();
      }
  }
  ```

### 7. 字节码操作__javassist库

- Java动态性的两种常见实现方式：

  - 字节码操作
  - 反射

- 运行时操作字节码可以让我们实现如下功能：

  - 动态生成新的类
  - 动态改变某个类的结构（添加/删除/修改 新的属性/方法）

- 优势

  - 比反射开销小，性能高
  - JAVAssist性能高于反射，低于ASM

- 常见的字节码操作类库

  - BCEL
  - ASM
  - CGLIB
  - Javassist

- 测试使用javassist生成一个新的类

  ```java
  package com.sxt.test.testJavassist;
  
  import javassist.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Demo1.java
   * @time: 2020/1/14 9:21
   * @desc: 测试使用javassist生成一个新的类
   */
  
  public class Demo1 {
      public static void main(String[] args) throws Exception {
          ClassPool pool = ClassPool.getDefault();
          CtClass cc = pool.makeClass("com.sxt.test.testJavassist.EmpTest");
  
          // 创建属性
          CtField f1 = CtField.make("private int empno;", cc);
          CtField f2 = CtField.make("private String ename;", cc);
          cc.addField(f1);
          cc.addField(f2);
  
          // 创建方法
          CtMethod m1 = CtMethod.make("public int getEmpno(){return empno;}", cc);
          CtMethod m2 = CtMethod.make("public void setEmpno(int empno){this.empno=empno;}", cc);
          cc.addMethod(m1);
          cc.addMethod(m2);
  
          // 添加构造器
          CtConstructor constructor = new CtConstructor(new CtClass[]{CtClass.intType, pool.get("java.lang.String")}, cc);
          constructor.setBody("{this.empno = empno; this.ename = ename;}");
          cc.addConstructor(constructor);
  
          // 将上面构造好的类写入到下面的工作空间下面
          cc.writeFile("D:\\java_test");
          System.out.println("生成类，成功！");
  
      }
  }
  ```

- 测试javassist的API

  - Emp.java

    ```java
    package com.sxt.test.testJavassist;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Emp.java
     * @time: 2020/1/14 9:28
     * @desc:
     */
    
    @Author(name="litian", year=2020)
    public class Emp {
        private int empno;
        private String name;
    
        public int getEmpno() {
            return empno;
        }
    
        public void setEmpno(int empno) {
            this.empno = empno;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public Emp() {
        }
    
        public Emp(int empno, String name) {
            this.empno = empno;
            this.name = name;
        }
    
        public void sayHello(int a){
            System.out.println("Hello!: " + a);
        }
    }
    ```

  - Author.java

    ```java
    package com.sxt.test.testJavassist;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Author.java
     * @time: 2020/1/14 14:50
     * @desc:
     */
    
    public @interface Author {
        String name();
        int year();
    }
    ```

  - 测试javassist的API

    ```java
    package com.sxt.test.testJavassist;
    
    import javassist.*;
    
    import java.lang.reflect.Method;
    import java.util.Arrays;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Demo2.java
     * @time: 2020/1/14 10:45
     * @desc: 测试javassist的API
     */
    
    public class Demo2 {
        /*
          处理类的基本用法
         */
        public static void test1() throws Exception {
            ClassPool pool = ClassPool.getDefault();
            CtClass cc = pool.get("com.sxt.test.testJavassist.Emp");
    
            byte[] bytes = cc.toBytecode();
            System.out.println(Arrays.toString(bytes));
    
            // 获取类名
            System.out.println(cc.getName());
            // 获取简要类名
            System.out.println(cc.getSimpleName());
            // 获得父类
            System.out.println(cc.getSuperclass());
            // 获得接口
            System.out.println(cc.getInterfaces());
        }
    
        public static void test2() throws Exception {
            /*
            测试产生新的方法
             */
            ClassPool pool = ClassPool.getDefault();
            CtClass cc = pool.get("com.sxt.test.testJavassist.Emp");
    
            // 新建方法1
            CtMethod m1 = CtNewMethod.make("public int add(int a, int b){return a+b;}", cc);
            // 新建方法2
            CtMethod m2 = new CtMethod(CtClass.intType, "add", new CtClass[]{CtClass.intType, CtClass.intType}, cc);
            // 设置权限
            m2.setModifiers(Modifier.PUBLIC);
            // 设置方法体 $1等等代表的是形参的占位符
            m2.setBody("{System.out.println(\"冲冲冲！\"); return $1+$2;}");
    
            cc.addMethod(m2);
    
            // 通过反射调用新生成的方法
            Class clazz = cc.toClass();
            // 通过调用Emp无参构造器，创建新的Emp对象
            Object obj = clazz.newInstance();
            Method method = clazz.getDeclaredMethod("add", int.class, int.class);
            Object result = method.invoke(obj, 200, 300);
            System.out.println(result);
        }
    
        public static void test3() throws Exception {
            /*
            对已有的方法进行修改
             */
            ClassPool pool = ClassPool.getDefault();
            CtClass cc = pool.get("com.sxt.test.testJavassist.Emp");
    
            CtMethod cm = cc.getDeclaredMethod("sayHello", new CtClass[]{CtClass.intType});
            cm.insertBefore("System.out.println($1);System.out.println(\"start!!!\");");
            cm.insertAfter("System.out.println(\"end!!!\");");
            // 在某一行前面加代码，从1开始计数，不存在迭代效应，也就是改行代码的行数不会因加入了新的代码而改变
            cm.insertAt(41, "System.out.println(\"???\");");
            cm.insertAt(42, "System.out.println(\"!!!\");");
    
            // 通过反射调用新生成的方法
            Class clazz = cc.toClass();
            Object obj = clazz.newInstance();
            Method method = clazz.getDeclaredMethod("sayHello", int.class);
            Object result = method.invoke(obj, 200);
            System.out.println(result);
    
        }
    
        public static void test4() throws Exception {
            /*
            对已有的属性进行修改
             */
            ClassPool pool = ClassPool.getDefault();
            CtClass cc = pool.get("com.sxt.test.testJavassist.Emp");
    
            // CtField f1 = CtField.make("private int empno;", cc);
            CtField f1 = new CtField(CtClass.intType, "salary", cc);
            f1.setModifiers(Modifier.PRIVATE);
            // 后面的参数是默认值，如果不写的话，就没有默认值
            cc.addField(f1, "1000");
            // 获取指定的属性
            cc.getDeclaredField("salary");
    
            // 除了直接通过增加方法的方式提供getter和setter方法，还可以通过以下方式
            cc.addMethod(CtNewMethod.getter("getSalary", f1));
            cc.addMethod(CtNewMethod.setter("setSalary", f1));
        }
    
        public static void test5() throws Exception {
            /*
            查看已有构造方法，并进行修改
             */
            ClassPool pool = ClassPool.getDefault();
            CtClass cc = pool.get("com.sxt.test.testJavassist.Emp");
    
            CtConstructor[] cs = cc.getConstructors();
            for (CtConstructor c : cs) {
                System.out.println(c.getLongName());
                c.insertBefore("System.out.println(\"what？\");");
            }
            // 通过反射调用新生成的方法
            Class clazz = cc.toClass();
            Object obj = clazz.newInstance();
        }
    
        public static void test6() throws Exception {
            /*
            注解
             */
            ClassPool pool = ClassPool.getDefault();
            CtClass cc = pool.get("com.sxt.test.testJavassist.Emp");
            Object[] all = cc.getAnnotations();
            Author a = (Author) all[0];
            String name = a.name();
            int year = a.year();
            System.out.println("name: " + name + "year: " + year);
        }
    
        public static void main(String[] args) throws Exception {
            test6();
        }
    }
    ```

- Javassist库的局限性

  - 不支持泛型、枚举等新语法，不支持注解修改，但可以通过底层的javassist类来解决。
  - 不支持数组的初始化
  - 不支持内部类和匿名类
  - 不支持continue和break表达式
  - 对于集成关系，有些不支持

### 8. JVM核心机制

- JVM运行和类加载全过程
  
  - 类的加载机制（JVM内存分析+反射机制核心原理+常量池理解）
    
    - JVM把class文件加载到内存，并对数据进行校验、解析和初始化，最终形成JVM可以直接使用的Java类型的过程。
    
    - 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。
    
    - 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程
    
      - 验证：确保加载的类信息符合JVM规范，没有安全方面的问题。
      - 准备：正式为类变量(static变量)分配内存并设置类变量初始值的阶段，这些内存都将在方法去中进行分配
      - 解析：虚拟机常量池内的**符号引用**替换为**直接引用**的过程。
    
    - 初始化
    
      - 初始化阶段是执行类构造器`<clinit>()`方法的过程。类构造器`<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的。
      - 当初始化一个类额时候，如果发现其父类还没有进行过初始化、则需要先进行其父类的初始化
      - 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确加锁和同步。
      - 当访问一个Java类的静态域时，只有真正声明这个域的类才会被初始化。
    
    - 过程图解 
    
      ![过程图解](https://img-blog.csdnimg.cn/20200116145924784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
    
  - 初始化时机+静态初始化块执行的顺序问题
  
    - 静态变量、静态域、field本质上是一回事
    - 类构造方法就是把静态域复制的动作以及静态初始化块合并在一起形成一个类构造器
    - 先调类构造方法，然后才调普通方法；先调父类的类构造方法，然后才调子类的
    - 类的加载和初始化只执行一次。
  
  - 类的主动引用和被动引用
  
    - 类的主动引用（一定会发生类的初始化）
      - new一个类的对象
      - 调用类的静态成员（除了final常量）和静态方法
      - 使用java.lang.reflect包的方法对类进行反射调用
      - 当虚拟机启动，java Hello，则一定会初始化Hello类，说白了就是先启动main方法所在的类
      - 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类
    - 类的被动引用（不会发生类的初始化）
      - 当访问一个静态域时，只有真正声明这个域的类才会被初始化（通过子类引用父类的静态变量，不会导致子类初始化）
      - 通过数组定义类引用，不会触发此类的初始化
      - 引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）
  
- 深入类加载器

  - 类加载器原理
    
    - 类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区数据的访问入口。
    
  - 类加载器树状结构、双亲委托（代理）机制
  
    - 分类：
  
      - 引导类加载器（C）
      - 扩展类加载器（JAVA）
      - 应用程序类加载器（JAVA）
      - 自定义类加载器（JAVA）
      - 除了引导类，其他的类都要继承ClassLoader，其基本职责就是根据一个指定的类的名称，找到或者生成相应的字节代码，然后从这些字节代码中定义出一个Java类，即java.lang.Class类的一个实例；除此之外，ClassLoader还负责加载java应用所需的资源，如图像文件和配置文件等。
  
    - 类加载器的代理模式
  
      - 交给其他加载器来加载指定的类
      - **双亲委托机制**是**代理模式**的一种，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次追溯，直到最高的爷爷辈的，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。
      - 双亲委托机制是为了**保证Java核心库的类型安全**。这种机制就保证不会出现用户自己能定义java.lang.Obejct类的情况。
      - **类加载器除了用于加载类，也是安全的最基本的保障。**
      - 并不是所有的类加载器都采用双亲委托机制。（tomcat的加载顺序是相反的）
  
    - 类加载器实战
  
      ```java
      package com.sxt.test.classLoader;
      
      /**
       * @author: Li Tian
       * @contact: litian_cup@163.com
       * @software: IntelliJ IDEA
       * @file: Demo01.java
       * @time: 2020/1/30 21:40
       * @desc:
       */
      
      public class Demo01 {
          public static void main(String[] args){
              // 应用加载器
              System.out.println(ClassLoader.getSystemClassLoader());
              // 扩展加载器（上一个的父类）
              System.out.println(ClassLoader.getSystemClassLoader().getParent());
              // 引导加载器，但是是C写的，所以为null（上一个的父类）
              System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent());
      
              // 系统中类的路径
              System.out.println(System.getProperty("java.class.path"));
          }
      }
      ```
  
  - 自定义类加载器（文件、网路、加密）
  
    - 自定义加载器的流程：
  
      - 继承java.lang.ClassLoader
      - 检查请求的类型是否已经被这个类加载器装载到命名空间了，如果已经装载，直接返回；
      - 委派类加载请求给父类加载器，如果父类加载器能够完成，则返回父类加载器加载的Class实例；
      - 调用本类加载器的findClass(...)方法，试图获取对应的字节码，如果获取的到，则调用defineClass(...)导入类型到方法区；如果获取不到对应的字节码或者其他原因失败，则返回异常给loadClass(...)，loadClass(...)转抛异常，终止加载过程。
      - **注意：被两个类加载器加载的同一个类，JVM不认为是相同的类。**
  
    - 自定义文件系统类加载器
  
      - FileSystemClassLoader
  
        ```java
        package com.sxt.test.classLoader;
        
        import java.io.*;
        
        /**
         * @author: Li Tian
         * @contact: litian_cup@163.com
         * @software: IntelliJ IDEA
         * @file: FileSystemClassLoader.java
         * @time: 2020/1/31 20:58
         * @desc: 自定义文件系统类加载器
         */
        
        public class FileSystemClassLoader extends ClassLoader {
            // com.sxt.test.bean.User --> F:/BookStudy/else/JAVAPro/src/com/sxt/test/bean/User.class
            private String rootDir;
        
            public FileSystemClassLoader(String rootDir) {
                this.rootDir = rootDir;
            }
        
            @Override
            protected Class<?> findClass(String name) throws ClassNotFoundException {
                Class<?> c = findLoadedClass(name);
        
                // 应该要先查询有没有加载过这个类，如果已经加载，则直接返回加载好的类，如果没有，则加载新的类。
                if (c != null) {
                    return c;
                } else {
                    ClassLoader parent = this.getParent();
                    // 委派给父类加载
                    try {
                        c = parent.loadClass(name);
                    }catch (Exception e){
                        System.out.println("父类加载器没有加载到这个类哦！");
                    }
                    if (c != null) {
                        return c;
                    } else {
                        byte[] classData = getClassData(name);
                        if (classData == null) {
                            throw new ClassNotFoundException();
                        } else {
                            c = defineClass(name, classData, 0, classData.length);
                        }
                    }
                }
                return c;
            }
        
            private byte[] getClassData(String classname) {
                String path = rootDir + "/" + classname.replace('.', '/') + ".class";
                // 可以使用IOUtils将流中的数据转成字节数组，这里采用手写了
                InputStream is = null;
                ByteArrayOutputStream baos = null;
                try {
                    is = new FileInputStream(path);
                    baos = new ByteArrayOutputStream();
                    byte[] buffer = new byte[1024];
                    int temp = 0;
                    while ((temp = is.read(buffer)) != -1) {
                        baos.write(buffer, 0, temp);
                    }
                    return baos.toByteArray();
                } catch (IOException e) {
                    e.printStackTrace();
                    return null;
                } finally {
                    try {
                        if (is != null) {
                            is.close();
                        }
                    }catch(IOException e){
                        e.printStackTrace();
                    }
                    try {
                        if (baos != null) {
                            baos.close();
                        }
                    }catch(IOException e){
                        e.printStackTrace();
                    }
                }
            }
        }
        ```
  
      - 测试自定义类加载器FileSystemClassLoader
  
        ```java
        package com.sxt.test.classLoader;
        
        /**
         * @author: Li Tian
         * @contact: litian_cup@163.com
         * @software: IntelliJ IDEA
         * @file: Demo02.java
         * @time: 2020/1/31 21:17
         * @desc: 测试自定义类加载器FileSystemClassLoader
         */
        
        public class Demo02 {
            public static void main(String[] args) throws ClassNotFoundException {
                FileSystemClassLoader loader1 = new FileSystemClassLoader("F:\\Java WorkSpace");
                FileSystemClassLoader loader2 = new FileSystemClassLoader("F:\\Java WorkSpace");
                System.out.println(loader1 == loader2);
        
        
                Class<?> c1 = loader1.loadClass("NewClass");
                Class<?> c2 = loader1.loadClass("NewClass");
                Class<?> c3 = loader2.loadClass("NewClass");
                Class<?> c4 = loader1.loadClass("java.lang.String");
                Class<?> c5 = loader1.loadClass("com.sxt.test.classLoader.Demo01");
        
                System.out.println(c1);
                System.out.println(c1.hashCode());
                System.out.println(c2);
                System.out.println(c2.hashCode());
        
                // 注意：被两个类加载器加载的同一个类，JVM不认为是相同的类。
                System.out.println(c3);
                System.out.println(c3.hashCode());
        
                System.out.println(c4);
                System.out.println(c4.hashCode());
        
                System.out.println(c1.getClassLoader());
                System.out.println(c2.getClassLoader());
                System.out.println(c3.getClassLoader());    // 自定义的类加载器
                System.out.println(c4.getClassLoader());    // 引导类加载器
                System.out.println(c5.getClassLoader());    // 系统默认的类加载器
            }
        }
        ```
  
    - 自定义网路类加载器
  
      ```java
      package com.sxt.test.classLoader;
      
      import java.io.ByteArrayOutputStream;
      import java.io.IOException;
      import java.io.InputStream;
      import java.net.URL;
      
      /**
       * @author: Li Tian
       * @contact: litian_cup@163.com
       * @software: IntelliJ IDEA
       * @file: FileSystemClassLoader.java
       * @time: 2020/1/31 20:58
       * @desc: 自定义网路类加载器
       */
      
      public class NetSystemClassLoader extends ClassLoader {
          // com.sxt.test.bean.User --> www.sxt.cn/JAVAPro/src/com/sxt/test/bean/User.class
          private String rootUrl;
      
          public NetSystemClassLoader(String rootDir) {
              this.rootUrl = rootDir;
          }
      
          @Override
          protected Class<?> findClass(String name) throws ClassNotFoundException {
              Class<?> c = findLoadedClass(name);
      
              // 应该要先查询有没有加载过这个类，如果已经加载，则直接返回加载好的类，如果没有，则加载新的类。
              if (c != null) {
                  return c;
              } else {
                  ClassLoader parent = this.getParent();
                  // 委派给父类加载
                  try {
                      c = parent.loadClass(name);
                  }catch (Exception e){
                      System.out.println("父类加载器没有加载到这个类哦！");
                  }
                  if (c != null) {
                      return c;
                  } else {
                      byte[] classData = getClassData(name);
                      if (classData == null) {
                          throw new ClassNotFoundException();
                      } else {
                          c = defineClass(name, classData, 0, classData.length);
                      }
                  }
              }
              return c;
          }
      
          private byte[] getClassData(String classname) {
              String path = rootUrl + "/" + classname.replace('.', '/') + ".class";
              // 可以使用IOUtils将流中的数据转成字节数组，这里采用手写了
              InputStream is = null;
              ByteArrayOutputStream baos = null;
              try {
                  URL url = new URL(path);
                  is = url.openStream();
                  baos = new ByteArrayOutputStream();
                  byte[] buffer = new byte[1024];
                  int temp = 0;
                  while ((temp = is.read(buffer)) != -1) {
                      baos.write(buffer, 0, temp);
                  }
                  return baos.toByteArray();
              } catch (IOException e) {
                  e.printStackTrace();
                  return null;
              } finally {
                  try {
                      if (is != null) {
                          is.close();
                      }
                  }catch(IOException e){
                      e.printStackTrace();
                  }
                  try {
                      if (baos != null) {
                          baos.close();
                      }
                  }catch(IOException e){
                      e.printStackTrace();
                  }
              }
          }
      }
      ```
  
    - 自定义加密解密类加载器
  
      - 加密工具类
  
        ```java
        package com.sxt.test.classLoader;
        
        import java.io.*;
        
        /**
         * @author: Li Tian
         * @contact: litian_cup@163.com
         * @software: IntelliJ IDEA
         * @file: EncrpUtil.java
         * @time: 2020/2/1 22:52
         * @desc: 加密工具类
         */
        
        public class EncrpUtil {
            public static void main(String[] args) {
                encrpt("F:/Java WorkSpace/NewClass.class", "F:/Java WorkSpace/temp/NewClass.class");
            }
        
            public static void encrpt(String src, String dest) {
                FileInputStream fis = null;
                FileOutputStream fos = null;
        
                try {
                    fis = new FileInputStream(src);
                    fos = new FileOutputStream(dest);
        
                    int temp = -1;
                    while ((temp = fis.read()) != -1) {
                        // 取反操作
                        fos.write(temp ^ 0xff);
                    }
        
                } catch (IOException e) {
                    e.printStackTrace();
                } finally {
                    try {
                        if (fis != null) {
                            fis.close();
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                try {
                    if (fos != null) {
                        fos.close();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        ```
  
      - 解密工具类：加载文件系统中加密后的class字节码的类加载器
  
        ```java
        package com.sxt.test.classLoader;
        
        import java.io.ByteArrayOutputStream;
        import java.io.FileInputStream;
        import java.io.IOException;
        import java.io.InputStream;
        
        /**
         * @author: Li Tian
         * @contact: litian_cup@163.com
         * @software: IntelliJ IDEA
         * @file: DecrptClassLoader.java
         * @time: 2020/2/1 23:03
         * @desc: 解密工具类：加载文件系统中加密后的class字节码的类加载器
         */
        
        public class DecrptClassLoader extends ClassLoader {
            // com.sxt.test.bean.User --> F:/BookStudy/else/JAVAPro/src/com/sxt/test/bean/User.class
            private String rootDir;
        
            public DecrptClassLoader(String rootDir) {
                this.rootDir = rootDir;
            }
        
            @Override
            protected Class<?> findClass(String name) throws ClassNotFoundException {
                Class<?> c = findLoadedClass(name);
        
                // 应该要先查询有没有加载过这个类，如果已经加载，则直接返回加载好的类，如果没有，则加载新的类。
                if (c != null) {
                    return c;
                } else {
                    ClassLoader parent = this.getParent();
                    // 委派给父类加载
                    try {
                        c = parent.loadClass(name);
                    } catch (Exception e) {
                        System.out.println("父类加载器没有加载到这个类哦！");
                    }
                    if (c != null) {
                        return c;
                    } else {
                        byte[] classData = getClassData(name);
                        if (classData == null) {
                            throw new ClassNotFoundException();
                        } else {
                            c = defineClass(name, classData, 0, classData.length);
                        }
                    }
                }
                return c;
            }
        
            private byte[] getClassData(String classname) {
                String path = rootDir + "/" + classname.replace('.', '/') + ".class";
                // 可以使用IOUtils将流中的数据转成字节数组，这里采用手写了
                InputStream is = null;
                ByteArrayOutputStream baos = null;
                try {
                    is = new FileInputStream(path);
                    baos = new ByteArrayOutputStream();
                    int temp = -1;
                    while ((temp = is.read()) != -1) {
                        // 取反操作，进行解密
                        baos.write(temp ^ 0xff);
                    }
                    return baos.toByteArray();
                } catch (IOException e) {
                    e.printStackTrace();
                    return null;
                } finally {
                    try {
                        if (is != null) {
                            is.close();
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    try {
                        if (baos != null) {
                            baos.close();
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
        ```
  
      - 测试简单加密解密（取反）操作
  
        ```java
        package com.sxt.test.classLoader;
        
        /**
         * @author: Li Tian
         * @contact: litian_cup@163.com
         * @software: IntelliJ IDEA
         * @file: Demo03.java
         * @time: 2020/2/1 22:49
         * @desc: 测试简单加密解密（取反）操作
         */
        
        public class Demo03 {
            public static void main(String[] args) throws ClassNotFoundException {
                int a = 3;  // 00000011
                System.out.println(Integer.toBinaryString(a ^ 0xff));
        
                // 加载这个加密的类会报类格式错误ClassFormatError
                FileSystemClassLoader loader1 = new FileSystemClassLoader("F:/Java WorkSpace");
                Class<?> c1 = loader1.loadClass("NewClass_encrp");
                System.out.println(c1);
        
                // 使用解密类加载器加载加密后的类
                DecrptClassLoader loader = new DecrptClassLoader("F:/Java WorkSpace/temp");
                Class<?> c = loader.loadClass("NewClass");
                System.out.println(c);
            }
        }
        ```
  
  - 线程上下文类加载器
  
  - 服务器类加载原理和OSGI介绍

------

我的CSDN：https://blog.csdn.net/qq_21579045

我的博客园：https://www.cnblogs.com/lyjun/

我的Github：https://github.com/TinyHandsome

纸上得来终觉浅，绝知此事要躬行~

欢迎大家过来OB~

by 李英俊小朋友
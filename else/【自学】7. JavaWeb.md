# 尚硅谷JavaWeb学习笔记

[TOC]

## 写在前面

学习链接：[Java Web 视频教程全集（103P）](https://www.bilibili.com/video/av59545633/)

**特别注意**：该内容全是我自学时，一边听课一边做的笔记，本文的初衷是**希望每一个学习时有疑问的同学能够在这篇文章里找到答案**；里面关于吐槽的内容仅代表个人看法，白嫖党不会针对任何老师或书籍发表不合适的看法，如有冒犯，请见谅。所有传播知识的行为都应该受到尊重，该内容涉及的一切只为学习交流使用，希望每个求知进来的读者都可以满载而归。有任何问题或侵权行为，请联系本人**李英俊小朋友**，我会回应并删除；另外，做笔记真的不容易，希望大家转载时标明作者，若非个人使用的转载，请联系本人，否则必究。

学习体会：跟以前一样，主要写不足之处，优点就不赘述了，这么多视频选择这一个看，就是优点本身的体现了哈哈哈。

> 1. P11中，关于GenericServlet中为何要写一个init()函数，我是真没搞懂，讲的弯弯绕绕，绕来绕去。先是强行假设了子类中需要出示化的需求，init之后会报错。这个假设我是没想到的，为什么会有这种假设？好吧，就算有吧，那么只要init重写的是带ServletConfig参数的，都肯定会报错啊，写个init又能怎么样呢，让别人初始化就只能用这个init吗？（**这部分主要是啰嗦太多了**，给我绕晕了，简单说的话就容易理解多了）
>
>    这里需要附上重写和重载的区别帮助理解，[参考链接](https://www.runoob.com/java/java-override-overload.html)。百度之后得到的答案是：**为了防止在重载的时候忘记调用super.init(config); 因此写个init()来帮助初始化时增加一些自己的初始化参数**，[参考连接](https://www.cnblogs.com/itmanxgl/p/fbeced7052b9ec29fa5bae652c5ceff4.html)
>
> 2. P12中，关于HttpServlet的doXxx方法讲的我云里雾里的，实在是不知道这个方法具体有什么用
>
>    调用流程是：浏览器发送请求 -> 调用service(servletRequest, servletReponse)方法，该方法将里面的两个传参转化为Http的类 -> 然后再调用service(HttpServletRequest, HttpServletResponse)方法，在这个方法中根据method的不同使用不同的**doMethod()**（即doGet，doPost），而这个方法中的内容需要自己重写。 -> 实现了根据method方式完成不同的功能。[参考链接](https://blog.csdn.net/zhaolang2009/article/details/80678660?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2)
>
>    

## 1. 前言

- 在Sun的JavaServlet规范中：JavaWeb应用由一组Servlet、HTML页、类、以及其他可以被绑定的资源构成。它可以在各种供应商提供的**实现Servlet规范的Servlet容器中运行**。

- JavaWeb应用中可以包含如下内容：

  - Servlet
  - JSP
  - 实用类
  - 静态文档如HTML、图片等
  - 描述Web应用的信息（web.xml）

- Servlet与Servlet容器

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409124223247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- Servlet容器的概念

  - Servlet容器为JavaWeb应用提供运行时的环境，它负责管理Servlet和JSP的生命周期，以及管理它们的共享数据。
  - Servlet容器也称为JavaWeb应用容器，或者Servlet/HSP容器。
  - 目前最流行的Servlet容器软件包括：
    - Tomcat
    - Resin
    - J2EE服务器（如Weblogic）中也提供了内置的Servlet容器

- **Tomcat**：Apache、Sun和其他一些公司及个人共同开发完成。

  - Tomcat的目录层次结构

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409125526469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - 运行Tomcat

    1. 配置java_home或jre_home（这一步我能运行哈哈哈哈，我用的tomcat9）
    2. 双击bin目录下的startup.bat文件
    3. 在地址栏中输入http://localhost:8080/
    4. 若已经启动了一个Tomcat应用，若再启动同一个Tomcat应用，则会抛出异常（这是因为端口被占用了）

  - 关闭Tomcat&配置Tomcat的端口号

    1. 双击bin目录下的shutdown.bat文件关闭Tomcat服务器

    2. 修改Tomcat默认的端口号：

       - 打开conf目录下的server.xml文件
       - 修改端口号

       ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409130844768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - catalina：可以通过设置catalina_home环境变量的方式来通过dos启动关闭tomcat

    - 为了可以在任意目录下启动Tomcat服务器

    1. 把Tomcat的bin目录添加到path下（但是这样添加成功会，通过startup启动Tomcat会有提示：catalina的环境变量没有正确设置）
    2. 设置CATALINA_HOME环境变量：
       1. 通过阅读startup.bat文件可知，该环境变量下有一个bin目录，而bin目录下又有一个catalina.bat文件，由此可知CATALINA_HOME指向的应该是Tomcat安装的根目录
       2. 于是把Tomcat的根目录设为CATALINA_HOME环境变量
       3. 此时即可以在任意根目录下通过startup.bat、shutdown.bat启动、关闭Tomcat服务器
       4. 继续阅读startup.bat文件，发现启动tomcat服务器的是catalina.bat文件，在命令行窗口直接输入catalina会有各种命令的提示，出现各种可选参数。
       5. 常用的有：run（同窗口启动服务器）、start（新窗口启动服务器）、stop（关闭服务器）

  - Tomcat的管理程序

    - Tomcat提供了一个管理程序：manager，用于部署到Tomcat服务器中的web应用程序
    - 要访问manager web应用程序，需要添加具有管理员权限的账号，编辑conf目录下的**tomcat-users.xml**文件，添加manager角色，设置用户名和密码
    - **注意**：这里我在操作的时候，发现我用的是tomcat9嘛，所以跟视频里面将的不一样，设置的时候发现仅仅设置manager是不行的，并且**tomcat-users.xml**文件中也说了不同的用户对应着不同的管理权限，不像以前直接manager用户管所有了，因此为了解决这个问题查了百度，[参考链接](http://blog.sina.com.cn/s/blog_6ac4c6cb0101485d.html)，这样就解决了。另外，不能像视频中设置用户和密码为空，不然一直弹框也进不去。

## 2. Web程序结构

- 一个web应用程序是由一组Servlet，HTML页面，类，以及其他的资源组成的运行在web服务器上的完整的应用程序，以一种结构化的有层次的目录形式存在。

- 组成web应用程序的这些文件要部署在相应的目录层次中，根目录代表整个web应用程序的“根”。

- 通常将web应用程序的目录放在webapps目录下，在webapps目录下的每一个子目录都是一个独立的web应用程序，子目录的名字就是web应用程序的名字，也就是web应用程序的“根”。用户通过web应用程序的“根”来访问web应用程序中的资源。

- Servlet规范汇总定义了web应用程序的目录层次

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409153613329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- **注意**：跟着视频在创建jsp文件的时候，我发现并没有这个新建这个文件的选择，网上搜了搜方法，据说是：“IDEA认为我这个包建的有问题，才导致这地方不应该创建jsp文件，所以就没有创建JSP文件的选项。” [参考连接](https://blog.csdn.net/weixin_44381073/article/details/89816624)，采用这个方法之后就可以新建jsp文件了。

- JSP(Java Server Pages)是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。

- 第一个WEB应用程序：开发，并部署到Tomcat服务器下运行

  1. 新建一个JavaProject
  2. 在Java项目下创建WEB开发的目录结构
     - WebContent
       - WEN-INF
         - classes 编译后的class文件必须放在该目录下
         - lib
         - web.xml （从Tomcatwebapps\docs\WEB-INFO中复制过来，可以不做修改）
       - html 页面
       - jsp 页面
       - 图片。。。
  3. 在src下新建一个Person类
  4. 手工的Person类对应的Class文件（含包）复制到classes目录下
     - 可以通过修改默认的输出目录达到自动把编译好的class放到classes目录下
     - 由于视频中是eclipse操作的，因此我搜了一下idea的[操作方法](https://www.cnblogs.com/dslx/p/10172602.html)
  5. 在WebContent目录下新建一个JSP文件
  6. 把WebContent目录复制到Tomcat的webapps目录下，并改名为helloworld
  7. 在浏览器的地址栏中输入http://localhost:8080/WebContent/hello.jsp即可看到命令行打印的信息
  8. 使用【配置任意目录下Web应用程序2】的方式建立.xml文件，实现直接部署

- 配置任意目录下Web应用程序1

  - 在Web服务器中可以配置虚拟目录，而虚拟目录所对应的真实目录可以在任何路径下
  - 在Tomcat服务器中，主要在XML配置文件中通过`<Context>`元素的设置来完成的。一个`<Context>`元素就表示一个Web应用程序，运行在特定的虚拟主机中
  - `<Context>`元素是`<Host>`元素的子元素，可以在conf\server.xml文件中设置Context元素
  - 使用docBase属性指定Web应用程序的真实路径。将属性reloadable设置为true，Tomcat在运行时会自动监测Servlet类的改动，如果发现有类被更新，Tomcat服务器将自动重新加载该Web应用程序。这样，在开发时，就不需要频繁重启Tomcat了。

- 配置任意目录下Web应用程序2（超酷）

  - 还可以在conf目录下一次创建Catalina\localhost目录，然后在localhost目录下为test这个Web应用程序建立test.xml文件，编辑这个文件输入以下内容`<Context path="/test" docBase="c:/test" reloadable="true">`
  - 从Tomcat5开始，**不建议直接在server.xml文件中配置`<Context>`元素**，因为server.xml文件作为Tomcat的主要配置文件，一旦Tomcat启动后，将不会再读取这个文件，因此无法在Tomcat服务器启动时发布Web应用程序。如果在其他地方配置`<Context>`元素，那么在Tomcat运行时，也可以发布Web应用程序。
  - 从Tomcat5.5开始，在\conf\Catalina\localhost目录下创建XML配置文件来配置Web应用程序，**Tomcat将以XML文件的文件名作为Web应用程序的上下文路径**，而不会理会在`<Context>`元素的path属性中指定的上下文路径是什么。由于Tomcat5.5之后的版本是以XML配置文件的文件名作为Web应用程序的上下文路径的，因此在配置`<Context>`元素时，可以不使用path属性。

- 文件修改为helloworld2.xml

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <Context path="/test2" docBase="F:/BookStudy/else/JavaWebPro/WebContent" reloadable="true"/>
  ```

- 上述内容的解释

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409173352178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- **之前没有实现自动化的结果这里就不展示了**

- 自动化包含了两个，具体实现方法在上面

  - 一是将class输出的位置放到WebContent/WEB-INF/classes下
  - 二是通过配置任意目录下Web应用程序（使用第2种方法），把后面的原路径映射道虚拟路径上，实现实时更新项目的目的，这样修改了原始项目的内容，也可以不用重启Tomcat直接展示最新的结果。

- 报错问题：

  - org.apache.jasper.JasperException: Unable to compile class for JSP:
  - JSP出现 类名 cannot be resolved to a type
  - 上面两种问题是同一页面出现的。。。我查了一万个方法。。。最后发现是WEB-INF写成WEB-INFO了
  - 所以出了问题的第一件事情，一定要从自己这里找原因。。。哭！

- 最后运行成功的图如下：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409171814200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

## 3. 使用Eclipse / Idea开发JavaWeb项目

- [Idea配置1](https://blog.csdn.net/With_Her/article/details/89243777?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)、[Idea配置2](https://blog.csdn.net/chenshun123/article/details/51285890)

- Eclipse配置：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410120252614.png)

## 4. Servlet

- Java Servlet是和平台无关的服务器端组件，它运行在Servlet容器中。Servlet容器负责Servlet和客户的通信以及调用Servlet的方法，Servlet和客户的通信采用“请求/响应”的模式。

- Server Applet

- Servlet可完成如下功能：

  - 创建并返回基于客户请求的动态HTML页面
  - 创建可嵌入到现有HTML页面中的部分HTML页面（HTML片段）。
  - 与其它服务器资源（如数据库或基于Java的应用程序）进行通信。

- Servlet容器响应客户请求的过程

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410120926345.png)

- Servlet API

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410121212144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 4.1 第一个Servlet程序

- 问题：我在操作的时候，发现不能implements Servlet，网上查了查，说是没有导入对应的包

- [解决方法](https://www.cnblogs.com/ifeil/p/9378921.html)：实际上就是在Modules中的项目里的Dependences中+上Tomcat的library

- 问题：在启动自己的HelloServlet时，输出中文为乱码

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410123530828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- [解决方法](https://www.cnblogs.com/chenxianbin/p/11367954.html)：早Tomcat的conf路径下修改logging.properties文件中，将下图的位置的UTF-8改为GBK

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020041012373535.png)

- 问题：xml文件在写的时候，如何优雅的注释

- [解决方法](https://blog.csdn.net/weixin_33889245/article/details/94303669)：CTRL + SHIFT + / 直接调出注释

- **自己的解决方法**：我自己做了一个Live Template：输入<然后回车就会直接生成注释

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410125509301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- Servlet的HelloWorld

  1. 创建一个Servlet接口的实现类（记住这个时候要导入Tomcat的library，[参考链接](https://blog.csdn.net/weixin_44319545/article/details/100544309)）

  2. 在web.xml文件中配置和映射这个Servlet（目的是希望能够通过浏览器去访问java类）

     ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410124301987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 具体实现

  - HelloServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: HelloServlet.java
     * @time: 2020/4/10 12:20
     * @desc: |
     */
    
    public class HelloServlet implements Servlet {
    
        public HelloServlet() {
            System.out.println("HelloServlet构造器已启动...");
        }
    
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            System.out.println("初始化中...");
        }
    
        @Override
        public ServletConfig getServletConfig() {
            System.out.println("获取Servlet配置中...");
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            System.out.println("服务中...");
        }
    
        @Override
        public String getServletInfo() {
            System.out.println("获取Servlet信息中...");
            return null;
        }
    
        @Override
        public void destroy() {
            System.out.println("毁灭中...");
        }
    }
    ```

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
        <!-- 配置和映射Servlet -->
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.HelloServlet</servlet-class>
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello</url-pattern>
        </servlet-mapping>
    </web-app>
    ```

### 4.2 Servlet配置及生命周期方法

- Servlet容器：运行Servlet、JSP、Filter等的软件环境
  - 可以来创建Servlet，并调用Servlet的相关生命周期方法
  - JSP，Filter，Listener，Tag…
- Servlet生命周期的方法：以下方法都是由Servlet容器负责调用
  - 构造器方法：只被调用一次，只有第一次请求Servlet时，创建Servlet的实例，调用构造器。（这说明Servlet是单实例的）
  - init方法：只被调用一次，在创建好实例后立即被调用，用于初始化当前Servlet。
  - service：被多次调用。每次请求都会调用service方法，实际用于相应请求的。
  - destroy：只被调用一次，在当前Servlet所在的WEB应用被卸载前调用，用于释放当前Servlet所占用的资源。
- load-on-startup参数
  - 配置在Servlet节点中
  - load-on-startup：可以指定Servlet被创建的时机，若为负数，则在第一次请求时被创建。若为0或正数，则在当前WEB应用被Servlet容器被加载时创建实例，且数值越小越早被创建。负数，则不创建。
- Servlet容器响应客户请求的过程
  1. Servlet引擎检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第4步，否则，执行第2步
  2. 装载并创建该Servlet的第一个实例对象：调用该Servlet的构造器
  3. 调用Servlet实例对象的init()方法
  4. 创建一个用于封装请求的ServletRequest对象和一个代表响应消息的ServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传进去
  5. WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法
- Servlet的注册于运行
  - Servlet程序必须通过Servlet容器来启动运行，并且存储目录有特殊要求，通常需要存储在`<WEB应用程序目录>\WEB-INF\classes\`目录中。
  - Servlet程序必须在WEB应用程序的web.xml文件中进行注册和映射其访问路径，才可以被Servlet引擎加载和被外界访问。
  - 一个`<servlet>`元素用于注册一个Servlet，它包含有两个主要的子元素：
    - `<servlet-name>`：用于设置Servlet的注册名称
    - `<servlet-class>`：用于设置Servlet的完整类名
  - 一个`<servlet-mapping>`元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：
    - `<servlet-name>`：用于设置Servlet的注册名称
    - `<url-pattern>`：用于设置Servlet的对外访问路径
- Servlet映射的细节
  - 同一个Servlet可以被映射到多个URL上，即多个`<servlet-mapping>`元素的`<servlet-name>`子元素的设置值可以是同一个Servlet的注册名
  - 在Servlet映射到的URL中也可以使用`*`通配符，但是只能有两种固定的格式：一种是`*.扩展名`，另一种格式是以正斜杠`/`开头并以`/*`结尾
  - 注意：`/*.扩展名`，即既带/又带扩展名的不合法

### 4.3 ServletConfig & ServletContext

- 封装了Servlet的配置信息，并且可以获取ServletContext对象（ServletConfig获取的是该Servlet的初始化参数，ServletContext中可以获取全局的初始化参数）
  1. 配置Servlet的初始化参数
  2. 获取初始化参数：
     - getInitParameter(String name)：获取指定参数名的初始化参数
     - getInitParameterNames()：获取参数名组成的Enumeration对象
  3. 获取Servlet的配置名称
  4. getServletContext
     - Servlet引擎为 **每个WEB应用程序** 都创建一个对应的ServletContext对象，ServletContext对象被包含在ServletConfig对象中，调用ServletConfig.getServletContext方法可以返回ServletContext对象的应用。
     - **由于一个WEB应用程序中的所有Servlet都共享同一ServletContext对象**，所以，ServletContext对象被称为application对象（Web应用程序对象）
     - 功能：
       - 获取WEB应用程序的初始化参数
       - 记录日志
       - application域范围的属性
       - 访问资源文件
       - 获取虚拟路径所映射的本地路径
       - WEB应用程序之间的访问
       - ServletContext的其他方法

- 代码

  - HelloServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    import java.io.InputStream;
    import java.util.Enumeration;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: HelloServlet.java
     * @time: 2020/4/10 12:20
     * @desc: |
     */
    
    public class HelloServlet implements Servlet {
    
        public HelloServlet() {
            System.out.println("HelloServlet构造器已启动...");
        }
    
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            // 1. ServletConfig
            // 针对Servlet的初始化参数
            System.out.println("初始化中...");
            String user = servletConfig.getInitParameter("user");
            System.out.println("user: " + user);
            Enumeration<String> names = servletConfig.getInitParameterNames();
            while(names.hasMoreElements()){
                String name = names.nextElement();
                String value = servletConfig.getInitParameter(name);
                System.out.println(name + "-->" + value);
            }
            String servletName = servletConfig.getServletName();
            System.out.println(servletName);
    
            // 2. ServletContext
            // 针对app的初始化参数，相较于上面，该参数适用于所有Servlet，相当于全局的参数
            // 2.1 获取ServletContext对象
            ServletContext sc = servletConfig.getServletContext();
            // 获取WEB应用程序的初始化参数
            String driver = sc.getInitParameter("driver");
            System.out.println("driver: " + driver);
            Enumeration<String> names2 = sc.getInitParameterNames();
            while(names2.hasMoreElements()){
                String name = names2.nextElement();
                String value = sc.getInitParameter(name);
                System.out.println(name + "-->" + value);
            }
    
            // 2.2 获取当前WEB应用的某一个文件在服务器上的绝对路径：
            String realPath = sc.getRealPath("/index.jsp");
            System.out.println(realPath);
    
            // 2.3 获取当前WEB应用的名称
            String contextPath = sc.getContextPath();
            System.out.println(contextPath);
    
            // 2.4 获取当前WEB应用的某一个文件对应的输入流
            // path的 / 响度与当前WEB应用的根目录
            try {
                ClassLoader cl = getClass().getClassLoader();
                InputStream is = cl.getResourceAsStream("jdbc.properties");
                System.out.println("1. " + is);
    
                InputStream is2 = sc.getResourceAsStream("jdbc.properties");
                System.out.println("2. " + is2);
    
                InputStream is3 = sc.getResourceAsStream("/WEB-INF/classes/jdbc.properties");
                System.out.println("3. " + is3);
            } catch (Exception e) {
                e.printStackTrace();
            }
    
            // 2.5 和attribute相关的几个方法
    
        }
    
        @Override
        public ServletConfig getServletConfig() {
            System.out.println("获取Servlet配置中...");
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            System.out.println("服务中...");
        }
    
        @Override
        public String getServletInfo() {
            System.out.println("获取Servlet信息中...");
            return null;
        }
    
        @Override
        public void destroy() {
            System.out.println("毁灭中...");
        }
    }
    ```

  - SecondServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: SecondServlet.java
     * @time: 2020/4/11 10:11
     * @desc: |
     */
    
    public class SecondServlet implements Servlet {
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            System.out.println("第二次Servlet初始化");
        }
    
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
    
        }
    
        @Override
        public String getServletInfo() {
            return null;
        }
    
        @Override
        public void destroy() {
    
        }
    }
    ```

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
        <!-- 配置和映射Servlet -->
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.HelloServlet</servlet-class>
    
            <!-- 配置Servlet的初始化参数，且节点必须在load-on-startup节点的前面 -->
            <init-param>
                <!-- 参数名 -->
                <param-name>user</param-name>
                <!-- 参数值 -->
                <param-value>root</param-value>
            </init-param>
            <init-param>
                <param-name>password</param-name>
                <param-value>1230</param-value>
            </init-param>
    
            <!-- 可以指定Servlet被创建的时机 -->
            <load-on-startup>5</load-on-startup>
    
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello</url-pattern>
        </servlet-mapping>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello2</url-pattern>
        </servlet-mapping>
    
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>secondServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.SecondServlet</servlet-class>
            <!-- 可以指定Servlet被创建的时机 -->
            <load-on-startup>2</load-on-startup>
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>secondServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>*.html</url-pattern>
        </servlet-mapping>
    </web-app>
    ```

### 4.4 HTTP简介

- WEB浏览器与WEB浏览器之间的一问一答的交互过程，必须遵循一定的规则，这个规则就是HTTP协议

- HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是TCP/IP协议集中的一个应用层协议，**用于定义WEB浏览器与WEB浏览器之间交换数据的过程以及数据本身的格式**。

- HTTP协议的版本HTTP/1.0、HTTP/1.1、HTTP-NG

- HTTP的会话方式：

  - 四个步骤：建立连接、发出请求信息、回送响应信息、关闭连接
  - 浏览器与WEB服务器的连接过程是短暂的，每次连接只处理一个请求和响应。对每一个页面的访问，浏览器与WEB服务器都要建立一次单独的连接。
  - 浏览器到WEB服务器之间的所有通讯都是完全独立分开的请求和响应对。

- 浏览器范文多图网页的过程

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412145427186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- HTTP请求消息

  - 请求消息的结果：**一个请求行、若干消息头以及实体内容**，其中一些消息头和实体内容都是可选的，消息头和实体内容之间要用空行隔开。

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412145629979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- HTTP响应信息

  - 响应信息的结构：**一个状态行、若干消息头、以及实体内容**，其中一些消息头和实体内容都是可选的，消息头和实体内容之间要用空行隔开。

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412145820158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 其他细节

  - 响应消息的实体内容就是网页文件的内容，也就是在浏览器中使用查看源文件的方式所看到的内容
  - 一个使用GET方式的请求消息中不能包含实体内容，只有使用POST、PUT和DELETE方式的请求消息中才可以包含实体内容。

- 使用GET和POST方式传递参数

  - 在URL地址后面还可以附加一些参数

  - GET方式：

    - 传输的数据量是有限的，一般限制在1KB以下。
    - 在浏览器地址栏中输入某个URL地址或单击网页上的一个超链接时，浏览器发出的HTTP请求消息的请求方式为GET
    - 如果网页中的`<form>`表单元素的method属性被设置为了“GET”，浏览器提交这个FROM表单时生成的HTTP请求消息方式也为GET
    - 使用GET请求方式给WEB服务器传递参数的格式：`xxx?name=l&pwd=123`

  - POST方式：

    - POST方式将各个表单字段元素及其数据作为HTTP消息的实体内容发送给WEB服务器。传送的数据量要比GET方式传送的数据量大得多。

    - POST请求方式主要用于向WEB服务器端程序提交FORM表单中的数据。

    - 格式：

      ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412152046412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 4.5 ServletRequest & ServletResponse

- 如何在Servlet中获取请求信息：

  - Servlet的service()方法用于应答请求：因为每次请求都会调用service()方法

- ServletRequest：封装了请求信息，可以从中获取到任何的请求信息。

- ServletResponse：封装了响应信息，如果想给用户什么响应，均可以使用该接口的方法实现。

- 这两个接口的实现类都是服务器给予实现的，并在服务器调用service方法时传入。

>  问题1：在实验的时候我发现了一个大问题，就是每次改了代码之后，都需要重启Servlet才能行。
>
>  解决方案：[参考链接](https://blog.csdn.net/Jodie_Girl/article/details/103597872)，我在参考连接的基础上对Tomcat的配置进行了修改，也就是如图所示的部分，全部修改为update classes and resources
>  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413120914681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
>
>  问题2：IDEA中重新启动一共有四种选择，分别是什么意思
>  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413122116504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
>
>  解决方案：[参考连接](https://blog.csdn.net/qq_40871734/article/details/99749715)，我发现选择重新部署，也就是第三个，才能起到刷新java类的效果

- ServletRequest：

  - 获取请求参数：
    - String getParameter(String name)：根据请求参数的名字，返回参数值（若请求参数有多个值，如checkbox，该方法只能获取到第一个提交的值）。
    - Map getParameterMap()：返回请求参数的键值对：Key：参数名；Value：参数值，String数组类型。
    - Enumeration getParameterNames()：返回参数名对应的Enumeration对象，类似于ServletConfig(或ServletContext)的getInitParameterNames()方法。
    - String[] getParameterValues(String name)：根据请求参数的名字，返回请求参数对应的字符串数组
    
  - 流程图
  
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413120207777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
  
- HttpServletRequest：是ServletRequest的子接口，针对HTTP请求所定义。里边包含了大量获取HTTP请求的方法

  - 获取请求的URL：HttpServletRequest.getRequestURI()，结果示例：`/app2/loginServLet`
  - 获取请求的方式：HttpServletRequest.getMethod()，结果示例：`GET`
  - 获取请求参数的字符串：HttpServletRequest.getQueryString()，结果示例：`user=111&password=333&interesting=reading&interesting=game&interesting=party`
  - 获取Servlet的映射路径：HttpServletRequest.getServletPath()，结果示例：`/loginServLet`
  - 和attribute相关的几个方法

- ServletResponse

  - getWriter()：返回PrintWriter对象，调用该对象的print()方法，将把print()中的参数直接打印到客户的浏览器上。
  - setContentType()：设置响应的内容类型。

- HttpServletResponse：跟HttpServletRequest同理，有一个超重要的方法

  - void sendRedirect(String location)：请求的重定向。（此方法为HttpServletResponse中定义，因此使用时需要强转）

- 上述的实现代码

  - LoginServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import java.io.IOException;
    import java.io.PrintWriter;
    import java.util.Arrays;
    import java.util.Enumeration;
    import java.util.Map;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LoginServlet.java
     * @time: 2020/4/13 11:45
     * @desc: |
     */
    
    public class LoginServlet implements Servlet {
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
    
        }
    
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            System.out.println("请求来了！");
            System.out.println(servletRequest);
    
            String user = servletRequest.getParameter("user");
            String psd = servletRequest.getParameter("password");
            System.out.println(user + "-->" + psd);
    
            String interesting = servletRequest.getParameter("interesting");
            System.out.println(interesting);
    
            String[] interestings = servletRequest.getParameterValues("interesting");
            System.out.println(interestings);
            for(String a: interestings){
                System.out.println(a);
            }
    
            Enumeration<String> names = servletRequest.getParameterNames();
            while(names.hasMoreElements()){
                String name = names.nextElement();
                String val = servletRequest.getParameter(name);
    
                System.out.println("3. " + name + ": " + val);
            }
    
            Map<String, String[]> map = servletRequest.getParameterMap();
            for(Map.Entry<String, String[]> entry: map.entrySet()){
                System.out.println("4. " + entry.getKey() + ": " + Arrays.asList(entry.getValue()));
            }
    
            HttpServletRequest hsr = (HttpServletRequest) servletRequest;
            String requestURI = hsr.getRequestURI();
            System.out.println(requestURI);
    
            String method = hsr.getMethod();
            System.out.println(method);
    
            String qs = hsr.getQueryString();
            System.out.println(qs);
    
            String sp = hsr.getServletPath();
            System.out.println(sp);
    
            // 设置响应的内容类型：这里设置成word格式，那么submit之后会让你下载一个文件，文件可以用word打开，内容是write中的内容。
            servletResponse.setContentType("application/msword");
    
            PrintWriter out = servletResponse.getWriter();
            out.println("What are you talking about?");
    
        }
    
        @Override
        public String getServletInfo() {
            return null;
        }
    
        @Override
        public void destroy() {
    
        }
    }
    ```

  - login.html

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
    <form action="loginServLet" method="get">
        user: <input type="text" name="user">
        password: <input type="password" name="password">
    
        <br><br>
    
        interesting:
        <input type="checkbox" name="interesting" value="reading" />Reading
        <input type="checkbox" name="interesting" value="game" />Game
        <input type="checkbox" name="interesting" value="party" />Party
        <input type="checkbox" name="interesting" value="shopping" />Shopping
        <input type="checkbox" name="interesting" value="sport" />Sport
        <input type="checkbox" name="interesting" value="tv" />TV
    
        <input type="submit" value="submit"/>
    </form>
    
    </body>
    </html>
    ```

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
    
        <!-- 获取WEB应用程序的初始化参数 -->
        <context-param>
            <param-name>driver</param-name>
            <param-value>com.mysql.cj.jdbc.Driver</param-value>
        </context-param>
    
        <context-param>
            <param-name>jdbcUrl</param-name>
            <param-value>jdbc:mysql://localhost:3306/testjdbc?serverTimezone=GMT%2B8</param-value>
        </context-param>
    
        <!-- 配置和映射Servlet -->
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.HelloServlet</servlet-class>
    
            <!-- 配置Servlet的初始化参数，且节点必须在load-on-startup节点的前面 -->
            <init-param>
                <!-- 参数名 -->
                <param-name>user</param-name>
                <!-- 参数值 -->
                <param-value>root</param-value>
            </init-param>
            <init-param>
                <param-name>password</param-name>
                <param-value>1230</param-value>
            </init-param>
    
            <!-- 可以指定Servlet被创建的时机 -->
            <load-on-startup>5</load-on-startup>
    
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello</url-pattern>
        </servlet-mapping>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello2</url-pattern>
        </servlet-mapping>
    
    <!--    <servlet>-->
    <!--        &lt;!&ndash; Servlet 注册的名字 &ndash;&gt;-->
    <!--        <servlet-name>secondServlet</servlet-name>-->
    <!--        &lt;!&ndash; Servlet 的全类名 &ndash;&gt;-->
    <!--        <servlet-class>com.litian.test.SecondServlet</servlet-class>-->
    <!--        &lt;!&ndash; 可以指定Servlet被创建的时机 &ndash;&gt;-->
    <!--        <load-on-startup>2</load-on-startup>-->
    <!--    </servlet>-->
    
    <!--    <servlet-mapping>-->
    <!--        &lt;!&ndash; 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 &ndash;&gt;-->
    <!--        <servlet-name>secondServlet</servlet-name>-->
    <!--        &lt;!&ndash; 映射具体的访问路径：/ 代表当前WEB应用的根目录 &ndash;&gt;-->
    <!--        <url-pattern>*.html</url-pattern>-->
    <!--    </servlet-mapping>-->
    
        <servlet>
            <servlet-name>loginServlet</servlet-name>
            <servlet-class>com.litian.test.LoginServlet</servlet-class>
        </servlet>
    
        <servlet-mapping>
            <servlet-name>loginServlet</servlet-name>
            <url-pattern>/loginServLet</url-pattern>
        </servlet-mapping>
    
    </web-app>
    ```

### 4.6 GenericServlet

> 小题目：在web.xml文件中设置两个WEB应用的初始化参数，user，password；定义一个login.html，里边定义两个请求字段：user，password，发送请求到loginServlet；再创建一个LoginServlet，在其中获取请求的user，password。比对其和web.xml文件中定义的请求参数是否一致，若一致，响应Hello：xxx；若不一致，响应Sorry：xxx；xxx为user。

- 新建一个工程来实现上述问题

  - 配置Tomcat和一系列设置

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
        <!-- 配置当前WEB应用的初始化参数 -->
        <context-param>
            <param-name>user</param-name>
            <param-value>litian</param-value>
        </context-param>
    
        <context-param>
            <param-name>password</param-name>
            <param-value>123</param-value>
        </context-param>
    
        <!-- 配置Servlet -->
        <servlet>
            <servlet-name>log</servlet-name>
            <servlet-class>com.litian.test.LoginServlet</servlet-class>
        </servlet>
    
        <servlet-mapping>
            <servlet-name>log</servlet-name>
            <url-pattern>/LoginServlet</url-pattern>
        </servlet-mapping>
    </web-app>
    ```

  - login.html

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>冲冲冲</title>
    </head>
    <body>
    <form action="LoginServlet" method="post">
        user: <input type="text" name="username"/>
        password: <input type="password" name="password"/>
        <input type="submit" value="Submit"/>
    </form>
    
    </body>
    </html>
    ```

  - LoginServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    import java.io.PrintWriter;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LoginServlet.java
     * @time: 2020/4/13 14:17
     * @desc: |
     */
    
    public class LoginServlet implements Servlet {
        private ServletConfig servletConfig;
    
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            this.servletConfig = servletConfig;
        }
    
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            // 1. 获取请求参数：username和password
            String username = servletRequest.getParameter("username");
            String password = servletRequest.getParameter("password");
    
            // 2. 获取当前WEB应用的初始化参数：user，password
            // 需要使用ServletContext对象
            ServletContext sc = servletConfig.getServletContext();
            String initUser = sc.getInitParameter("user");
            String initPassword = sc.getInitParameter("password");
    
            // 3. 比对
            // 设置中文乱码问题
            servletResponse.setCharacterEncoding("utf-8");
            // 设置响应的内容类型
            servletResponse.setContentType("text/html;charset=utf-8");
    
            PrintWriter out = servletResponse.getWriter();
            if(initUser.equals(username) && initPassword.equals(password)){
                // 4. 打印响应字符
                out.println("Hello: " + username);
            }else{
                out.println("Sorry: " + username + "，你甭想进来！");
            }
        }
    
        @Override
        public String getServletInfo() {
            return null;
        }
    
        @Override
        public void destroy() {
    
        }
    }
    ```

- GenericServlet（不常用，了解，因为常用HttpServlet）

  - 是一个Servlet，是Servlet接口和ServletConfig接口的实现类，但是是一个抽象类，其中service方法为抽象方法。

  - 存在的意义：如果新建的Servlet程序直接继承GenericServlet会使得开发更简洁。

  - 具体实现

    - 在GenericServlet中声明了一个**ServletConfig**类型的成员变量，在init(ServletConfig)方法中对其进行了初始化。
    - 利用ServletConfig成员变量的方法实现了ServletConfig接口的方法。
    - 还定义了一个**init方法**，在init(ServletConfig)方法中对其进行调用，子类可以直接覆盖init()在其中实现对Servlet的初始化。
    - 不建议直接覆盖带参init，忘记编写super(ServletConfig)，还使用了ServletConfig接口的方法时会报空指针异常。
    - 新建的init()并非Servlet的声明周期方法，而带参的那个是。

  - 手写GenericServlet的原理（实际上还有log日志方法）

    - 自定义一个Servlet接口的实现类：让开发的任何Servlet都继承该类，以简化开发

      ```java
      package com.litian.test;
      
      import javax.servlet.*;
      import java.util.Enumeration;
      
      /**
       * @author: Li Tian
       * @contact: litian_cup@163.com
       * @software: IntelliJ IDEA
       * @file: MyGenericServlet.java
       * @time: 2020/4/14 15:29
       * @desc: |自定义一个Servlet接口的实现类：让开发的任何Servlet都继承该类，以简化开发
       */
      
      public abstract class MyGenericServlet implements Servlet, ServletConfig {
          private ServletConfig servletConfig;
      
          // 以下方法为Servlet接口的方法
          @Override
          public void init(ServletConfig servletConfig) throws ServletException {
              this.servletConfig = servletConfig;
          }
      
          @Override
          public ServletConfig getServletConfig() {
              return servletConfig;
          }
      
          @Override
          public abstract void service(ServletRequest servletRequest, ServletResponse servletResponse);
      
          @Override
          public String getServletInfo() {
              return null;
          }
      
          @Override
          public void destroy() {
      
          }
      
          // 以下方法为ServletConfig接口的方法
          @Override
          public String getServletName() {
              return servletConfig.getServletName();
          }
      
          @Override
          public ServletContext getServletContext() {
              return servletConfig.getServletContext();
          }
      
          @Override
          public String getInitParameter(String s) {
              return servletConfig.getInitParameter(s);
          }
      
          @Override
          public Enumeration<String> getInitParameterNames() {
              return servletConfig.getInitParameterNames();
          }
      }
      ```

    - 利用手写的GenericServlet简化开发

      ```java
      package com.litian.test;
      
      import javax.servlet.*;
      import java.io.IOException;
      import java.io.PrintWriter;
      
      /**
       * @author: Li Tian
       * @contact: litian_cup@163.com
       * @software: IntelliJ IDEA
       * @file: LoginServlet.java
       * @time: 2020/4/13 14:17
       * @desc: |继承MyGenericServlet来实现简化开发
       */
      
      public class LoginServlet2 extends MyGenericServlet {
      
          @Override
          public void service(ServletRequest servletRequest, ServletResponse servletResponse) {
              // 1. 获取请求参数：username和password
              String username = servletRequest.getParameter("username");
              String password = servletRequest.getParameter("password");
      
              // 2. 获取当前WEB应用的初始化参数：user，password
              // 需要使用ServletContext对象
              String initUser = getServletContext().getInitParameter("user");
              String initPassword = getServletContext().getInitParameter("password");
      
              // 3. 比对
              // 设置中文乱码问题
              servletResponse.setCharacterEncoding("utf-8");
              // 设置响应的内容类型
              servletResponse.setContentType("text/html;charset=utf-8");
      
              PrintWriter out = null;
              try {
                  out = servletResponse.getWriter();
              } catch (IOException e) {
                  e.printStackTrace();
              }
              if(initUser.equals(username) && initPassword.equals(password)){
                  // 4. 打印响应字符
                  out.println("Hello: " + username);
              }else{
                  out.println("Sorry: " + username + "，你甭想进来！");
              }
          }
      }
      ```

  - GenericServlet中有一个init()函数（**下面写的是视频的解释，个人查证后的在开头的学习体会中**）

    - 因为在子类LoginServlet2中存在一种需求：对当前的Servlet进行初始化，即覆盖init方法

      ```java
      @Override
      public void init(ServletConfig servletConfig) throws ServletException {
      	System.out.println("初始化");
      }
      ```

    - 运行后会报空指针异常，这是因为初始化的时候覆盖了父类初始化方法，这样ServletConfig就没有传参过去，因此就不能调用ServletConfig的各个函数。

    - 因此加入一个init()函数，里面不传参

      ```java
      @Override
      public void init(ServletConfig servletConfig) throws ServletException {
          this.servletConfig = servletConfig;
          init();
      }
      
      public void init() throws ServletException {
      }
      ```

    - 这时，再在LoginServlet2中初始化时，会使用init()函数，则不会再报错。

### 4.7 HttpServlet

- 若有个需求：获取请求方式是get还是post

  - 这样每次使用的时候都需要将request强转为HttpServletRequest

- 定义GenericServlet是为了集成ServletConfig中的方法，从而直接获得更多的内容，就不用new ServletConfig了

- 在GenericServlet的基础上HttpServlet继承了GenericServlet类，集成了HttpServletRequest和HttpServletResponse的各种方法，就不用强转了。

- HttpServlet是一个Servlet，继承自GenericServlet，针对HTTP协议所定制。

- 在service方法中直接把ServletRequest和ServletResponse转为HttpServletRequest和HttpServletResponse，并调用了重载的service(HttpServletRequest, HttpServletResponse)；在这个重载的service中获取了请求方式：request.getMethod()，根据请求方式又创建了doXxx()方法（Xxx为具体的请求方式，如doGet，doPost）

- **实际开发中，直接继承HttpServlet，并根据请求方式重写doXxx方法接口**。（主要指doGet，doPost）

- 好处：

  - 直接有针对性的覆盖doXxx方法
  - 直接使用HttpServletRequest和HttpServletResponse，不再需要强转。

- 手写HttpServlet的原理

  - MyHttpServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.ServletException;
    import javax.servlet.ServletRequest;
    import javax.servlet.ServletResponse;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: MyHttpServletRequest.java
     * @time: 2020/4/14 16:30
     * @desc: |针对http协议定义的Servlet基类
     */
    
    public class MyHttpServlet extends MyGenericServlet{
        @Override
        public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
            HttpServletRequest request;
            HttpServletResponse response;
            try {
                request = (HttpServletRequest)req;
                response = (HttpServletResponse)res;
            } catch (ClassCastException var6) {
                throw new ServletException("http.non_http");
            }
    
            this.service(request, response);
        }
    
        public void service(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
            // 1. 获取请求方式
            String method = servletRequest.getMethod();
    
            // 2. 根据请求方式再调用对应的处理方法
            if("GET".equalsIgnoreCase(method)){
                doGet(servletRequest, servletResponse);
            }
    
            if("POST".equalsIgnoreCase(method)){
                doPost(servletRequest, servletResponse);
            }
        }
    
        public void doPost(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
        }
    
        public void doGet(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
        }
    }
    ```

  - 继承MyHttpServlet来实现简化开发

    ```java
    package com.litian.test;
    
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    import java.io.PrintWriter;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LoginServlet.java
     * @time: 2020/4/13 14:17
     * @desc: |继承MyHttpServlet来实现简化开发
     */
    
    public class LoginServlet3 extends MyHttpServlet {
        @Override
        public void doPost(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
            // 获取的请求方式是GET还是POST
            String method = servletRequest.getMethod();
            System.out.println(method);
    
            // 1. 获取请求参数：username和password
            String username = servletRequest.getParameter("username");
            String password = servletRequest.getParameter("password");
    
            // 2. 获取当前WEB应用的初始化参数：user，password
            // 需要使用ServletContext对象
            String initUser = getServletContext().getInitParameter("user");
            String initPassword = getServletContext().getInitParameter("password");
    
            // 3. 比对
            // 设置中文乱码问题
            servletResponse.setCharacterEncoding("utf-8");
            // 设置响应的内容类型
            servletResponse.setContentType("text/html;charset=utf-8");
    
            PrintWriter out = null;
            try {
                out = servletResponse.getWriter();
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (initUser.equals(username) && initPassword.equals(password)) {
                // 4. 打印响应字符
                out.println("Hello: " + username);
            } else {
                out.println("Sorry: " + username + "，你甭想进来！");
            }
        }
    }
    ```

- 利用HttpServ实现上述小题目

> 小题目：
> 在MySQL数据库中穿件一个test_users.users数据表，添加3个字段：id，user，password，并录入几条记录。
> 定义一个login.html，里边定义两个请求字段：user，password，发送请求到loginServlet；再创建一个LoginServlet4（使用HttpServlet），在其中获取请求的user，password。
> 利用JDBC从test_users.users中查询有没有和页面输入的user，password对应的记录。
> select count(id) from users where user=? and password=?
> 若有，响应Hello：xxx；若没有，响应Sorry：xxx；xxx为user。

- 代码

  ```java
  package com.litian.test;
  
  import javax.servlet.ServletException;
  import javax.servlet.http.HttpServlet;
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  import java.io.IOException;
  import java.io.PrintWriter;
  import java.sql.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: LoginServlet.java
   * @time: 2020/4/13 14:17
   * @desc: |
   */
  
  public class LoginServlet4 extends HttpServlet {
      @Override
      protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          String username = req.getParameter("username");
          String password = req.getParameter("password");
  
          // 设置中文乱码问题
          resp.setCharacterEncoding("utf-8");
          // 设置响应的内容类型
          resp.setContentType("text/html;charset=utf-8");
  
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
  
          PrintWriter out = resp.getWriter();
  
          try {
              Class.forName("com.mysql.cj.jdbc.Driver");
              String url = "jdbc:mysql://localhost:3306/test_users?serverTimezone=GMT%2B8";
              String ur = "root";
              String psd = "123456";
              conn = DriverManager.getConnection(url, ur, psd);
              String sql = "select count(id) from users where user=? and password=?";
              ps = conn.prepareStatement(sql);
              ps.setString(1, username);
              ps.setString(2, password);
  
              rs = ps.executeQuery();
              if (rs.next()) {
                  int count = rs.getInt(1);
                  if (count > 0) {
                      out.println("登陆成功：" + username);
                  } else {
                      out.println("登陆失败：" + username + "，自己赶紧滚！");
                  }
              }
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
              try {
                  if (rs != null) {
                      rs.close();
                  }
              } catch (SQLException e) {
                  e.printStackTrace();
              }
              try {
                  if (ps != null) {
                      ps.close();
                  }
              } catch (SQLException e) {
                  e.printStackTrace();
              }
              try {
                  if (conn != null) {
                      conn.close();
                  }
              } catch (SQLException e) {
                  e.printStackTrace();
              }
          }
      }
  }
  ```

- idea报错：java.lang.ClassNotFoundException: com.mysql.cj.jdbc.Driver解决方案：

  这是因为没有导入mysql的包，注意：只需要把包复制到对应的lib目录，这点很重要，一定要复制，并且不用配置工程中lib的路径，只需要复制，就行（不复制，怎么配置路径都没用，我试了）

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200414182805564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 运行结果

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020041418341943.png)

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200414183442404.png)

## 5. JSP

### 5.1 JSP概述





------

我的CSDN：https://blog.csdn.net/qq_21579045

我的博客园：https://www.cnblogs.com/lyjun/

我的Github：https://github.com/TinyHandsome

纸上得来终觉浅，绝知此事要躬行~

欢迎大家过来OB~

by 李英俊小朋友
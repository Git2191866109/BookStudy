# 尚硅谷JavaWeb学习笔记

[TOC]

## 写在前面

学习链接：[Java Web 视频教程全集（103P）](https://www.bilibili.com/video/av59545633/)

**特别注意**：该内容全是我自学时，一边听课一边做的笔记，本文的初衷是**希望每一个学习时有疑问的同学能够在这篇文章里找到答案**；里面关于吐槽的内容仅代表个人看法，白嫖党不会针对任何老师或书籍发表不合适的看法，如有冒犯，请见谅。所有传播知识的行为都应该受到尊重，该内容涉及的一切只为学习交流使用，希望每个求知进来的读者都可以满载而归。有任何问题或侵权行为，请联系本人**李英俊小朋友**，我会回应并删除；另外，做笔记真的不容易，希望大家转载时标明作者，若非个人使用的转载，请联系本人，否则必究。

学习体会：跟以前一样，主要写不足之处，优点就不赘述了，这么多视频选择这一个看，就是优点本身的体现了哈哈哈。

> 1. P11中，关于GenericServlet中为何要写一个init()函数，我是真没搞懂，讲的弯弯绕绕，绕来绕去。先是强行假设了子类中需要出示化的需求，init之后会报错。这个假设我是没想到的，为什么会有这种假设？好吧，就算有吧，那么只要init重写的是带ServletConfig参数的，都肯定会报错啊，写个init又能怎么样呢，让别人初始化就只能用这个init吗？（**这部分主要是啰嗦太多了**，给我绕晕了，简单说的话就容易理解多了）
>
>    这里需要附上重写和重载的区别帮助理解，[参考链接](https://www.runoob.com/java/java-override-overload.html)。百度之后得到的答案是：**为了防止在重载的时候忘记调用super.init(config); 因此写个init()来帮助初始化时增加一些自己的初始化参数**，[参考连接](https://www.cnblogs.com/itmanxgl/p/fbeced7052b9ec29fa5bae652c5ceff4.html)
>
> 2. P12中，关于HttpServlet的doXxx方法讲的我云里雾里的，实在是不知道这个方法具体有什么用
>
>    调用流程是：浏览器发送请求 -> 调用service(servletRequest, servletReponse)方法，该方法将里面的两个传参转化为Http的类 -> 然后再调用service(HttpServletRequest, HttpServletResponse)方法，在这个方法中根据method的不同使用不同的**doMethod()**（即doGet，doPost），而这个方法中的内容需要自己重写。 -> 实现了根据method方式完成不同的功能。[参考链接](https://blog.csdn.net/zhaolang2009/article/details/80678660?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2)
>
> 3. 一直都有一个疑问，在idea中怎么弄Junit
>
>    在src目录同级建一个test目录，然后右键设置该目录为测试目录。然后在想要测试的的java类文件页面中，点击编辑栏中的Navigate-Test，就能调出来测试类，并且该类在test目录中生成，[参考链接](https://blog.csdn.net/dongzhensong/article/details/89450823)。此外，Junit是需要jar包的，idea中如果报错的话，可以通过点击红色的灯泡，下载Junit4和5。
>
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200423163408355.png)
>
>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020042316371813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
>
>    

## 1. 前言

- 在Sun的JavaServlet规范中：JavaWeb应用由一组Servlet、HTML页、类、以及其他可以被绑定的资源构成。它可以在各种供应商提供的**实现Servlet规范的Servlet容器中运行**。

- JavaWeb应用中可以包含如下内容：

  - Servlet
  - JSP
  - 实用类
  - 静态文档如HTML、图片等
  - 描述Web应用的信息（web.xml）

- Servlet与Servlet容器

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409124223247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- Servlet容器的概念

  - Servlet容器为JavaWeb应用提供运行时的环境，它负责管理Servlet和JSP的生命周期，以及管理它们的共享数据。
  - Servlet容器也称为JavaWeb应用容器，或者Servlet/HSP容器。
  - 目前最流行的Servlet容器软件包括：
    - Tomcat
    - Resin
    - J2EE服务器（如Weblogic）中也提供了内置的Servlet容器

- **Tomcat**：Apache、Sun和其他一些公司及个人共同开发完成。

  - Tomcat的目录层次结构

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409125526469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - 运行Tomcat

    1. 配置java_home或jre_home（这一步我能运行哈哈哈哈，我用的tomcat9）
    2. 双击bin目录下的startup.bat文件
    3. 在地址栏中输入http://localhost:8080/
    4. 若已经启动了一个Tomcat应用，若再启动同一个Tomcat应用，则会抛出异常（这是因为端口被占用了）

  - 关闭Tomcat&配置Tomcat的端口号

    1. 双击bin目录下的shutdown.bat文件关闭Tomcat服务器

    2. 修改Tomcat默认的端口号：

       - 打开conf目录下的server.xml文件
       - 修改端口号

       ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409130844768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - catalina：可以通过设置catalina_home环境变量的方式来通过dos启动关闭tomcat

    - 为了可以在任意目录下启动Tomcat服务器

    1. 把Tomcat的bin目录添加到path下（但是这样添加成功会，通过startup启动Tomcat会有提示：catalina的环境变量没有正确设置）
    2. 设置CATALINA_HOME环境变量：
       1. 通过阅读startup.bat文件可知，该环境变量下有一个bin目录，而bin目录下又有一个catalina.bat文件，由此可知CATALINA_HOME指向的应该是Tomcat安装的根目录
       2. 于是把Tomcat的根目录设为CATALINA_HOME环境变量
       3. 此时即可以在任意根目录下通过startup.bat、shutdown.bat启动、关闭Tomcat服务器
       4. 继续阅读startup.bat文件，发现启动tomcat服务器的是catalina.bat文件，在命令行窗口直接输入catalina会有各种命令的提示，出现各种可选参数。
       5. 常用的有：run（同窗口启动服务器）、start（新窗口启动服务器）、stop（关闭服务器）

  - Tomcat的管理程序

    - Tomcat提供了一个管理程序：manager，用于部署到Tomcat服务器中的web应用程序
    - 要访问manager web应用程序，需要添加具有管理员权限的账号，编辑conf目录下的**tomcat-users.xml**文件，添加manager角色，设置用户名和密码
    - **注意**：这里我在操作的时候，发现我用的是tomcat9嘛，所以跟视频里面将的不一样，设置的时候发现仅仅设置manager是不行的，并且**tomcat-users.xml**文件中也说了不同的用户对应着不同的管理权限，不像以前直接manager用户管所有了，因此为了解决这个问题查了百度，[参考链接](http://blog.sina.com.cn/s/blog_6ac4c6cb0101485d.html)，这样就解决了。另外，不能像视频中设置用户和密码为空，不然一直弹框也进不去。

## 2. Web程序结构

- 一个web应用程序是由一组Servlet，HTML页面，类，以及其他的资源组成的运行在web服务器上的完整的应用程序，以一种结构化的有层次的目录形式存在。

- 组成web应用程序的这些文件要部署在相应的目录层次中，根目录代表整个web应用程序的“根”。

- 通常将web应用程序的目录放在webapps目录下，在webapps目录下的每一个子目录都是一个独立的web应用程序，子目录的名字就是web应用程序的名字，也就是web应用程序的“根”。用户通过web应用程序的“根”来访问web应用程序中的资源。

- Servlet规范汇总定义了web应用程序的目录层次

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409153613329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- **注意**：跟着视频在创建jsp文件的时候，我发现并没有这个新建这个文件的选择，网上搜了搜方法，据说是：“IDEA认为我这个包建的有问题，才导致这地方不应该创建jsp文件，所以就没有创建JSP文件的选项。” [参考连接](https://blog.csdn.net/weixin_44381073/article/details/89816624)，采用这个方法之后就可以新建jsp文件了。

- JSP(Java Server Pages，java服务器端网页)是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。

- 第一个WEB应用程序：开发，并部署到Tomcat服务器下运行

  1. 新建一个JavaProject
  2. 在Java项目下创建WEB开发的目录结构
     - WebContent
       - WEN-INF
         - classes 编译后的class文件必须放在该目录下
         - lib
         - web.xml （从Tomcatwebapps\docs\WEB-INFO中复制过来，可以不做修改）
       - html 页面
       - jsp 页面
       - 图片。。。
  3. 在src下新建一个Person类
  4. 手工的Person类对应的Class文件（含包）复制到classes目录下
     - 可以通过修改默认的输出目录达到自动把编译好的class放到classes目录下
     - 由于视频中是eclipse操作的，因此我搜了一下idea的[操作方法](https://www.cnblogs.com/dslx/p/10172602.html)
  5. 在WebContent目录下新建一个JSP文件
  6. 把WebContent目录复制到Tomcat的webapps目录下，并改名为helloworld
  7. 在浏览器的地址栏中输入http://localhost:8080/WebContent/hello.jsp即可看到命令行打印的信息
  8. 使用【配置任意目录下Web应用程序2】的方式建立.xml文件，实现直接部署

- 配置任意目录下Web应用程序1

  - 在Web服务器中可以配置虚拟目录，而虚拟目录所对应的真实目录可以在任何路径下
  - 在Tomcat服务器中，主要在XML配置文件中通过`<Context>`元素的设置来完成的。一个`<Context>`元素就表示一个Web应用程序，运行在特定的虚拟主机中
  - `<Context>`元素是`<Host>`元素的子元素，可以在conf\server.xml文件中设置Context元素
  - 使用docBase属性指定Web应用程序的真实路径。将属性reloadable设置为true，Tomcat在运行时会自动监测Servlet类的改动，如果发现有类被更新，Tomcat服务器将自动重新加载该Web应用程序。这样，在开发时，就不需要频繁重启Tomcat了。

- 配置任意目录下Web应用程序2（超酷）

  - 还可以在conf目录下一次创建Catalina\localhost目录，然后在localhost目录下为test这个Web应用程序建立test.xml文件，编辑这个文件输入以下内容`<Context path="/test" docBase="c:/test" reloadable="true">`
  - 从Tomcat5开始，**不建议直接在server.xml文件中配置`<Context>`元素**，因为server.xml文件作为Tomcat的主要配置文件，一旦Tomcat启动后，将不会再读取这个文件，因此无法在Tomcat服务器启动时发布Web应用程序。如果在其他地方配置`<Context>`元素，那么在Tomcat运行时，也可以发布Web应用程序。
  - 从Tomcat5.5开始，在\conf\Catalina\localhost目录下创建XML配置文件来配置Web应用程序，**Tomcat将以XML文件的文件名作为Web应用程序的上下文路径**，而不会理会在`<Context>`元素的path属性中指定的上下文路径是什么。由于Tomcat5.5之后的版本是以XML配置文件的文件名作为Web应用程序的上下文路径的，因此在配置`<Context>`元素时，可以不使用path属性。

- 文件修改为helloworld2.xml

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <Context path="/test2" docBase="F:/BookStudy/else/JavaWebPro/WebContent" reloadable="true"/>
  ```

- 上述内容的解释

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409173352178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- **之前没有实现自动化的结果这里就不展示了**

- 自动化包含了两个，具体实现方法在上面

  - 一是将class输出的位置放到WebContent/WEB-INF/classes下
  - 二是通过配置任意目录下Web应用程序（使用第2种方法），把后面的原路径映射道虚拟路径上，实现实时更新项目的目的，这样修改了原始项目的内容，也可以不用重启Tomcat直接展示最新的结果。

- 报错问题：

  - org.apache.jasper.JasperException: Unable to compile class for JSP:
  - JSP出现 类名 cannot be resolved to a type
  - 上面两种问题是同一页面出现的。。。我查了一万个方法。。。最后发现是WEB-INF写成WEB-INFO了
  - 所以出了问题的第一件事情，一定要从自己这里找原因。。。哭！

- 最后运行成功的图如下：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409171814200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

## 3. 使用Eclipse / Idea开发JavaWeb项目

- [Idea配置1](https://blog.csdn.net/With_Her/article/details/89243777?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)、[Idea配置2](https://blog.csdn.net/chenshun123/article/details/51285890)

- Eclipse配置：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410120252614.png)

## 4. Servlet

- Java Servlet是和平台无关的服务器端组件，它运行在Servlet容器中。Servlet容器负责Servlet和客户的通信以及调用Servlet的方法，Servlet和客户的通信采用“请求/响应”的模式。

- Server Applet

- Servlet可完成如下功能：

  - 创建并返回基于客户请求的动态HTML页面
  - 创建可嵌入到现有HTML页面中的部分HTML页面（HTML片段）。
  - 与其它服务器资源（如数据库或基于Java的应用程序）进行通信。

- Servlet容器响应客户请求的过程

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410120926345.png)

- Servlet API

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410121212144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 4.1 第一个Servlet程序

- 问题：我在操作的时候，发现不能implements Servlet，网上查了查，说是没有导入对应的包

- [解决方法](https://www.cnblogs.com/ifeil/p/9378921.html)：实际上就是在Modules中的项目里的Dependences中+上Tomcat的library

- 问题：在启动自己的HelloServlet时，输出中文为乱码

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410123530828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- [解决方法](https://www.cnblogs.com/chenxianbin/p/11367954.html)：早Tomcat的conf路径下修改logging.properties文件中，将下图的位置的UTF-8改为GBK

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020041012373535.png)

- 问题：xml文件在写的时候，如何优雅的注释

- [解决方法](https://blog.csdn.net/weixin_33889245/article/details/94303669)：CTRL + SHIFT + / 直接调出注释

- **自己的解决方法**：我自己做了一个Live Template：输入<然后回车就会直接生成注释

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410125509301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- Servlet的HelloWorld

  1. 创建一个Servlet接口的实现类（记住这个时候要导入Tomcat的library，[参考链接](https://blog.csdn.net/weixin_44319545/article/details/100544309)）

  2. 在web.xml文件中配置和映射这个Servlet（目的是希望能够通过浏览器去访问java类）

     ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410124301987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 具体实现

  - HelloServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: HelloServlet.java
     * @time: 2020/4/10 12:20
     * @desc: |
     */
    
    public class HelloServlet implements Servlet {
    
        public HelloServlet() {
            System.out.println("HelloServlet构造器已启动...");
        }
    
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            System.out.println("初始化中...");
        }
    
        @Override
        public ServletConfig getServletConfig() {
            System.out.println("获取Servlet配置中...");
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            System.out.println("服务中...");
        }
    
        @Override
        public String getServletInfo() {
            System.out.println("获取Servlet信息中...");
            return null;
        }
    
        @Override
        public void destroy() {
            System.out.println("毁灭中...");
        }
    }
    ```

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
        <!-- 配置和映射Servlet -->
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.HelloServlet</servlet-class>
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello</url-pattern>
        </servlet-mapping>
    </web-app>
    ```

### 4.2 Servlet配置及生命周期方法

- Servlet容器：运行Servlet、JSP、Filter等的软件环境
  - 可以来创建Servlet，并调用Servlet的相关生命周期方法
  - JSP，Filter，Listener，Tag…
- Servlet生命周期的方法：以下方法都是由Servlet容器负责调用
  - 构造器方法：只被调用一次，只有第一次请求Servlet时，创建Servlet的实例，调用构造器。（这说明Servlet是单实例的）
  - init方法：只被调用一次，在创建好实例后立即被调用，用于初始化当前Servlet。
  - service：被多次调用。每次请求都会调用service方法，实际用于相应请求的。
  - destroy：只被调用一次，在当前Servlet所在的WEB应用被卸载前调用，用于释放当前Servlet所占用的资源。
- load-on-startup参数
  - 配置在Servlet节点中
  - load-on-startup：可以指定Servlet被创建的时机，若为负数，则在第一次请求时被创建。若为0或正数，则在当前WEB应用被Servlet容器被加载时创建实例，且数值越小越早被创建。负数，则不创建。
- Servlet容器响应客户请求的过程
  1. Servlet引擎检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第4步，否则，执行第2步
  2. 装载并创建该Servlet的第一个实例对象：调用该Servlet的构造器
  3. 调用Servlet实例对象的init()方法
  4. 创建一个用于封装请求的ServletRequest对象和一个代表响应消息的ServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传进去
  5. WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法
- Servlet的注册于运行
  - Servlet程序必须通过Servlet容器来启动运行，并且存储目录有特殊要求，通常需要存储在`<WEB应用程序目录>\WEB-INF\classes\`目录中。
  - Servlet程序必须在WEB应用程序的web.xml文件中进行注册和映射其访问路径，才可以被Servlet引擎加载和被外界访问。
  - 一个`<servlet>`元素用于注册一个Servlet，它包含有两个主要的子元素：
    - `<servlet-name>`：用于设置Servlet的注册名称
    - `<servlet-class>`：用于设置Servlet的完整类名
  - 一个`<servlet-mapping>`元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：
    - `<servlet-name>`：用于设置Servlet的注册名称
    - `<url-pattern>`：用于设置Servlet的对外访问路径
- Servlet映射的细节
  - 同一个Servlet可以被映射到多个URL上，即多个`<servlet-mapping>`元素的`<servlet-name>`子元素的设置值可以是同一个Servlet的注册名
  - 在Servlet映射到的URL中也可以使用`*`通配符，但是只能有两种固定的格式：一种是`*.扩展名`，另一种格式是以正斜杠`/`开头并以`/*`结尾
  - 注意：`/*.扩展名`，即既带/又带扩展名的不合法

### 4.3 ServletConfig & ServletContext

- 封装了Servlet的配置信息，并且可以获取ServletContext对象（ServletConfig获取的是该Servlet的初始化参数，ServletContext中可以获取全局的初始化参数）
  1. 配置Servlet的初始化参数
  2. 获取初始化参数：
     - getInitParameter(String name)：获取指定参数名的初始化参数
     - getInitParameterNames()：获取参数名组成的Enumeration对象
  3. 获取Servlet的配置名称
  4. getServletContext
     - Servlet引擎为 **每个WEB应用程序** 都创建一个对应的ServletContext对象，ServletContext对象被包含在ServletConfig对象中，调用ServletConfig.getServletContext方法可以返回ServletContext对象的应用。
     - **由于一个WEB应用程序中的所有Servlet都共享同一ServletContext对象**，所以，ServletContext对象被称为application对象（Web应用程序对象）
     - 功能：
       - 获取WEB应用程序的初始化参数
       - 记录日志
       - application域范围的属性
       - 访问资源文件
       - 获取虚拟路径所映射的本地路径
       - WEB应用程序之间的访问
       - ServletContext的其他方法

- 代码

  - HelloServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    import java.io.InputStream;
    import java.util.Enumeration;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: HelloServlet.java
     * @time: 2020/4/10 12:20
     * @desc: |
     */
    
    public class HelloServlet implements Servlet {
    
        public HelloServlet() {
            System.out.println("HelloServlet构造器已启动...");
        }
    
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            // 1. ServletConfig
            // 针对Servlet的初始化参数
            System.out.println("初始化中...");
            String user = servletConfig.getInitParameter("user");
            System.out.println("user: " + user);
            Enumeration<String> names = servletConfig.getInitParameterNames();
            while(names.hasMoreElements()){
                String name = names.nextElement();
                String value = servletConfig.getInitParameter(name);
                System.out.println(name + "-->" + value);
            }
            String servletName = servletConfig.getServletName();
            System.out.println(servletName);
    
            // 2. ServletContext
            // 针对app的初始化参数，相较于上面，该参数适用于所有Servlet，相当于全局的参数
            // 2.1 获取ServletContext对象
            ServletContext sc = servletConfig.getServletContext();
            // 获取WEB应用程序的初始化参数
            String driver = sc.getInitParameter("driver");
            System.out.println("driver: " + driver);
            Enumeration<String> names2 = sc.getInitParameterNames();
            while(names2.hasMoreElements()){
                String name = names2.nextElement();
                String value = sc.getInitParameter(name);
                System.out.println(name + "-->" + value);
            }
    
            // 2.2 获取当前WEB应用的某一个文件在服务器上的绝对路径：
            String realPath = sc.getRealPath("/index.jsp");
            System.out.println(realPath);
    
            // 2.3 获取当前WEB应用的名称
            String contextPath = sc.getContextPath();
            System.out.println(contextPath);
    
            // 2.4 获取当前WEB应用的某一个文件对应的输入流
            // path的 / 响度与当前WEB应用的根目录
            try {
                ClassLoader cl = getClass().getClassLoader();
                InputStream is = cl.getResourceAsStream("jdbc.properties");
                System.out.println("1. " + is);
    
                InputStream is2 = sc.getResourceAsStream("jdbc.properties");
                System.out.println("2. " + is2);
    
                InputStream is3 = sc.getResourceAsStream("/WEB-INF/classes/jdbc.properties");
                System.out.println("3. " + is3);
            } catch (Exception e) {
                e.printStackTrace();
            }
    
            // 2.5 和attribute相关的几个方法
    
        }
    
        @Override
        public ServletConfig getServletConfig() {
            System.out.println("获取Servlet配置中...");
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            System.out.println("服务中...");
        }
    
        @Override
        public String getServletInfo() {
            System.out.println("获取Servlet信息中...");
            return null;
        }
    
        @Override
        public void destroy() {
            System.out.println("毁灭中...");
        }
    }
    ```

  - SecondServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: SecondServlet.java
     * @time: 2020/4/11 10:11
     * @desc: |
     */
    
    public class SecondServlet implements Servlet {
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            System.out.println("第二次Servlet初始化");
        }
    
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
    
        }
    
        @Override
        public String getServletInfo() {
            return null;
        }
    
        @Override
        public void destroy() {
    
        }
    }
    ```

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
        <!-- 配置和映射Servlet -->
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.HelloServlet</servlet-class>
    
            <!-- 配置Servlet的初始化参数，且节点必须在load-on-startup节点的前面 -->
            <init-param>
                <!-- 参数名 -->
                <param-name>user</param-name>
                <!-- 参数值 -->
                <param-value>root</param-value>
            </init-param>
            <init-param>
                <param-name>password</param-name>
                <param-value>1230</param-value>
            </init-param>
    
            <!-- 可以指定Servlet被创建的时机 -->
            <load-on-startup>5</load-on-startup>
    
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello</url-pattern>
        </servlet-mapping>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello2</url-pattern>
        </servlet-mapping>
    
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>secondServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.SecondServlet</servlet-class>
            <!-- 可以指定Servlet被创建的时机 -->
            <load-on-startup>2</load-on-startup>
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>secondServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>*.html</url-pattern>
        </servlet-mapping>
    </web-app>
    ```

### 4.4 HTTP简介

- WEB浏览器与WEB浏览器之间的一问一答的交互过程，必须遵循一定的规则，这个规则就是HTTP协议

- HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是TCP/IP协议集中的一个应用层协议，**用于定义WEB浏览器与WEB浏览器之间交换数据的过程以及数据本身的格式**。

- HTTP协议的版本HTTP/1.0、HTTP/1.1、HTTP-NG

- HTTP的会话方式：

  - 四个步骤：建立连接、发出请求信息、回送响应信息、关闭连接
  - 浏览器与WEB服务器的连接过程是短暂的，每次连接只处理一个请求和响应。对每一个页面的访问，浏览器与WEB服务器都要建立一次单独的连接。
  - 浏览器到WEB服务器之间的所有通讯都是完全独立分开的请求和响应对。

- 浏览器范文多图网页的过程

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412145427186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- HTTP请求消息

  - 请求消息的结果：**一个请求行、若干消息头以及实体内容**，其中一些消息头和实体内容都是可选的，消息头和实体内容之间要用空行隔开。

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412145629979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- HTTP响应信息

  - 响应信息的结构：**一个状态行、若干消息头、以及实体内容**，其中一些消息头和实体内容都是可选的，消息头和实体内容之间要用空行隔开。

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412145820158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 其他细节

  - 响应消息的实体内容就是网页文件的内容，也就是在浏览器中使用查看源文件的方式所看到的内容
  - 一个使用GET方式的请求消息中不能包含实体内容，只有使用POST、PUT和DELETE方式的请求消息中才可以包含实体内容。

- 使用GET和POST方式传递参数

  - 在URL地址后面还可以附加一些参数

  - GET方式：

    - 传输的数据量是有限的，一般限制在1KB以下。
    - 在浏览器地址栏中输入某个URL地址或单击网页上的一个超链接时，浏览器发出的HTTP请求消息的请求方式为GET
    - 如果网页中的`<form>`表单元素的method属性被设置为了“GET”，浏览器提交这个FROM表单时生成的HTTP请求消息方式也为GET
    - 使用GET请求方式给WEB服务器传递参数的格式：`xxx?name=l&pwd=123`

  - POST方式：

    - POST方式将各个表单字段元素及其数据作为HTTP消息的实体内容发送给WEB服务器。传送的数据量要比GET方式传送的数据量大得多。

    - POST请求方式主要用于向WEB服务器端程序提交FORM表单中的数据。

    - 格式：

      ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412152046412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 4.5 ServletRequest & ServletResponse

- 如何在Servlet中获取请求信息：

  - Servlet的service()方法用于应答请求：因为每次请求都会调用service()方法

- ServletRequest：封装了请求信息，可以从中获取到任何的请求信息。

- ServletResponse：封装了响应信息，如果想给用户什么响应，均可以使用该接口的方法实现。

- 这两个接口的实现类都是服务器给予实现的，并在服务器调用service方法时传入。

>  问题1：在实验的时候我发现了一个大问题，就是每次改了代码之后，都需要重启Servlet才能行。
>
>  解决方案：[参考链接](https://blog.csdn.net/Jodie_Girl/article/details/103597872)，我在参考连接的基础上对Tomcat的配置进行了修改，也就是如图所示的部分，全部修改为update classes and resources
>  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413120914681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
>
>  问题2：IDEA中重新启动一共有四种选择，分别是什么意思
>  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413122116504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
>
>  解决方案：[参考连接](https://blog.csdn.net/qq_40871734/article/details/99749715)，我发现选择重新部署，也就是第三个，才能起到刷新java类的效果

- ServletRequest：

  - 获取请求参数：
    - String getParameter(String name)：根据请求参数的名字，返回参数值（若请求参数有多个值，如checkbox，该方法只能获取到第一个提交的值）。
    - Map getParameterMap()：返回请求参数的键值对：Key：参数名；Value：参数值，String数组类型。
    - Enumeration getParameterNames()：返回参数名对应的Enumeration对象，类似于ServletConfig(或ServletContext)的getInitParameterNames()方法。
    - String[] getParameterValues(String name)：根据请求参数的名字，返回请求参数对应的字符串数组
    
  - 流程图
  
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413120207777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
  
- HttpServletRequest：是ServletRequest的子接口，针对HTTP请求所定义。里边包含了大量获取HTTP请求的方法

  - 获取请求的URL：HttpServletRequest.getRequestURI()，结果示例：`/app2/loginServLet`
  - 获取请求的方式：HttpServletRequest.getMethod()，结果示例：`GET`
  - 获取请求参数的字符串：HttpServletRequest.getQueryString()，结果示例：`user=111&password=333&interesting=reading&interesting=game&interesting=party`
  - 获取Servlet的映射路径：HttpServletRequest.getServletPath()，结果示例：`/loginServLet`
  - 和attribute相关的几个方法

- ServletResponse

  - getWriter()：返回PrintWriter对象，调用该对象的print()方法，将把print()中的参数直接打印到客户的浏览器上。
  - setContentType()：设置响应的内容类型。

- HttpServletResponse：跟HttpServletRequest同理，有一个超重要的方法

  - void sendRedirect(String location)：请求的重定向。（此方法为HttpServletResponse中定义，因此使用时需要强转）

- 上述的实现代码

  - LoginServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import java.io.IOException;
    import java.io.PrintWriter;
    import java.util.Arrays;
    import java.util.Enumeration;
    import java.util.Map;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LoginServlet.java
     * @time: 2020/4/13 11:45
     * @desc: |
     */
    
    public class LoginServlet implements Servlet {
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
    
        }
    
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            System.out.println("请求来了！");
            System.out.println(servletRequest);
    
            String user = servletRequest.getParameter("user");
            String psd = servletRequest.getParameter("password");
            System.out.println(user + "-->" + psd);
    
            String interesting = servletRequest.getParameter("interesting");
            System.out.println(interesting);
    
            String[] interestings = servletRequest.getParameterValues("interesting");
            System.out.println(interestings);
            for(String a: interestings){
                System.out.println(a);
            }
    
            Enumeration<String> names = servletRequest.getParameterNames();
            while(names.hasMoreElements()){
                String name = names.nextElement();
                String val = servletRequest.getParameter(name);
    
                System.out.println("3. " + name + ": " + val);
            }
    
            Map<String, String[]> map = servletRequest.getParameterMap();
            for(Map.Entry<String, String[]> entry: map.entrySet()){
                System.out.println("4. " + entry.getKey() + ": " + Arrays.asList(entry.getValue()));
            }
    
            HttpServletRequest hsr = (HttpServletRequest) servletRequest;
            String requestURI = hsr.getRequestURI();
            System.out.println(requestURI);
    
            String method = hsr.getMethod();
            System.out.println(method);
    
            String qs = hsr.getQueryString();
            System.out.println(qs);
    
            String sp = hsr.getServletPath();
            System.out.println(sp);
    
            // 设置响应的内容类型：这里设置成word格式，那么submit之后会让你下载一个文件，文件可以用word打开，内容是write中的内容。
            servletResponse.setContentType("application/msword");
    
            PrintWriter out = servletResponse.getWriter();
            out.println("What are you talking about?");
    
        }
    
        @Override
        public String getServletInfo() {
            return null;
        }
    
        @Override
        public void destroy() {
    
        }
    }
    ```

  - login.html

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
    <form action="loginServLet" method="get">
        user: <input type="text" name="user">
        password: <input type="password" name="password">
    
        <br><br>
    
        interesting:
        <input type="checkbox" name="interesting" value="reading" />Reading
        <input type="checkbox" name="interesting" value="game" />Game
        <input type="checkbox" name="interesting" value="party" />Party
        <input type="checkbox" name="interesting" value="shopping" />Shopping
        <input type="checkbox" name="interesting" value="sport" />Sport
        <input type="checkbox" name="interesting" value="tv" />TV
    
        <input type="submit" value="submit"/>
    </form>
    
    </body>
    </html>
    ```

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
    
        <!-- 获取WEB应用程序的初始化参数 -->
        <context-param>
            <param-name>driver</param-name>
            <param-value>com.mysql.cj.jdbc.Driver</param-value>
        </context-param>
    
        <context-param>
            <param-name>jdbcUrl</param-name>
            <param-value>jdbc:mysql://localhost:3306/testjdbc?serverTimezone=GMT%2B8</param-value>
        </context-param>
    
        <!-- 配置和映射Servlet -->
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.HelloServlet</servlet-class>
    
            <!-- 配置Servlet的初始化参数，且节点必须在load-on-startup节点的前面 -->
            <init-param>
                <!-- 参数名 -->
                <param-name>user</param-name>
                <!-- 参数值 -->
                <param-value>root</param-value>
            </init-param>
            <init-param>
                <param-name>password</param-name>
                <param-value>1230</param-value>
            </init-param>
    
            <!-- 可以指定Servlet被创建的时机 -->
            <load-on-startup>5</load-on-startup>
    
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello</url-pattern>
        </servlet-mapping>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello2</url-pattern>
        </servlet-mapping>
    
    <!--    <servlet>-->
    <!--        &lt;!&ndash; Servlet 注册的名字 &ndash;&gt;-->
    <!--        <servlet-name>secondServlet</servlet-name>-->
    <!--        &lt;!&ndash; Servlet 的全类名 &ndash;&gt;-->
    <!--        <servlet-class>com.litian.test.SecondServlet</servlet-class>-->
    <!--        &lt;!&ndash; 可以指定Servlet被创建的时机 &ndash;&gt;-->
    <!--        <load-on-startup>2</load-on-startup>-->
    <!--    </servlet>-->
    
    <!--    <servlet-mapping>-->
    <!--        &lt;!&ndash; 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 &ndash;&gt;-->
    <!--        <servlet-name>secondServlet</servlet-name>-->
    <!--        &lt;!&ndash; 映射具体的访问路径：/ 代表当前WEB应用的根目录 &ndash;&gt;-->
    <!--        <url-pattern>*.html</url-pattern>-->
    <!--    </servlet-mapping>-->
    
        <servlet>
            <servlet-name>loginServlet</servlet-name>
            <servlet-class>com.litian.test.LoginServlet</servlet-class>
        </servlet>
    
        <servlet-mapping>
            <servlet-name>loginServlet</servlet-name>
            <url-pattern>/loginServLet</url-pattern>
        </servlet-mapping>
    
    </web-app>
    ```

### 4.6 GenericServlet

> 小题目：在web.xml文件中设置两个WEB应用的初始化参数，user，password；定义一个login.html，里边定义两个请求字段：user，password，发送请求到loginServlet；再创建一个LoginServlet，在其中获取请求的user，password。比对其和web.xml文件中定义的请求参数是否一致，若一致，响应Hello：xxx；若不一致，响应Sorry：xxx；xxx为user。

- 新建一个工程来实现上述问题

  - 配置Tomcat和一系列设置

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
        <!-- 配置当前WEB应用的初始化参数 -->
        <context-param>
            <param-name>user</param-name>
            <param-value>litian</param-value>
        </context-param>
    
        <context-param>
            <param-name>password</param-name>
            <param-value>123</param-value>
        </context-param>
    
        <!-- 配置Servlet -->
        <servlet>
            <servlet-name>log</servlet-name>
            <servlet-class>com.litian.test.LoginServlet</servlet-class>
        </servlet>
    
        <servlet-mapping>
            <servlet-name>log</servlet-name>
            <url-pattern>/LoginServlet</url-pattern>
        </servlet-mapping>
    </web-app>
    ```

  - login.html

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>冲冲冲</title>
    </head>
    <body>
    <form action="LoginServlet" method="post">
        user: <input type="text" name="username"/>
        password: <input type="password" name="password"/>
        <input type="submit" value="Submit"/>
    </form>
    
    </body>
    </html>
    ```

  - LoginServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    import java.io.PrintWriter;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LoginServlet.java
     * @time: 2020/4/13 14:17
     * @desc: |
     */
    
    public class LoginServlet implements Servlet {
        private ServletConfig servletConfig;
    
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            this.servletConfig = servletConfig;
        }
    
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            // 1. 获取请求参数：username和password
            String username = servletRequest.getParameter("username");
            String password = servletRequest.getParameter("password");
    
            // 2. 获取当前WEB应用的初始化参数：user，password
            // 需要使用ServletContext对象
            ServletContext sc = servletConfig.getServletContext();
            String initUser = sc.getInitParameter("user");
            String initPassword = sc.getInitParameter("password");
    
            // 3. 比对
            // 设置中文乱码问题
            servletResponse.setCharacterEncoding("utf-8");
            // 设置响应的内容类型
            servletResponse.setContentType("text/html;charset=utf-8");
    
            PrintWriter out = servletResponse.getWriter();
            if(initUser.equals(username) && initPassword.equals(password)){
                // 4. 打印响应字符
                out.println("Hello: " + username);
            }else{
                out.println("Sorry: " + username + "，你甭想进来！");
            }
        }
    
        @Override
        public String getServletInfo() {
            return null;
        }
    
        @Override
        public void destroy() {
    
        }
    }
    ```

- GenericServlet（不常用，了解，因为常用HttpServlet）

  - 是一个Servlet，是Servlet接口和ServletConfig接口的实现类，但是是一个抽象类，其中service方法为抽象方法。

  - 存在的意义：如果新建的Servlet程序直接继承GenericServlet会使得开发更简洁。

  - 具体实现

    - 在GenericServlet中声明了一个**ServletConfig**类型的成员变量，在init(ServletConfig)方法中对其进行了初始化。
    - 利用ServletConfig成员变量的方法实现了ServletConfig接口的方法。
    - 还定义了一个**init方法**，在init(ServletConfig)方法中对其进行调用，子类可以直接覆盖init()在其中实现对Servlet的初始化。
    - 不建议直接覆盖带参init，忘记编写super(ServletConfig)，还使用了ServletConfig接口的方法时会报空指针异常。
    - 新建的init()并非Servlet的声明周期方法，而带参的那个是。

  - 手写GenericServlet的原理（实际上还有log日志方法）

    - 自定义一个Servlet接口的实现类：让开发的任何Servlet都继承该类，以简化开发

      ```java
      package com.litian.test;
      
      import javax.servlet.*;
      import java.util.Enumeration;
      
      /**
       * @author: Li Tian
       * @contact: litian_cup@163.com
       * @software: IntelliJ IDEA
       * @file: MyGenericServlet.java
       * @time: 2020/4/14 15:29
       * @desc: |自定义一个Servlet接口的实现类：让开发的任何Servlet都继承该类，以简化开发
       */
      
      public abstract class MyGenericServlet implements Servlet, ServletConfig {
          private ServletConfig servletConfig;
      
          // 以下方法为Servlet接口的方法
          @Override
          public void init(ServletConfig servletConfig) throws ServletException {
              this.servletConfig = servletConfig;
          }
      
          @Override
          public ServletConfig getServletConfig() {
              return servletConfig;
          }
      
          @Override
          public abstract void service(ServletRequest servletRequest, ServletResponse servletResponse);
      
          @Override
          public String getServletInfo() {
              return null;
          }
      
          @Override
          public void destroy() {
      
          }
      
          // 以下方法为ServletConfig接口的方法
          @Override
          public String getServletName() {
              return servletConfig.getServletName();
          }
      
          @Override
          public ServletContext getServletContext() {
              return servletConfig.getServletContext();
          }
      
          @Override
          public String getInitParameter(String s) {
              return servletConfig.getInitParameter(s);
          }
      
          @Override
          public Enumeration<String> getInitParameterNames() {
              return servletConfig.getInitParameterNames();
          }
      }
      ```

    - 利用手写的GenericServlet简化开发

      ```java
      package com.litian.test;
      
      import javax.servlet.*;
      import java.io.IOException;
      import java.io.PrintWriter;
      
      /**
       * @author: Li Tian
       * @contact: litian_cup@163.com
       * @software: IntelliJ IDEA
       * @file: LoginServlet.java
       * @time: 2020/4/13 14:17
       * @desc: |继承MyGenericServlet来实现简化开发
       */
      
      public class LoginServlet2 extends MyGenericServlet {
      
          @Override
          public void service(ServletRequest servletRequest, ServletResponse servletResponse) {
              // 1. 获取请求参数：username和password
              String username = servletRequest.getParameter("username");
              String password = servletRequest.getParameter("password");
      
              // 2. 获取当前WEB应用的初始化参数：user，password
              // 需要使用ServletContext对象
              String initUser = getServletContext().getInitParameter("user");
              String initPassword = getServletContext().getInitParameter("password");
      
              // 3. 比对
              // 设置中文乱码问题
              servletResponse.setCharacterEncoding("utf-8");
              // 设置响应的内容类型
              servletResponse.setContentType("text/html;charset=utf-8");
      
              PrintWriter out = null;
              try {
                  out = servletResponse.getWriter();
              } catch (IOException e) {
                  e.printStackTrace();
              }
              if(initUser.equals(username) && initPassword.equals(password)){
                  // 4. 打印响应字符
                  out.println("Hello: " + username);
              }else{
                  out.println("Sorry: " + username + "，你甭想进来！");
              }
          }
      }
      ```

  - GenericServlet中有一个init()函数（**下面写的是视频的解释，个人查证后的在开头的学习体会中**）

    - 因为在子类LoginServlet2中存在一种需求：对当前的Servlet进行初始化，即覆盖init方法

      ```java
      @Override
      public void init(ServletConfig servletConfig) throws ServletException {
      	System.out.println("初始化");
      }
      ```

    - 运行后会报空指针异常，这是因为初始化的时候覆盖了父类初始化方法，这样ServletConfig就没有传参过去，因此就不能调用ServletConfig的各个函数。

    - 因此加入一个init()函数，里面不传参

      ```java
      @Override
      public void init(ServletConfig servletConfig) throws ServletException {
          this.servletConfig = servletConfig;
          init();
      }
      
      public void init() throws ServletException {
      }
      ```

    - 这时，再在LoginServlet2中初始化时，会使用init()函数，则不会再报错。

### 4.7 HttpServlet

- 若有个需求：获取请求方式是get还是post

  - 这样每次使用的时候都需要将request强转为HttpServletRequest

- 定义GenericServlet是为了集成ServletConfig中的方法，从而直接获得更多的内容，就不用new ServletConfig了

- 在GenericServlet的基础上HttpServlet继承了GenericServlet类，集成了HttpServletRequest和HttpServletResponse的各种方法，就不用强转了。

- HttpServlet是一个Servlet，继承自GenericServlet，针对HTTP协议所定制。

- 在service方法中直接把ServletRequest和ServletResponse转为HttpServletRequest和HttpServletResponse，并调用了重载的service(HttpServletRequest, HttpServletResponse)；在这个重载的service中获取了请求方式：request.getMethod()，根据请求方式又创建了doXxx()方法（Xxx为具体的请求方式，如doGet，doPost）

- **实际开发中，直接继承HttpServlet，并根据请求方式重写doXxx方法接口**。（主要指doGet，doPost）

- 好处：

  - 直接有针对性的覆盖doXxx方法
  - 直接使用HttpServletRequest和HttpServletResponse，不再需要强转。

- 手写HttpServlet的原理

  - MyHttpServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.ServletException;
    import javax.servlet.ServletRequest;
    import javax.servlet.ServletResponse;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: MyHttpServletRequest.java
     * @time: 2020/4/14 16:30
     * @desc: |针对http协议定义的Servlet基类
     */
    
    public class MyHttpServlet extends MyGenericServlet{
        @Override
        public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
            HttpServletRequest request;
            HttpServletResponse response;
            try {
                request = (HttpServletRequest)req;
                response = (HttpServletResponse)res;
            } catch (ClassCastException var6) {
                throw new ServletException("http.non_http");
            }
    
            this.service(request, response);
        }
    
        public void service(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
            // 1. 获取请求方式
            String method = servletRequest.getMethod();
    
            // 2. 根据请求方式再调用对应的处理方法
            if("GET".equalsIgnoreCase(method)){
                doGet(servletRequest, servletResponse);
            }
    
            if("POST".equalsIgnoreCase(method)){
                doPost(servletRequest, servletResponse);
            }
        }
    
        public void doPost(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
        }
    
        public void doGet(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
        }
    }
    ```

  - 继承MyHttpServlet来实现简化开发

    ```java
    package com.litian.test;
    
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    import java.io.PrintWriter;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LoginServlet.java
     * @time: 2020/4/13 14:17
     * @desc: |继承MyHttpServlet来实现简化开发
     */
    
    public class LoginServlet3 extends MyHttpServlet {
        @Override
        public void doPost(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
            // 获取的请求方式是GET还是POST
            String method = servletRequest.getMethod();
            System.out.println(method);
    
            // 1. 获取请求参数：username和password
            String username = servletRequest.getParameter("username");
            String password = servletRequest.getParameter("password");
    
            // 2. 获取当前WEB应用的初始化参数：user，password
            // 需要使用ServletContext对象
            String initUser = getServletContext().getInitParameter("user");
            String initPassword = getServletContext().getInitParameter("password");
    
            // 3. 比对
            // 设置中文乱码问题
            servletResponse.setCharacterEncoding("utf-8");
            // 设置响应的内容类型
            servletResponse.setContentType("text/html;charset=utf-8");
    
            PrintWriter out = null;
            try {
                out = servletResponse.getWriter();
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (initUser.equals(username) && initPassword.equals(password)) {
                // 4. 打印响应字符
                out.println("Hello: " + username);
            } else {
                out.println("Sorry: " + username + "，你甭想进来！");
            }
        }
    }
    ```

- 利用HttpServ实现上述小题目

> 小题目：
> 在MySQL数据库中穿件一个test_users.users数据表，添加3个字段：id，user，password，并录入几条记录。
> 定义一个login.html，里边定义两个请求字段：user，password，发送请求到loginServlet；再创建一个LoginServlet4（使用HttpServlet），在其中获取请求的user，password。
> 利用JDBC从test_users.users中查询有没有和页面输入的user，password对应的记录。
> select count(id) from users where user=? and password=?
> 若有，响应Hello：xxx；若没有，响应Sorry：xxx；xxx为user。

- 代码

  ```java
  package com.litian.test;
  
  import javax.servlet.ServletException;
  import javax.servlet.http.HttpServlet;
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  import java.io.IOException;
  import java.io.PrintWriter;
  import java.sql.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: LoginServlet.java
   * @time: 2020/4/13 14:17
   * @desc: |
   */
  
  public class LoginServlet4 extends HttpServlet {
      @Override
      protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          String username = req.getParameter("username");
          String password = req.getParameter("password");
  
          // 设置中文乱码问题
          resp.setCharacterEncoding("utf-8");
          // 设置响应的内容类型
          resp.setContentType("text/html;charset=utf-8");
  
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
  
          PrintWriter out = resp.getWriter();
  
          try {
              Class.forName("com.mysql.cj.jdbc.Driver");
              String url = "jdbc:mysql://localhost:3306/test_users?serverTimezone=GMT%2B8";
              String ur = "root";
              String psd = "123456";
              conn = DriverManager.getConnection(url, ur, psd);
              String sql = "select count(id) from users where user=? and password=?";
              ps = conn.prepareStatement(sql);
              ps.setString(1, username);
              ps.setString(2, password);
  
              rs = ps.executeQuery();
              if (rs.next()) {
                  int count = rs.getInt(1);
                  if (count > 0) {
                      out.println("登陆成功：" + username);
                  } else {
                      out.println("登陆失败：" + username + "，自己赶紧滚！");
                  }
              }
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
              try {
                  if (rs != null) {
                      rs.close();
                  }
              } catch (SQLException e) {
                  e.printStackTrace();
              }
              try {
                  if (ps != null) {
                      ps.close();
                  }
              } catch (SQLException e) {
                  e.printStackTrace();
              }
              try {
                  if (conn != null) {
                      conn.close();
                  }
              } catch (SQLException e) {
                  e.printStackTrace();
              }
          }
      }
  }
  ```

- idea报错：java.lang.ClassNotFoundException: com.mysql.cj.jdbc.Driver解决方案：

  这是因为没有导入mysql的包，注意：只需要把包复制到对应的lib目录，这点很重要，一定要复制，并且不用配置工程中lib的路径，只需要复制，就行（不复制，怎么配置路径都没用，我试了）

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200414182805564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 运行结果

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020041418341943.png)

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200414183442404.png)

## 5. JSP

### 5.1 JSP概述

- Why?：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200415122337507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- helloword：

  - 新建一个JSP页面，在body节点内的`<%%>`中即可编写java代码

- 建立对JSP的直观认识

  - JSP页面是由HTML语句和嵌套在其中的Java代码组成的一个普通文本文件，JSP页面的文件扩展名必须为.jsp。
  - 在JSP页面中编写的Java代码需要嵌套在`<%`和`%>`中，嵌套在`<%`和`%>`之间的Java代码被称之为**脚本片段**（Scriptlets），没有嵌套在`<%`和`%>`之间的内容被称为JSP的模板元素。
  - JSP中的Java代码可以使用out.println语句将其他Java程序代码缠身的结果字符串输出给客户端，也可以使用System.out.println语句将它们打印到命令行窗口。
  - JSP文件就像普通的HTML文件一样，它们可以**放置在WEB应用程序中的除了WEB-INF及其子目录外的其他任何目录中，JSP页面的访问路径与普通HTML页面的访问路径形式也是完全一样。**
  - 在JSP页面中也可以使用一种称之为**JSP表达式**的元素，只需要将输出的变量或表达式直接封装在`<%=`和`%>`之中，就可以向客户端输出这个变量或表达式的运算结果。**在JSP表达式中嵌套的变量或表达式后面不能有分号。**

- JSP的运行原理：**JSP本质是一个Servlet**

  - WEB容器（Servlet引擎）接收到以.jsp为扩展名的URL的访问请求时，它将把该访问请求交给**JSP引擎**去处理。
  - 每个JSP页面在第一次被访问时，JSP引擎将它翻译成一个Servlet源程序，接着再把这个Servlet源程序编译成Servlet的class类文件，然后再由**WEB容器（Servlet引擎）**像调用普通Servlet程序一样的方式来装载和解释这个由JSP页面翻译成的Servlet程序。
  - JSP规范也没有明确要求JSP中的脚本程序代码必须采用Java语言，JSP中的脚本程序代码可以采用Java语言之外的其他脚本语言来编写，但是，JSP页面最终必须转换成Java Servlet程序。
  - 可以在WEB应用程序正是发布之前，将其中的所有JSP页面预先编译成Servlet程序。

### 5.2 JSp页面的9个隐含对象

- JSP页面的9个隐含变量：没有声明就可以使用的对象

  1. **out**： JspWriter对象，调用out.println()直接把字符串打印到浏览器上

  2. **request**：HttpServletRequest对象

  3. **response**：HttpServletResponse对象(在jsp页面几乎用不到)

  4. **pageContext**：页面上下文，是pageContext的一个对象，可以从该对象中获取其他对象信息（可以从该对象获取到其他8个隐含对象，也可以从中获取到当前页面的其他信息，学习自定义标签时使用）

  5. **session**：来源于javax.servlet.http.HttpSession。代表浏览器和服务器的一次会话，它用于存储客户端请求的信息，因此它是有状态交互式的。

  6. **application**：代表当前web应用，来源于javax.servlet.servletcontext

  7. **config**：来源于ServletConfig，它包含了当前JSP/Servlet所在的WEB应用的配置信息，若需要访问当前jsp配置的初始化参数，需要通过映射才可以（开发的时候几乎不用）

      ```xml
      <servlet>
          <servlet-name>hellojsp</servlet-name>
          <jsp-file>/hello.jsp</jsp-file>
          <init-param>
              <param-name>test</param-name>
            <param-value>testValue</param-value>
          </init-param>
      </servlet>
      <servlet-mapping>
          <servlet-name>hellojsp</servlet-name>
          <url-pattern>/hellojsp</url-pattern>
      </servlet-mapping>
      ```
  
  8. **page**：指向当前jsp对应的Servlet对象的引用，但为Object类型，只能调用Object类方法（几乎不使用）
  
  9. **exception**：用于捕获JSP抛出的异常。它只有在JSP页面属性isErrorPage=true时才可用。
  
      ```jsp
      <%@ page contentType="text/html;charset=UTF-8" language="java" %>
      <%@ page isErrorPage="true" %>
      <html>
      <head>
          <title>Title</title>
      </head>
      <body>
      <%
          exception.printStackTrace();
      %>
      </body>
      </html>
      ```
  
- **常用的对象（对属性作用于的范围从小到大）：pageContext，request，session，application**

- 其他对象：out，response，config，page，exception

### 5.3 JSP语法

- JSP模板元素
  - JSP页面中的静态HTML内容称之为JSP模板元素，在静态的HTML内容之中可以嵌套JSP的其他各种元素来产生动态内容和执行业务逻辑。
  - JSP模板元素定义了网页的基本骨架，即定义了页面的结构和外观。
  
- 相关编码问题：[参考链接](https://blog.csdn.net/fengqing5578/article/details/80648753)

- JSP表达式
  - JSP表达式（expression）提供了将一个java变量或表达式的计算结果输出到客户端的简化方式，它将要输出的变量或表达式直接封装在`<%=`和`%>`之中。（如：Current time: <%= new java.util.Date() %>）
  
  - JSP表达式中的变量或表达式的计算结果将被转换成一个字符串，然后被插入进整个JSP页面输出结果的相应位置处。
  
  - JSP表达式中的变量或表达式后面不能有分号（;），JSP表达式被翻译成Servlet程序中的一条out.print()语句。
  
    ```jsp
    <%@ page import="java.util.Date" %><%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/4/17
      Time: 9:34
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
    <head>
        <title>Title</title>
    </head>
    <body>
    <%
        Date date = new Date(System.currentTimeMillis());
        out.println(date);
    %>
    <br>
    <%= date %>
    </body>
    </html>
    ```
  
- JSP脚本片段

  - JSP脚本片段（scriptlet）是指嵌套在`<%`和`%>`之间的一条或多条Java程序代码。

  - 在JSP脚本片段中，可以定义变量、执行基本的程序运算、调用其他Java类、访问数据库、访问文件系统等普通Java程序所能实现的功能。

  - 在JSP脚本片段可以直接使用JSP提供的隐式对象来完成WEB应用程序特有的功能。

  - JSP脚本片段中的Java代码**将被原封不动地搬移进由JSP页面所翻译成的Servlet的jspService方法中**，所以，JSP脚本片段之中只能是符合Java语法要求的程序代码，除此之外的任何文本、HTML标记、其他JSP元素都必须在脚本片段之外编写。

  - JSP脚本片段中的Java代码必须严格遵循Java语法，例如，每条命令执行语句后面必须用分号（;）结束。

  - 在一个JSP页面中可以由多个脚本片段（每个脚本片段代码嵌套在各自独立的一对`<%`和`%>`之间），在两个或多个脚本片段之间可以嵌入文本、HTML标记和其他JSP元素。

    ```jsp
    <%@ page import="java.util.Date" %><%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/4/17
      Time: 9:34
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" language="java" pageEncoding="UTF-8" %>
    <html>
    <head>
        <title>Title</title>
    </head>
    <body>
    <%
        Date date = new Date(System.currentTimeMillis());
        out.println(date);
    %>
    <br>
    <%= date %>
    <%
        String ageStr = request.getParameter("age");
        Integer age = Integer.parseInt(ageStr);
        if (age >= 18) {
    %>
    成人...
    <%
        } else {
            out.print("未成年人！");
        }
    %>
    </body>
    </html>
    ```

- JSP声明

  - JSP声明将Java代码封装在`<%!`和`%>`之中，它里面的代码**将被插入进Servlet的jspService方法的外面**，所以，JSP声明可用于定义JSP页面转换成的Servlet程序的静态代码块、成员变量和方法。（在JSP页面中几乎不用）

  - 多个静态代码块、变量和函数可以定义在一个JSP声明中，也可以分别单独定义在多个JSP声明中。

  - **JSP隐式对象的作用范围仅限于Servlet的jspService方法，所以在JSP声明中不能使用这些隐式对象。**

    ```jsp
    <%!
        void test(){}
    %>
    ```

- JSP注释

  - JSP注释的格式：`<%-- 注释信息 --%>`；HTML注释：`<!-- HTML注释 -->`
  - 区别：JSP注释可以阻止Java代码的执行

### 5.4 域对象的属性操作

- 和属性相关的方法：
    - Object getAttribute(String name)：获取指定的属性
    - Enumeration getAttributeNames()：获取所有属性的名字组成的Enumeration对象
    - removeAttribute(String name)：移除指定的属性。
    - void setAttribute(String name, Object o)：设置属性
- pageContext，request，session，application对象都有这些方法，这四个方法也称之为域对象。
- pageContext：属性的作用范围仅限于当前JSP页面
- request：属性的作用范围仅限于同一个请求（**在有转发的情况下可以跨页面获取属性值**）
- session：属性的作用范围仅限于一次会话（浏览器打开直到关闭称之为一次会话（在此期间会话不失效））
- application：getServletConfig()，属性的作用范围仅限于当前WEB应用，是范围最大的属性作用范围，只要在一处设置属性，在其他各处的JSP或Servlet中都可以获取。
- 测试代码就不写了，主要是为了了解四个对象的作用域的区别。

### 5.5 请求的转发和重定向

- 本质区别：**请求的转发只发出了一次请求；而重定向则发出了两次请求**

- 具体特点：

  1. 转发：地址栏是初次发出请求的地址。

     重定向：地址栏不再是初次发出的请求地址，地址栏为最后响应的地址。

  2. 转发：在最终的Servlet中，request对象和中转的那个request是同一个对象。

     重定向：request不是同一个对象。

  3. 转发：只能转发给当前WEB应用的资源（内部资源）。

     重定向：可以重定向到任何资源。

  4. 转发：/ 代表的是当前WEB应用的根目录。

     重定向：/ 代表的是当前WEB站点的根目录。

- 根目录：

  - 当前WEB应用的根目录：`http://localhost:8080/app3`
  - 站点的根目录：`http://localhost:8080`

- 测试结果

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200417144910573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  > 问题：如果控制台输出中文乱码
  >
  > 解决办法：设置Tomcat 的配置中VM option加上：`-Dfile.encoding=GBK`
  >
  > [参考连接](https://blog.csdn.net/rznice/article/details/41006913)，有时候UTF-8没用还是乱码，我测试后发现GBK有效

- RequestDispatcher接口

  - RequestDispatcher实例对象是由Servlet引擎创建的，它用于包装一个要被其他资源调用的资源（例如，Servlet、HTML文件、JSP文件等），并可以通过其中的方法将客户端的请求转发给所包装的资源。

  - RequestDispatcher接口中定义了两个方法：forward方法和include方法

  - forward方法和include方法接受的两个参数必须是传递给当前Servlet的service方法的那两个ServletRequest和ServletResponse对象，或者是对它们进行了包装的ServletRequestWrapper或ServletResponseWrapper对象。

  - 获取RequestDispatcher对象的方法：

    - ServletContext.getRequestDispatcher(**参数只能是以"/"开头的路径**)
    - ServletContext.getNamedDispatcher
    - ServletRequest.getRequestDispatcher(**参数可以是不以"/"开头的路径**)

  - 在实际操作的过程中可以不配置web.xml，而是通过类前加入注释的方式，达到配置的效果[参考连接](https://www.zhihu.com/question/45118798)

    ```java
    @WebServlet(name = "TestServlet", urlPatterns = "/testServlet")
    ```
    
  - 在配置的时候一定要注意加`/`，不然就会报错：`java.lang.IllegalStateException: Error starting child`

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421194824520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 转发和重定向测试代码

  - 转发Servlet（这里采用的是配置web.xml文件）

    ```java
    package com.litian.test;
    
    import javax.servlet.RequestDispatcher;
    import javax.servlet.ServletException;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ${NAME}.java
     * @time: 2020/4/17 14:18
     * @desc: |
     */
    
    public class ForwardServlet extends HttpServlet {
        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    
        }
    
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            System.out.println("ForwardServlet's doGet! ↓");
    
            request.setAttribute("name", "ForwardServlet");
            System.out.println(request.getAttribute("name"));
    
            // 请求的转发
            // 1. 调用HttServletRequest的getRequestDispatcher()方法获取RequestDispatcher对象
            // 调用getRequestDispatcher()需要传入要转发的地址
            String path = "testServlet";
            RequestDispatcher rd = request.getRequestDispatcher("/" + path);
    
            // 2. 调用HttpServletRequest的forward(request, response)方法进行请求的转发
            rd.forward(request, response);
        }
    }
    ```

  - 重定向Servlet（这里采用的是配置注释文件）

    ```java
    package com.litian.test;
    
    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ${NAME}.java
     * @time: 2020/4/17 14:31
     * @desc: |
     */
    
    @WebServlet(name = "RedirectServlet", urlPatterns = "/redirectServlet")
    public class RedirectServlet extends HttpServlet {
        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    
        }
    
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            System.out.println("RedirectServlet's doGet method! ↓");
    
            request.setAttribute("name", "RedirectServlet");
            System.out.println(request.getAttribute("name"));
    
            // 执行请求的重定向，直接调用response的sendRedirect方法
            // 其中path为要重定向的地址
            String location = "testServlet";
            response.sendRedirect(location);
        }
    }
    ```

  - 目标页面

    ```java
    package com.litian.test;
    
    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ${NAME}.java
     * @time: 2020/4/17 14:26
     * @desc: |
     */
    
    @WebServlet(name = "TestServlet", urlPatterns = "/testServlet")
    public class TestServlet extends HttpServlet {
        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    
        }
    
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            System.out.println("testServlet's doGet method! ↓");
            System.out.println(request.getAttribute("name"));
        }
    }
    ```

  - abc的测试用例我写了，就不粘了，都是为了说明，转发和重定向的区别的，转发是在b网页显示c的内容，重定向是在c网页显示c的内容。（代码传到github上面了）

### 5.6 JSP指令

- JSP指令（directive）是为JSP引擎而设计的，它们并不直接产生任何可见输出，而只是**告诉引擎如何处理JSP页面中的其余部分**。

- JSP指令的基本语法格式：`<%@ 指令 属性名="值" %>`

  举例：`<%@ page contentType="text/html;charset=gb2312" %>`

  注意：属性名部分是大小写敏感的

- 在目前的JSP2.0中，定义了**page、include和taglib**这三种指令，每种指令中又定义了一些各自的属性。

- 如果要在一个JSP页面中设置同一个条指令的多个属性，可以使用多条指令语句单独设置每个属性，也可以使用同一条指令语句设置该指令的多个属性。

  第一种：

  ```jsp
  <%@ page contentType="text/html;charset=gb2312" %>
  <%@ page import="java.util.Date" %>
  ```

  第二种：

  ```jsp
  <%@ page contentType="text/html;charset=gb2312" import="java.util.Date" pageEncoding="utf-8" %>
  ```

- **Page指令**

  - page指令用于定义JSP页面的各种属性，无论page指令出现在JSP页面中的什么地方，它作用的都是整个JSP页面，为了保持程序的可读性和遵循良好的编程习惯，**page指令最好是放在整个JSP页面的起始位置**。

  - JSP2.0规范中定义的page指令的完整语法：

    ```jsp
    <%@ page
        [language="java"]
        [extends="package.class"]
        [import="{package.class | package.*}, ..."]
        [session="true | false"]
        [buffer="none | 8kb | sizekb"]
        [autoFlush="true | false"]
        [isThreadSafe="true | false"]
        [info="text"]
        [errorPage="relative_url"]	# 错误页面的地址（该页面有错之后转到的页面），转发机制
        [isErrorPage="true | false"]	# 该页面是否是错误页面，设置之后就可以用exception了，测试中就可以输出 <% exception.getMessage() %> 来输出错误信息
        [contentType="mimeType [;charset=characterSet]" | "text/html; charset=ISO-8859-1"]
        [pageEncoding="characterSet | ISO-8859-1"]
        [isELIgnored="true | false"]
    %>
    ```

  - page指令常用的属性：
  
    - import：指定当前JSP页面对应的Servlet需要导入的类。
  
    - session：取值为true或false，指定当前页面的session隐藏变量是否可用，也可以说访问当前页面时是否一定要生成HttpSession对象。
  
    - errorPage和isErrorPage：
  
      - errorPage指定若当前页面出现错误的实际响应页面是什么，其中/表示的是当前WEB应用的根目录，`<%@ page errorPage="/error.jsp" %>`
  
      - 在响应error.jsp时，在JSP引擎使用的是请求转发的方式。
  
      - isErrorPage指定当前页面是否为错误处理页面，可以说明当前页面是否可以使用exception隐藏变量，需要注意的是：若指定isErrorPage="true"，并使用exception的方法，一般不建议能够直接访问该页面。（也就是用转发而不是重定向）
  
      - 如何使客户不能直接访问某一个页面呢？对于tomcat服务器而言，WEB-INF下的文件时不能通过在浏览器中直接输入地址的方式来访问的。
  
      - 还可以在web.xml文件中配置错误页面
  
        ```xml
        <error-page>
            <!-- 指定出错的代码：404没有指定的资源，500内部错误 -->
            <error-code>404</error-code>
            <!-- 指定响应页面的位置 -->
            <location>/hello.jsp</location>
        </error-page>
        
        <error-page>
            <!-- 指定异常的类型 -->
            <exception-type>java.lang.ArithmeticException</exception-type>
            <location>/WEB-INF/error.jsp</location>
        </error-page>
        ```
  
    - contentType：指定当前JSP页面的响应类型，实际调用的是`response.setContentType("text/html; charset=UTF-8");`通常情况下，对于JSP页面而言，其取值均为`response.setContentType("text/html; charset=UTF-8");`
  
      - charset：指定返回的页面的字符编码是什么，通常取值为UTF-8
  
    - pageEncoding：指定当前JSP页面的字符编码，通常情况下该值和contentType中的charset一致。
  
    - isELIgnored：指定当前JSP页面是否可以使用EL表达式，通常取值为false，表示不忽略。
  
- **include指令**

  - inlude指令用于通知JSP引擎**在翻译当前JSP页面时**将其他文件的内容合并进当前JSP页面转换成的Servlet源文件中，这种在源文件级别进行引入的方式称之为静态引入，**当前JSP页面与静态引入的页面紧密结合为一个Servlet**。
  
  - 语法：`<%@ include file="relativeURL" %>`，其中的file属性用于指定被引入文件的**相对路径**。**推荐使用`/`的方式来包含页面**，使用绝对路径肯定没问题，使用相对路径可能会有问题！
  
  - 细节1：
    - 被引入的而文件必须遵循JSP语法，其中的内容可以包含静态HTML、JSP脚本元素、JSP指令和JSP行为元素等普通JSP页面所具有的一切内容。
    - 被引入的文件可以使用任意的扩展名，即使其扩展名是html，JSP引擎也会按照处理jsp页面的方式处理它里面的内容，为了见名知意，JSP规范建议使用.jspf（JSP fragments）最为静态引入文件的扩展名。
    - 在将JSP文件翻译成Servlet源文件时，JSP引擎将合并被引入的文件与当前JSP页面中的指令元素（**设置pageEncoding指令除外**），所以，**除了import和pageEncoding属性之外，page指令的其他属性不能在这两个页面中有不同的设置值。**
    
  - 细节2：
  
    - 除了指令元素之外，被引入的文件中的其他元素都被转换成相应的Java源代码，然后插入进当前的JSP页面所翻译成的Servlet源文件中，插入位置与include指令在当前JSP页面中的位置保持一致。
    - **引入文件与被引入文件时在被JSP引擎翻译成Servlet的过程中进行合并，而不是先合并源文件后再对合并的结果进行翻译。**当前JSP页面的源文件与被引入文件的源文件可以采用不同的字符集编码，即使在一个页面中使用page指令的pageEncoding或contentType属性指定了其源文件的字符集编码，在另外一个页面中还需要用page指令的pageEncoding或contentType属性指定其源文件所使用的的字符集。
    - Tomcat5.x在访问JSP页面时，可以检测它所引入的其他文件是否发生了修改，如果发生了修改，则重新编译当前JSP页面。
    - **file属性的设置值必须使用相对路径**，如果以`/`开头，表示相对于当前WEB应用程序的根目录（注意不是站点根目录），否则，表示相对于当前文件。
  
  - 代码：在a.jsp文件中通过include指令插入b.jsp
  
    - a.jsp
  
      ```jsp
      <%--
        Created by IntelliJ IDEA.
        User: Administrator
        Date: 2020/4/19
        Time: 13:16
        To change this template use File | Settings | File Templates.
      --%>
      <%@ page contentType="text/html;charset=UTF-8" language="java" %>
      <html>
      <head>
          <title>a</title>
      </head>
      <body>
      <h3>aaa page</h3>
      <% String ss = "what!";%>
      <%-- 在a.jsp 中包含b.jsp --%>
      <%@ include file="b.jsp" %>
      </body>
      </html>
      ```
  
    - b.jsp
  
      ```jsp
      <%--
        Created by IntelliJ IDEA.
        User: Administrator
        Date: 2020/4/19
        Time: 13:16
        To change this template use File | Settings | File Templates.
      --%>
      <%@ page contentType="text/html;charset=UTF-8" language="java" %>
      <html>
      <head>
          <title>b</title>
      </head>
      <body>
      <h3>bbb page</h3>
      <%= ss %>
      </body>
      </html>
      ```
  
    - 运行结果
  
      ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020041923014836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
  

### 5.7 JSP标签

- 概念

  - JSP还提供了一种称之为Action的元素，在JSP页面中使用Action元素**可以完成各种通用的JSP页面功能**，也可以实现一些处理复杂业务逻辑的专用功能。
  - Action元素采用XML元素的语法格式，即每个Action元素在JSP页面中都已XML标签的形式出现。
  - JSP规范中定义了一些标准的Action元素，这些元素的**标签名都以jsp作为前缀，并且全部采用小写**，例如：`<jsp:include>、<jsp:forward>`等等。

- `<jsp:include>`标签

  - 用于把另外一个资源的输出内容插入进当前JSP页面的输出内容中，这种在**JSP页面执行的引入方式称之为动态引入**。
  - 语法：`<jsp:include page="relativeURL | <%= expression %>" flush="true|false" />`
  - 实用：`<jsp:include page="b.jsp"></jsp:include>`
  - page属性用于指定被引入资源的**相对路径**，它也可以通过执行一个表达式来获得。
  - flush属性指定在插入其他资源的输出内容时，是否先将当前JSP页面的已输出内容刷新到客户端。
  - **区别简述**：并不是像include指令一样生成一个Servlet源文件，而是生成两个Servlet源文件，然后通过一个方法的方式把目标页面包含进来。

- `<jsp:include>`标签与include指令的比较（理解，记住上面简单区别就行）

  - `<jsp:include>`标签是在当前JSP页面的**执行期间**插入被引入资源的输出内容，当前JSP页面与被动态引入的资源时两个彼此独立的执行实体，**被动态引入的资源必须是一个能独立被WEB容器调用和执行的资源**。include指令只能引入遵循JSP格式的文件，被引入文件与当前JSP文件共同合并被翻译成一个Servlet的源文件。
  - 使用`<jsp:include>`标签和include指令都可以把一个页面的内容分成多个组件来生成，开发者不必再把页眉和页脚部分的相同HTML代码复制到每个JSP文件中，从而可以更轻松地完成维护工作，但是**都应注意最终的输出结果内容应遵循HTML语法结构**，例如：如果当前页面产生了`<html>、</html>、<body>、</body>`等标记，那么在被引入文件中就不能再输出`<html>、</html>、<body>、</body>`等标记。
  - **`<jsp:include>`标签对JSP引擎翻译JSP页面的过程不起作用**，它是在JSP页面的执行期间才被调用，因此不会影响两个页面的编译。由于**include指令是在JSP引擎翻译JSP页面的过程中被解释处理的，所以它对JSP引擎翻译JSP页面的过程起作用**，如果多个JSP页面中都要用到一些相同的声明，那么就可以把这些声明语句放在一个单独的文件中编写，然后在每个JSP页面中使用include指令将那个文件包含进来。

- `<jsp:forward>`标签

  - `<jsp:forward page="/include/b.jsp"></jsp:forward>`

  - 相当于

    ```jsp
    <%
        request.getRequestDispatcher("/include/b.jsp").forward(request, response);
    %>
    ```

  - 但使用jsp:forward可以使用jsp:param子标签向b.jsp传入一些参数。同样jsp:include也可以使用jsp:param子标签。**即在目标jsp页面，可以通过`request.getParameter("参数名")`获取到传入的请求参数**

    ```jsp
    a.jsp
    <jsp:forward page="/include2/b.jsp">
        <jsp:param name="username" value="abcd"/>
    </jsp:forward>
    
    b.jsp
    <%= request.getParameter("username") %>
    ```

### 5.8 JSP中文乱码问题

1. 在JSP页面上输入中文，请求页面后不出现乱码：保证 `contentType="text/html;charset=UTF-8" pageEncoding="UTF-8"`。即charset和pageEncoding的编码一致，且都支持中文。通常建议取值为UTF-8。同时还需要保证浏览器的显示的字符编码也和请求的JSP页面的编码一致。

2. 获取中文参数值：默认参数在传输过程中使用的编码为ISO-8859-1

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200420162336515.png)

   - 对于POST请求：设置请求的编码为UTF-8：`request.setCharacterEncoding("UTF-8");`（在获取请求参数之前使用）

   - 对个GET请求：前面的方式对GET无效，先解码再编码（这里我get请求中文是正常的）；或者通过修改Tomcat的server.xml文件的方式：为connector节点添加userBodyEncodingForURI属性，并设置为true。

     ```jsp
     <%
         String val = request.getParameter("username");
         String username = new String(val.getBytes("iso-8859-1"), "UTF-8");
         out.print(username);
     %>
     ```

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200420162439955.png)

## 6. MVC设计模式

- JavaEE开发中常见的组件：beanutils、dbcp、dbutils、fileipload、logging、hibernate、jbpm

- JavaEE开发流程（Servlet）：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421174047179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- JavaEE开发流程（JSP）：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020042117423629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- MVC处理过程，图中转向是转发或重定向：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421174335538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- MVC是Model-View-Controller的简称，即模型-视图-控制器。

- MVC是一种设计模式，它把应用程序分成三个核心模块：模型、视图、控制器，它们各自处理自己的任务。

  - 模型：
    - 模型是应用程序的主体部分，模型表示业务数据和业务逻辑。
    - 一个模型能为多个视图提供数据。
    - 由于应用于模型的代码只需写一次就可以被多个视图重用，所以提高了代码的**可重用性**。
  - 视图：
    - 视图是用户看到并与之交互的界面，作用如下：
      - 视图向用户显示相关的数据
      - 接受用户的输入
      - 不进行任何实际的业务处理
  - 控制器：
    - 控制器接受用户的输入并调用模型和视图去完成用户的需求
    - 控制器接受请求并决定调用哪个模型组件去处理请求，然后决定调用哪个视图来显示模型处理返回的数据

### 6.1 MVC案例1：查询

- 技术路线

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421180618350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 代码：在test.jsp点击链接查看学生信息的表格

  - test.jsp，点击后转到`/listAllStudents`链接

    ```jsp
    <%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/4/21
      Time: 19:20
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
    <head>
        <title>Test</title>
    </head>
    <body>
    <a href="listAllStudents">List All Students</a>
    </body>
    </html>
    ```

  - 学生类

    ```java
    package com.litian.mvc;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Student.java
     * @time: 2020/4/21 19:57
     * @desc: |
     */
    
    public class Student {
        private Integer id;
        private String user;
        private String password;
    
        public Student() {
        }
    
        public Student(Integer id, String user, String password) {
            this.id = id;
            this.user = user;
            this.password = password;
        }
    
        public Integer getId() {
            return id;
        }
    
        public void setId(Integer id) {
            this.id = id;
        }
    
        public String getUser() {
            return user;
        }
    
        public void setUser(String user) {
            this.user = user;
        }
    
        public String getPassword() {
            return password;
        }
    
        public void setPassword(String password) {
            this.password = password;
        }
    }
    ```

  - 操作数据库获取信息的方法

    ```java
    package com.litian.mvc;
    
    import java.sql.Connection;
    import java.sql.DriverManager;
    import java.sql.PreparedStatement;
    import java.sql.ResultSet;
    import java.util.ArrayList;
    import java.util.List;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: StudentDao.java
     * @time: 2020/4/21 20:00
     * @desc: |
     */
    
    public class StudentDao {
        public List<Student> getAll(){
    
            List<Student> students = new ArrayList<>();
    
            Connection conn = null;
            PreparedStatement ps = null;
            ResultSet rs = null;
    
            try {
                String driverClass = "com.mysql.cj.jdbc.Driver";
                String url = "jdbc:mysql://localhost:3306/test_users?serverTimezone=GMT%2B8";
                String user = "root";
                String password = "123456";
                Class.forName(driverClass);
                conn = DriverManager.getConnection(url, user, password);
    
                String sql = "select id, user, password from users";
    
                ps = conn.prepareStatement(sql);
                rs = ps.executeQuery();
    
                while(rs.next()){
                    int id = rs.getInt(1);
                    String username = rs.getString(2);
                    String psd = rs.getString(3);
    
                    Student st = new Student(id, username, psd);
                    students.add(st);
                }
    
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                try{
                    if(rs != null){
                        rs.close();
                    }
                }catch (Exception e){
                    e.printStackTrace();
                }
                try{
                    if(ps != null){
                        ps.close();
                    }
                }catch (Exception e){
                    e.printStackTrace();
                }
                try{
                    if(conn != null){
                        conn.close();
                    }
                }catch (Exception e){
                    e.printStackTrace();
                }
            }
            return students;
        }
    }
    ```

  - `/listAllStudents`链接的Servlet，目的是转发请求到页面`/students.jsp`，请求中包含students的信息

    ```java
    package com.litian.mvc;
    
    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    import java.util.Arrays;
    import java.util.List;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ${NAME}.java
     * @time: 2020/4/21 19:21
     * @desc: |
     */
    
    @WebServlet(name = "ListAllStudentsServlet", urlPatterns = "/listAllStudents")
    public class ListAllStudentsServlet extends HttpServlet {
        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    
        }
    
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // request.setAttribute("lists", Arrays.asList("AA", "BB", "CC"));
            // request.getRequestDispatcher("/students.jsp").forward(request, response);
    
            StudentDao sd = new StudentDao();
            List<Student> students = sd.getAll();
    
            request.setAttribute("students", students);
            request.getRequestDispatcher("/students.jsp").forward(request, response);
        }
    }
    ```

  - `/students.jsp`页面，获取请求中的参数，显示信息，由于是转发而不是重定向，所以最终显示的地址是`http://localhost:8080/MVCApp/listAllStudents`而不是`/students.jsp`

    ```jsp
    <%@ page import="com.litian.mvc.Student" %>
    <%@ page import="java.util.List" %><%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/4/21
      Time: 19:23
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
    <head>
        <title>Students</title>
    </head>
    <body>
    <%--
    <%=
    request.getAttribute("lists")
    %>
    <br><br>
    <%
        List<String> names = (List) request.getAttribute("lists");
        for (String name : names) {
            out.print(name + "<br>");
        }
    %>
    --%>
    
    <%
        List<Student> stus = (List<Student>) request.getAttribute("students");
    %>
    
    <table>
        <tr>
            <th>id</th>
            <th>user</th>
            <th>password</th>
        </tr>
        <%
            for (Student st : stus) {
        %>
        <tr>
            <td><%= st.getId() %></td>
            <td><%= st.getUser() %></td>
            <td><%= st.getPassword() %></td>
        </tr>
    
        <%
            }
        %>
    </table>
    </body>
    </html>
    ```

  - 部署成功

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421203705862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 6.2 MVC案例2：删除

- 关于MVC

  - Model：Dao
  - View：JSP，在页面上填写java代码实现显示
  - Controller：Servlet，受理请求，获取请求参数，调用DAO方法，可能会把DAO方法的返回值放回request中，转发或重定向页面。

- 什么时候转发？什么时候重定向？

  - 若目标的响应页面不需要从request中读取任何值，则可以使用重定向。（还可以防止表单的重复提交）

- 不足：

  - 使用数据库连接池，DBUtils，使用JDBCUtils工具类，DAO基类
  - 一个请求一个Servlet不好！一个模块使用一个Servlet，即多个请求可以使用一个Servlet
  - 在页面上加入jQuery提示

- 代码：

  - StudentDao新增根据id删除方法

    ```java
    package com.litian.mvc;
    
    import java.sql.Connection;
    import java.sql.DriverManager;
    import java.sql.PreparedStatement;
    import java.sql.ResultSet;
    import java.util.ArrayList;
    import java.util.List;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: StudentDao.java
     * @time: 2020/4/21 20:00
     * @desc: |
     */
    
    public class StudentDao {
    
        public void deleteById(Integer id) {
    
            Connection conn = null;
            PreparedStatement ps = null;
    
            try {
                String driverClass = "com.mysql.cj.jdbc.Driver";
                String url = "jdbc:mysql://localhost:3306/test_users?serverTimezone=GMT%2B8";
                String user = "root";
                String password = "123456";
                Class.forName(driverClass);
                conn = DriverManager.getConnection(url, user, password);
    
                String sql = "delete from users where id = ?";
                ps = conn.prepareStatement(sql);
    
                ps.setInt(1, id);
                ps.executeUpdate();
    
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                try {
                    if (ps != null) {
                        ps.close();
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                try {
                    if (conn != null) {
                        conn.close();
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    
        public List<Student> getAll() {
    
            List<Student> students = new ArrayList<>();
    
            Connection conn = null;
            PreparedStatement ps = null;
            ResultSet rs = null;
    
            try {
                String driverClass = "com.mysql.cj.jdbc.Driver";
                String url = "jdbc:mysql://localhost:3306/test_users?serverTimezone=GMT%2B8";
                String user = "root";
                String password = "123456";
                Class.forName(driverClass);
                conn = DriverManager.getConnection(url, user, password);
    
                String sql = "select id, user, password from users";
    
                ps = conn.prepareStatement(sql);
                rs = ps.executeQuery();
    
                while (rs.next()) {
                    int id = rs.getInt(1);
                    String username = rs.getString(2);
                    String psd = rs.getString(3);
    
                    Student st = new Student(id, username, psd);
                    students.add(st);
                }
    
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                try {
                    if (rs != null) {
                        rs.close();
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                try {
                    if (ps != null) {
                        ps.close();
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                try {
                    if (conn != null) {
                        conn.close();
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            return students;
        }
    }
    ```

  - 学生信息显示页面jsp增加删除超链接

    ```jsp
    <%@ page import="com.litian.mvc.Student" %>
    <%@ page import="java.util.List" %><%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/4/21
      Time: 19:23
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
    <head>
        <title>Students</title>
    </head>
    <body>
    <%--
    <%=
    request.getAttribute("lists")
    %>
    <br><br>
    <%
        List<String> names = (List) request.getAttribute("lists");
        for (String name : names) {
            out.print(name + "<br>");
        }
    %>
    --%>
    
    <%
        List<Student> stus = (List<Student>) request.getAttribute("students");
    %>
    
    <table border="1" cellpadding="10", cellspacing="0">
        <tr>
            <th>id</th>
            <th>user</th>
            <th>password</th>
            <th>Delete</th>
        </tr>
        <%
            for (Student st : stus) {
        %>
        <tr>
            <td><%= st.getId() %></td>
            <td><%= st.getUser() %></td>
            <td><%= st.getPassword() %></td>
            <td><a href="deleteStudent?id=<%=st.getId()%>">Delete</a></td>
        </tr>
    
        <%
            }
        %>
    </table>
    </body>
    </html>
    ```

  - 删除超链接点击后跳转Servlet进行删除

    ```java
    package com.litian.mvc;
    
    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ${NAME}.java
     * @time: 2020/4/22 12:50
     * @desc: |
     */
    
    @WebServlet(name = "DeleteStudentServlet", urlPatterns = "/deleteStudent")
    public class DeleteStudentServlet extends HttpServlet {
        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    
        }
    
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String id = request.getParameter("id");
            StudentDao dao = new StudentDao();
            dao.deleteById(Integer.parseInt(id));
    
            request.getRequestDispatcher("/success.jsp").forward(request, response);
        }
    }
    ```

  - 删除成功后跳转success.jsp页面

    ```jsp
    <%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/4/22
      Time: 12:54
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
    <head>
        <title>删除成功！</title>
    </head>
    <body>
    操作成功！
    <br><br>
    <a href="listAllStudents">List All Students</a>
    
    </body>
    </html>
    ```

### 6.3 MVC案例3：架构分析

- 没有业务层，直接由Servlet调用DAO，所以也没有事务操作，所以可以在DAO中直接获取Connection对象。

- 采取MVC设计模式

- 使用到的技术

  - MVC设计模式：JSP、Servlet，[POJO](https://baike.baidu.com/item/POJO/3311958?fr=aladdin)（Plain Ordinary Java Object）
  - 数据库使用MySQL
  - 连接数据库需要使用C3P0数据库连接池
  - JDBC工具采用DBUtils
  - 页面上的提示操作使用jQuery

- 技术难点

  - 多个请求如何使用一个Servlet？
  - 模糊查询
  - 在创建 或 修改的情况下，验证用户名是否被使用，并给出对应的提示

- 技术路线

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200422145112997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

#### 6.3.1 DAO层设计

- 创建数据表

  ```mysql
  create table customers(
      id int primary key auto_increment,
      name varchar(30) not null unique ,
      address varchar(30),
      phone varchar(30)
  );
  ```

- 为name字段添加唯一约束，如果忘记了约束是什么，唯一约束是什么，[参考连接](https://blog.csdn.net/baidu_37964071/article/details/80295312)

  ```mysql
  alter table customers add constraint name_uk unique (name);
  ```

- 加入C3P0数据源

  - C3P0及其依赖包

  - 数据库驱动的jar包

  - 记得配置环境哦

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200423170922518.png)

- 编写DAO、JDBCUtils工具类和CustomerDAO接口

- 提供CustomerDAO接口的实现类：CustomerDAOJDBCImpl

#### 6.3.2 DAO层实现

- com.litian.mvc.domain.Customer：目标类，javabean

  ```java
  package com.litian.mvc.domain;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Customer.java
   * @time: 2020/4/23 12:33
   * @desc: |
   */
  
  public class Customer {
      private Integer id;
      private String name;
      private String address;
      private String phone;
  
      public Customer() {
      }
  
      public Customer(Integer id, String name, String address, String phone) {
          this.id = id;
          this.name = name;
          this.address = address;
          this.phone = phone;
      }
  
      public Integer getId() {
          return id;
      }
  
      public void setId(Integer id) {
          this.id = id;
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public String getAddress() {
          return address;
      }
  
      public void setAddress(String address) {
          this.address = address;
      }
  
      public String getPhone() {
          return phone;
      }
  
      public void setPhone(String phone) {
          this.phone = phone;
      }
  
      @Override
      public String toString() {
          return "Customer{" +
                  "id=" + id +
                  ", name='" + name + '\'' +
                  ", address='" + address + '\'' +
                  ", phone='" + phone + '\'' +
                  '}';
      }
  }
  ```

- com.litian.mvc.db.JdbcUtils：利用C3P0实现JDBC操作工具

  ```java
  package com.litian.mvc.db;
  
  import com.mchange.v2.c3p0.ComboPooledDataSource;
  
  import javax.sql.DataSource;
  import java.sql.Connection;
  import java.sql.SQLException;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: JdbcUtils.java
   * @time: 2020/4/23 12:30
   * @desc: |JDBC操作的工具类
   */
  
  public class JdbcUtils {
  
      private static DataSource dataSource = null;
  
      static {
          // 数据源只能被创建一次
          dataSource = new ComboPooledDataSource("mvcapp");
      }
  
  
      /**
       * 释放Connection连接
       * @param conn
       */
      public static void releaseConnection(Connection conn) {
          try {
              conn.close();
          } catch (SQLException e) {
              e.printStackTrace();
          }
      }
  
  
      /**
       * 返回数据源的一个Connection对象
       * @return
       */
      public static Connection getConnection() throws SQLException {
          return dataSource.getConnection();
      }
  }
  ```

- c3p0-config.xml：放在src根目录，c3p0的配置文件

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <c3p0-config>
  
      <!-- 专门为Mysql提供的配置信息 -->
      <named-config name="mvcapp">
          <property name="jdbcUrl">jdbc:mysql://localhost:3306/test_users?serverTimezone=GMT%2B8</property>
          <property name="driverClass">com.mysql.cj.jdbc.Driver</property>
          <property name="user">root</property>
          <property name="password">123456</property>
  
        <!-- 若数据库中连接数不足时，一次向数据库服务器申请多少个连接 -->
          <property name="acquireIncrement">5</property>
          <!-- 初始化数据库连接池时连接的数量 -->
          <property name="initialPoolSize">10</property>
          <!-- 数据库连接池中最小的数据库连接数 -->
          <property name="minPoolSize">10</property>
          <!-- 数据库连接池中最大的数据库连接数 -->
          <property name="maxPoolSize">50</property>
  
          <!-- C3P0数据库连接池可以维护的Statement的个数 -->
          <property name="maxStatements">20</property>
          <!-- 每个连接同时可以使用的Statement对象的个数 -->
          <property name="maxStatementsPerConnection">5</property>
  
  
      </named-config>
  </c3p0-config>
  ```

- com.litian.mvc.dao.DAO：使用DBUtils，解决增删改查问题

  ```java
  package com.litian.mvc.dao;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: DAO.java
   * @time: 2020/4/23 12:22
   * @desc: |
   */
  
  import com.litian.mvc.db.JdbcUtils;
  import org.apache.commons.dbutils.QueryRunner;
  import org.apache.commons.dbutils.handlers.BeanHandler;
  import org.apache.commons.dbutils.handlers.BeanListHandler;
  import org.apache.commons.dbutils.handlers.ScalarHandler;
  
  import java.lang.reflect.ParameterizedType;
  import java.lang.reflect.Type;
  import java.sql.Connection;
  import java.sql.SQLException;
  import java.util.List;
  
  /**
   * 封装了基本的CRUD（增删改查）的方法，以供子类继承使用
   * 当前DAO直接在方法中获取数据库连接
   * 真个DAO采取DBUtils解决方案
   *
   * @param <T> 当前DAO处理的实体类的类型是什么
   */
  public class DAO<T> {
  
      private QueryRunner queryRunner = new QueryRunner();
  
      private Class<T> clazz;
  
      public DAO() {
          // [参考连接](https://bbs.csdn.net/topics/360169835?depth_1-utm_source=distribute.pc_relevant.none-task-discussion_topic-BlogCommendFromBaidu-3&utm_source=distribute.pc_relevant.none-task-discussion_topic-BlogCommendFromBaidu-3)
          // [什么是泛型](https://segmentfault.com/a/1190000014120746)
          // getGenericSuperclass() 通过反射获取当前类表示的实体（类，接口，基本类型或void）
          // 的直接父类的Type，getActualTypeArguments()返回参数数组。
  
          // 得到这个类的泛型父类
          Type superClass = getClass().getGenericSuperclass();
  
          // 如果没有实现ParameterizedType接口,即不支持泛型
          if (superClass instanceof ParameterizedType) {
  
              // 如果支持泛型，返回表示此类型实际类型参数的Type对象的数组，
              // 数组里放的都是对应类型的Class，因为可能有多个，所以是数组。
              ParameterizedType parameterizedType = (ParameterizedType) superClass;
              Type[] typeArgs = parameterizedType.getActualTypeArguments();
  
              if (typeArgs != null && typeArgs.length > 0) {
                  if (typeArgs[0] instanceof Class) {
                      clazz = (Class<T>) typeArgs[0];
                  }
              }
          }
      }
  
      /**
       * 返回某一个字段的值，例如返回某一条记录的id或name
       *
       * @param sql
       * @param args
       * @param <E>
       * @return
       */
      public <E> E getForValue(String sql, Object... args) {
          Connection conn = null;
          try {
              conn = JdbcUtils.getConnection();
              return (E) queryRunner.query(conn, sql, new ScalarHandler<>(), args);
          } catch (SQLException e) {
              e.printStackTrace();
          } finally {
              JdbcUtils.releaseConnection(conn);
          }
  
          return null;
      }
  
      /**
       * 返回T所对应的List
       *
       * @param sql
       * @param args
       * @return
       */
      public List<T> getForList(String sql, Object... args) {
          Connection conn = null;
          try {
              conn = JdbcUtils.getConnection();
              return queryRunner.query(conn, sql, new BeanListHandler<>(clazz), args);
          } catch (SQLException e) {
              e.printStackTrace();
          } finally {
              JdbcUtils.releaseConnection(conn);
          }
  
          return null;
      }
  
      /**
       * 返回对应的T的一个实体类的对象
       *
       * @param sql
       * @param args
       * @return
       */
      public T get(String sql, Object... args) {
          Connection conn = null;
          try {
              conn = JdbcUtils.getConnection();
              return queryRunner.query(conn, sql, new BeanHandler<>(clazz), args);
          } catch (SQLException e) {
              e.printStackTrace();
          } finally {
              JdbcUtils.releaseConnection(conn);
          }
  
          return null;
      }
  
      /**
       * 该方法封装了insert、delete和update操作
       *
       * @param sql  sql语句
       * @param args 填充sql语句的占位符
       */
      public void update(String sql, Object... args) {
          Connection conn = null;
          try {
              conn = JdbcUtils.getConnection();
              queryRunner.update(conn, sql, args);
          } catch (SQLException e) {
              e.printStackTrace();
          } finally {
              JdbcUtils.releaseConnection(conn);
          }
      }
  }
  ```

- com.litian.mvc.dao.CustomerDao：目标类需要实现的方法，接口

  ```java
  package com.litian.mvc.dao;
  
  import com.litian.mvc.domain.Customer;
  
  import java.util.List;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: CustomerDao.java
   * @time: 2020/4/23 12:31
   * @desc: |
   */
  
  public interface CustomerDao {
      public List<Customer> getAll();
  
      public void save(Customer c);
  
      public Customer get(Integer id);
  
      public void delete(Integer id);
  
      /**
       * 返回和name相等的记录数
       * @param name
       * @return
       */
      public long getCountWithNames(String name);
  }
  ```

- com.litian.mvc.dao.impl.CustomerDAOJdbcImpl：集成DAO实现CustomerDao接口，具体方法的实现类

  ```java
  package com.litian.mvc.dao.impl;
  
  import com.litian.mvc.dao.CustomerDao;
  import com.litian.mvc.dao.DAO;
  import com.litian.mvc.domain.Customer;
  
  import java.util.List;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: CustomerDAOJdbcImpl.java
   * @time: 2020/4/23 12:39
   * @desc: |
   */
  
  public class CustomerDAOJdbcImpl extends DAO<Customer> implements CustomerDao {
      @Override
      public List<Customer> getAll() {
          String sql = "select id, name, address, phone from customers";
          return getForList(sql);
      }
  
      @Override
      public void save(Customer c) {
          String sql = "insert into customers(name, address, phone) values (?, ?, ?)";
          update(sql, c.getName(), c.getAddress(), c.getPhone());
      }
  
      @Override
      public Customer get(Integer id) {
          String sql = "select id, name, address, phone from customers where id = ?";
          return get(sql, id);
      }
  
      @Override
      public void delete(Integer id) {
          String sql = "delete from customers where id = ?";
          update(sql, id);
      }
  
      @Override
      public long getCountWithNames(String name) {
          String sql = "select count(id) from customers where name = ?";
          return getForValue(sql, name);
      }
  }
  ```

#### 6.3.3 如何实现多个请求使用一个Servlet

- 方法1：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200424115302116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - 方法1存在的问题：

    1. 当添加一个请求时，需要再Servlet中修改两处代码，switch、添加方法。
    2. url中使用method=xxx暴露了要调用的方法，不私密，有安全隐患。

- 解决方案（方法2）：（我对解决方案的理解就是：原来的方案是通过接受的method值，利用if或switch语句，映射到对应的方法；而改进后的方法则是，直接根据方法名对应的字符串，利用反射调用该方法）

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200424130542876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - 方法2的实现流程：

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200424131803962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  > 运行时报错： `java.lang.IllegalArgumentException: Invalid <url-pattern> [/*.do] in servlet mapping`
  >
  > 解决方案：[参考连接](https://blog.csdn.net/liuzongl2012/article/details/43793167)
  >
  > ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200424130352181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 代码：

  - 测试页面：发送多个请求

    ```jsp
    <%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/4/24
      Time: 12:31
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
    <head>
        <title>测试</title>
    </head>
    <body>
    <%--
    <a href="customerServlet?method=add">Add</a>
    <br><br>
    <a href="customerServlet?method=query">Query</a>
    <br><br>
    <a href="customerServlet?method=delete">Delete</a>
    --%>
    
    <a href="add.do">Add</a>
    <br><br>
    <a href="query.do">Query</a>
    <br><br>
    <a href="delete.do">Delete</a>
    <br><br>
    <a href="update.do">Update</a>
    <br><br>
    
    
    </body>
    </html>
    ```

  - 一个Servlet处理多个请求

    ```java
    package com.litian.mvc.servlet;
    
    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    import java.lang.reflect.Method;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ${NAME}.java
     * @time: 2020/4/24 12:34
     * @desc: |
     */
    
    // @WebServlet(name = "CustomerServlet", urlPatterns = "/customerServlet")
    @WebServlet(name = "CustomerServlet", urlPatterns = "*.do")
    public class CustomerServlet extends HttpServlet {
        /*
        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String method = request.getParameter("method");
            switch (method) {
                case "add":
                    add(request, response);
                    break;
                case "query":
                    query(request, response);
                    break;
                case "delete":
                    delete(request, response);
                    break;
            }
        }
        */
    
        @Override
        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            // 1. 获取ServletPath：/edit.do或/addCustomer.do
            String servletPath = req.getServletPath();
            // 2. 去除/和.do，得到类似于edit或addCustomer这样的字符串
            String methodName = servletPath.substring(1);
            methodName = methodName.substring(0, methodName.length() - 3);
            // System.out.println(methodName);
    
            try {
                // 3. 利用反射获取methodName对应的方法
                Method method = getClass().getDeclaredMethod(methodName, HttpServletRequest.class, HttpServletResponse.class);
                // 4. 利用反射调用对应的方法
                method.invoke(this, req, resp);
            } catch (Exception e) {
                // e.printStackTrace();
                // 对没有的方法可以由一些良好的响应（重定向）
                resp.sendRedirect("error.jsp?code=CannotFindMethod");
            }
        }
    
        private void update(HttpServletRequest request, HttpServletResponse response) {
            System.out.println("update");
        }
    
        private void delete(HttpServletRequest request, HttpServletResponse response) {
            System.out.println("delete");
        }
    
        private void query(HttpServletRequest request, HttpServletResponse response) {
            System.out.println("query");
        }
    
        private void add(HttpServletRequest request, HttpServletResponse response) {
            System.out.println("add");
        }
    
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            doPost(request, response);
        }
    }
    ```

  - 若不存在请求则跳转到一个错误页面

    ```jsp
    <%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/4/24
      Time: 13:20
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
    <head>
        <title>错误页面</title>
    </head>
    <body>
    <h4>对不起，找不到您请求的页面！</h4>
    <br>
    <%
        String code = request.getParameter("code");
    %>
    错误描述为：<%=code%>
    </body>
    </html>
    ```

#### 6.3.4 模糊查询

- 在html中，`<th>`是表示的表头，table head；`<td>`是表示的表格单元，table district

  - 字体不同：th 元素内部的文本通常会呈现为居中的粗体文本，而 td 元素内的文本通常是左对齐的普通文本。
  - 定义的不同：th：定义表格的表头，td：定义表格单元。
  - 用法上的不同：`<table>`是`<tr>`的上层标签，`<tr>必`须在一个`<table></table>`里面，它不能单独使用，相当于`<table>`的属性标签。`<table>`标示一个表格，`<tr>`标示这个表格中间的一个行。
  - 包含的关系不同：一组`<td>`标签将建立一个单元格，`<td>`标签必须放在`<tr>`标签内，`<td>`标示行中的一个列，需要嵌套在`<tr></tr>`中间。

- 查询操作：

  - Servlet

    ```java
    // 1. 调用CustomerDao的getAll()得到Customer的集合
    List<Customer> customers = dao.getAll();
    // 2. 把Customer的集合放入request中
    request.setAttribute("customers", customers);
    // 3. 转发页面到index.jsp中（不能使用重定向）
    request.getRequestDispatcher("/index.jsp").forward(request, response);
    ```

  - JSP

    - 获取request中的customers属性
    
    - 遍历显示
    
      ```jsp
      <%
          List<Customer> customers = (List<Customer>) request.getAttribute("customers");
          if (customers != null && customers.size() > 0) {
      %>
      <br>
      <br>
      <table border="1" cellspacing="0" cellpadding="10">
          <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Address</th>
              <th>Phone</th>
              <th>UPDATE/DELETE</th>
          </tr>
      
          <%
              for (Customer customer : customers) {
          %>
      
          <tr>
              <td><%=customer.getId()%>
              </td>
              <td><%=customer.getName()%>
              </td>
              <td><%=customer.getAddress()%>
              </td>
              <td><%=customer.getPhone()%>
              </td>
              <td><a href="">UPDATE</a> / <a href="delete.do?id=<%=customer.getId()%>" class="delete">DELETE</a></td>
          </tr>
      
          <%
              }
          %>
      
          <%
              }
          %>
      </table>
      ```

- 模糊查询

  - 根据传入的name，address，phone进行模糊查询

  - 例子：name：a、address：b、phone：3，则sql语句为：

    ```sql
    select id, name, address, phone from customers where name like '%a%' and adddress like '%b%' and phone like '%3%'
    ```

  - 填充占位符的技巧：重写get方法

    - 需要在CustomerDAO接口中定义一个getForListWithCriteriaCustomer(CriteriaCustomer cc)

    - 其中**CriteriaCustomer**用于封装查询条件name、address、phone。因为查询条件很多时候和domain类并不相同，所以要做成一个单独的类。
    
      ```java
      package com.litian.mvc.dao;
      
      /**
       * @author: Li Tian
       * @contact: litian_cup@163.com
       * @software: IntelliJ IDEA
       * @file: CriteriaCustomer.java
       * @time: 2020/4/25 15:26
       * @desc: |
       */
      
      public class CriteriaCustomer {
          private String name;
          private String address;
          private String phone;
      
          public CriteriaCustomer(String name, String address, String phone) {
              this.name = name;
              this.address = address;
              this.phone = phone;
          }
      
          public String getName() {
              if (name == null) {
                  name = "%%";
              } else {
                  name = "%" + name + "%";
              }
              return name;
          }
      
          public void setName(String name) {
              this.name = name;
          }
      
          public String getAddress() {
              if (address == null) {
                  address = "%%";
              } else {
                  address = "%" + address + "%";
              }
              return address;
          }
      
          public void setAddress(String address) {
              this.address = address;
          }
      
          public String getPhone() {
              if (phone == null) {
                  phone = "%%";
              } else {
                  phone = "%" + phone + "%";
              }
              return phone;
          }
      
          public void setPhone(String phone) {
              this.phone = phone;
          }
  }
      ```

    - 拼sql：
    
      ```sql
  select id, name, address, phone from customers where name like ? and address like ? and phone like ?
      ```

    - 填充占位符时，为了正确的填充，重写了CriteriaCustomer的get方法
    
      ```java
      public String getName() {
          if (name == null) {
              name = "%%";
          } else {
              name = "%" + name + "%";
          }
          return name;
  }
      ```

    - 修改Servlet：获取请求参数，把请求参数封装为CriteriaCustomer对象，再调用getForListWithCriteriaCustomer方法（**替换getAll方法**）
    
      ```java
      // 获取模糊查询的请求参数
      String name = request.getParameter("name");
      String phone = request.getParameter("phone");
      String address = request.getParameter("address");
      // 把请求参数封装为一个CriteriaCustomer
      CriteriaCustomer cc = new CriteriaCustomer(name, address, phone);
      // 调用CustomerDao的getAll（划去）->getForListWithCriteriaCustomer得到Customer的集合
      List<Customer> customers = dao.getForListWithCriteriaCustomer(cc);
      ```

#### 6.3.5 删除操作

- 超链接：`delete.do?id=<%=customer.getId()%>`

- Servlet的delete方法

  - 获取id
  - 调用DAO执行删除
  - 重定向到**query.do**（若目标页面不需要读取当前请求的request属性，就可以使用重定向），将显示删除后的customer的list

- JSP上的jQuery提示：确定要删除xx的信息吗？

  - 这里我没学过jQuery，因此百度了一个[教程](https://blog.csdn.net/qq_33322074/article/details/79990584)

    ```jsp
    <script type="text/javascript" src="scripts/jquery-3.5.0.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $(".delete").click(function () {
                var flag = confirm("确定要删除的信息吗？");
                return flag;
            });
        })
    ```


#### 6.3.6 添加操作

- 添加的流程

  - Add New Customer超链接连接到newcustomer.jsp

  - 新建newcustomer.jsp

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200428153124701.png)

  - 在CustomerServlet的add方法中：获取表单参数、检验名字是否被占用、回显等

    ```java
    private void add(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 1. 获取表单参数：name，address，phone
        String name = request.getParameter("name");
        String address = request.getParameter("address");
        String phone = request.getParameter("phone");
    
        // 2. 检验名字是否被占用
        // 2.1 调用CustomerDao的getCountWithName方法获取name在数据库中是否存在
        long count = dao.getCountWithNames(name);
        // 2.2 若返回值大于0，则相应newcustomer.jsp页面：
        // 通过转发的方式来相应newcustomer.jsp
        if (count > 0) {
            // 2.2.1 要求在newcustomer.jsp页面显示一个错误消息：该用户名已被占用，请重新选择！
            // 在request中放入一个属性message：该用户名已被占用，请重新选择！
            // 在页面上通过request.getAttribute("message")的方式来显示
            request.setAttribute("message", "该用户名【" + name + "】已被占用，请重新选择！");
    
            // 2.2.2 newcustomer.jsp的表单值可以回显。
            // 方式：<td><input type="text" name="name" value="<%=request.getParameter("name") == null ? "": request.getParameter("name")%>"/></td>
            // 2.2.3 结束方法：return
            request.getRequestDispatcher("/newcustomer.jsp").forward(request, response);
            return;
        }
        // 3. 若验证通过，则把表单参数封装为一个Customer对象customer
        Customer cc = new Customer(name, address, phone);
        // 4. 调用CustomerDao的save方法执行保存操作
        dao.save(cc);
        // 5. 重定向到success.jsp页面：使用重定向可以避免出现表单的重复提交问题。
        // System.out.println(request.getParameter("name"));
        response.sendRedirect("success.jsp");
    }
    ```

  - 回显流程图（套娃？）包含了两个请求：

    - 加载页面的请求：发出请求到页面加载完成，请求结束。
    - 点击提交按钮到Servlet，发出了一个请求，Servlet转发到newcustomer.jsp直到页面加载完成，整个过程为一个请求（request）
    
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200428160931992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

#### 6.3.7 修改操作

- 修改思路：先显示页面，修改字段，提交表单，修稿。
  - 先显示（select操作）修改的页面updatecustomer.jsp，再进行修改（update操作）
  
  - 显示修改页面
    - update 的超链接：`<a href="edit.do?id=<%=customer.getId()%>">修改</a>`
    - Edit方法：获取id，调用CustomerDAO的方法获取id对应的Customer对象等
    - JSP页面（下述方法存在出错后无法保留输入值的问题，已在代码中修正）：
      - 获取请求域中的Customer对象，调用对应的字段的get方法来显示值
      - 需要使用隐藏域来保存需要修改的Customer对象的id：`<input type="hidden" name="id" value="<%=customer.getId()%>">`
      - 使用隐藏域来保存oldName：`<input type="hidden" name="oldName" value="<%=customer.getName()%>">`
      - 关于隐藏域：和其他的表单域一样，可以被提交到服务器，只不过在页面上不显示
      - 提交到update.do中
    - 修改操作
      - 获取请求参数：id，name，address，phone，oldName
      - 对name进行验证：对比oldName和name
      - Update方法：参见注释
      - updatecustomer.jsp：
        - 隐藏域的问题：id一般都使用隐藏域
        - 回显的问题
      - newcustomer.jsp和updatecustomer.jsp能汇总到一个页面吗？（思考）
    
  - 修改中的复杂验证，若某一字段在数据表中不允许重复的解决方案：
  
    1. 在表单中使用隐藏域保存该字段的最原始的值：`<input type="hidden" name="oldName" value="<%=oldName%>"/>`
  
    2. 在Servlet中同时获取原始值和新提交的值：比对，若一致，则通过；若不一致，则使用新提交的值去查询数据表。
  
       ```java
       if (!oldName.equalsIgnoreCase(name)) {
           long count = dao.getCountWithNames(name);
           // 2.2 若返回值大于0，则响应 updatecustomer.jsp页面：
           // 通过转发的方式来响应 updatecustomer.jsp
           if (count > 0) {
               // 2.2.1 要求在 updatecustomer.jsp页面显示一个错误消息：该用户名已被占用，请重新选择！
               // 在request中放入一个属性message：该用户名已被占用，请重新选择！
               // 在页面上通过request.getAttribute("message")的方式来显示
               request.setAttribute("message", "该用户名【" + name + "】已被占用，请重新选择！");
       
               // 2.2.2 updatecustomer.jsp的表单值可以回显。
               // 其中：address和phone显示提交表单的新的值，而name显示oldName而不是新提交的name
               request.getRequestDispatcher("/updatecustomer.jsp").forward(request, response);
               // 2.2.3 结束方法：return
               return ;
           }
       }
       ```
  
    3. 在修改状态下，若验证没有通过，表单的回显问题：不允许重复的字段要给予提示，但字段中显示旧的字段的值；允许修改的则改为新的字段的值。（就是名字显示为原来的名字，地址和电话保留改后的值）**这里通过Ajax会有更好的用户体验**
  
  - `response.sendRedirect()`方法的副作用 **（？这里应该不能叫副作用吧，应该叫额外的功能吧。。。）** 可以防止表单的重复提交。
  
  - 转发要加`/`，重定向不能加`/`
  
- 最后几个重要的相关代码：

  - 首页index.jsp

    ```jsp
    <%@ page import="com.litian.mvc.domain.Customer" %>
    <%@ page import="java.util.List" %><%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/4/23
      Time: 12:17
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
    <head>
        <title>首页</title>
        <script type="text/javascript" src="scripts/jquery-3.5.0.min.js"></script>
        <script type="text/javascript">
            $(function () {
                $(".delete").click(function () {
                    var content = $(this).parent().parent().find("td:eq(1)").text().replace('\n', '').trim();
                    return confirm("确定要删除【" + content + "】的信息吗？");
                    // return confirm("aaa" + content + "end");
                });
            })
        </script>
    </head>
    <body>
    <form action="query.do" method="post">
        <table>
            <tr>
                <td>CustomerName:</td>
                <td><input type="text" name="name"/></td>
            </tr>
            <tr>
                <td>Address:</td>
                <td><input type="text" name="address"/></td>
            </tr>
            <tr>
                <td>Phone:</td>
                <td><input type="text" name="phone"/></td>
            </tr>
            <tr>
                <td><input type="submit" value="Query"></td>
                <td><a href="newcustomer.jsp">Add New Customer</a></td>
            </tr>
        </table>
    </form>
    <br><br>
    
    <%
        List<Customer> customers = (List<Customer>) request.getAttribute("customers");
        if (customers != null && customers.size() > 0) {
    %>
    <br>
    <br>
    <table border="1" cellspacing="0" cellpadding="10">
        <tr>
            <th>ID</th>
            <th>Name</th>
            <th>Address</th>
            <th>Phone</th>
            <th>UPDATE/DELETE</th>
        </tr>
    
        <%
            for (Customer customer : customers) {
        %>
    
        <tr>
            <td><%=customer.getId()%>
            </td>
            <td><%=customer.getName()%>
            </td>
            <td><%=customer.getAddress()%>
            </td>
            <td><%=customer.getPhone()%>
            </td>
            <td><a href="edit.do?id=<%=customer.getId()%>">修改</a> / <a href="delete.do?id=<%=customer.getId()%>" class="delete">删除</a></td>
        </tr>
    
        <%
            }
        %>
    
        <%
            }
        %>
    </table>
    </body>
    </html>
    ```

  - 新建用户页面：newcustomer.jsp

    ```jsp
    <%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/4/28
      Time: 15:27
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
    <head>
        <title>新建用户</title>
    </head>
    <body>
    
    <%----<%=request.getParameter("name")%>----%>
    
    <%
        Object msg = request.getAttribute("message");
        if (msg != null) {
    %>
    <br>
    <font color="red"><%=msg%></font>
    <br>
    <%
        }
    %>
    
    <form action="add.do" method="post">
        <table>
            <tr>
                <td>CustomerName:</td>
                <td><input type="text" name="name"
                           value="<%=request.getParameter("name") == null ? "": request.getParameter("name")%>"/></td>
            </tr>
            <tr>
                <td>Address:</td>
                <td><input type="text" name="address"
                           value="<%=request.getParameter("address") == null ? "": request.getParameter("address")%>"/></td>
            </tr>
            <tr>
                <td>Phone:</td>
                <td><input type="text" name="phone"
                           value="<%=request.getParameter("phone") == null ? "": request.getParameter("phone")%>"/></td>
            </tr>
            <tr>
                <td colspan="2"><input type="submit" value="确定"></td>
            </tr>
        </table>
    </form>
    </body>
    </html>
    ```

  - 修改用户信息页面：updatecustomer.jsp

    ```jsp
    <%@ page import="com.litian.mvc.domain.Customer" %><%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/4/28
      Time: 15:27
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
    <head>
        <title>修改用户</title>
    </head>
    <body>
    <%----<%=request.getParameter("name")%>----%>
    <%
        Object msg = request.getAttribute("message");
        if (msg != null) {
    %>
    <br>
    <font color="red"><%=msg%>
    </font>
    <br>
    <%
        }
        String id = null;
        String oldName = null;
        String name = null;
        String address = null;
        String phone = null;
    
        Customer cc = (Customer) request.getAttribute("customer");
    
        // 如果cc不为空，则是从点击修改连接过来的
        // 若为空，则是出错之后返回而来的（名字已被占用）
        if (cc != null) {
            id = cc.getId() + "";
            oldName = cc.getName();
            name = cc.getName();
            address = cc.getAddress();
            phone = cc.getPhone();
        }else{
            id = request.getParameter("id");
            oldName = request.getParameter("oldName");
            name = request.getParameter("oldName");
            address = request.getParameter("address");
            phone = request.getParameter("phone");
        }
    %>
    
    <form action="update.do" method="post">
    
        <%--  隐藏域  --%>
        <input type="hidden" name="id" value="<%=id%>"/>
        <input type="hidden" name="oldName" value="<%=oldName%>"/>
    
        <table>
            <tr>
                <td>CustomerName:</td>
                <td><input type="text" name="name"
                           value="<%=name%>"/></td>
            </tr>
            <tr>
                <td>Address:</td>
                <td><input type="text" name="address"
                           value="<%=address%>"/></td>
            </tr>
            <tr>
                <td>Phone:</td>
                <td><input type="text" name="phone"
                           value="<%=phone%>"/></td>
            </tr>
            <tr>
                <td colspan="2"><input type="submit" value="提交"></td>
            </tr>
        </table>
    </form>
    </body>
    </html>
    ```

  - 实际管理用户的DAO：CustomerDAOJdbcImpl.java

    ```java
    package com.litian.mvc.dao.impl;
    
    import com.litian.mvc.dao.CriteriaCustomer;
    import com.litian.mvc.dao.CustomerDao;
    import com.litian.mvc.dao.DAO;
    import com.litian.mvc.domain.Customer;
    
    import java.util.List;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: CustomerDAOJdbcImpl.java
     * @time: 2020/4/23 12:39
     * @desc: |
     */
    
    public class CustomerDAOJdbcImpl extends DAO<Customer> implements CustomerDao {
        @Override
        public List<Customer> getForListWithCriteriaCustomer(CriteriaCustomer cc) {
            String sql = "select id, name, address, phone from customers where name like ? and address like ? and phone like ?";
            // return getForList(sql, cc.getName() == null? "%%": "%" + cc.getName() + "%");
            // 修改了CriteriaCustomer的getter方法：使其返回的字符串中有"%%"
            // 若返回值为null则返回"%%"，若不为null，则返回"%" + 字段本身的值 + "%"
            return getForList(sql, cc.getName(), cc.getAddress(), cc.getPhone());
        }
    
        @Override
        public List<Customer> getAll() {
            String sql = "select id, name, address, phone from customers";
            return getForList(sql);
        }
    
        @Override
        public void save(Customer c) {
            String sql = "insert into customers(name, address, phone) values (?, ?, ?)";
            update(sql, c.getName(), c.getAddress(), c.getPhone());
        }
    
        @Override
        public Customer get(Integer id) {
            String sql = "select id, name, address, phone from customers where id = ?";
            return get(sql, id);
        }
    
        @Override
        public void delete(Integer id) {
            String sql = "delete from customers where id = ?";
            update(sql, id);
        }
    
        @Override
        public void update(Customer customer) {
            String sql = "update customers set name = ?, address = ?, phone = ? where id = ?";
            update(sql, customer.getName(), customer.getAddress(), customer.getPhone(), customer.getId());
        }
    
        @Override
        public long getCountWithNames(String name) {
            String sql = "select count(id) from customers where name = ?";
            return getForValue(sql, name);
        }
    }
    ```

    - 处理各种请求的CustomerServlet.java

    ```java
    package com.litian.mvc.servlet;
    
    import com.litian.mvc.dao.CriteriaCustomer;
    import com.litian.mvc.dao.CustomerDao;
    import com.litian.mvc.dao.factory.CustomerDAOFactory;
    import com.litian.mvc.dao.impl.CustomerDAOJdbcImpl;
    import com.litian.mvc.domain.Customer;
    
    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    import java.lang.reflect.Method;
    import java.util.List;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ${NAME}.java
     * @time: 2020/4/24 12:34
     * @desc: |
     */
    
    // @WebServlet(name = "CustomerServlet", urlPatterns = "/customerServlet")
    @WebServlet(name = "CustomerServlet", urlPatterns = "*.do")
    public class CustomerServlet extends HttpServlet {
        // private CustomerDao dao = new CustomerDAOJdbcImpl();
        private CustomerDao dao = CustomerDAOFactory.getInstance().getCustomerDAO();
    
        /*
        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            String method = request.getParameter("method");
            switch (method) {
                case "add":
                    add(request, response);
                    break;
                case "query":
                    query(request, response);
                    break;
                case "delete":
                    delete(request, response);
                    break;
            }
        }
        */
    
        @Override
        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            // 1. 获取ServletPath：/edit.do或/addCustomer.do
            String servletPath = req.getServletPath();
            // 2. 去除/和.do，得到类似于edit或addCustomer这样的字符串
            String methodName = servletPath.substring(1);
            methodName = methodName.substring(0, methodName.length() - 3);
            // System.out.println(methodName);
    
            try {
                // 3. 利用反射获取methodName对应的方法
                Method method = getClass().getDeclaredMethod(methodName, HttpServletRequest.class, HttpServletResponse.class);
                // 4. 利用反射调用对应的方法
                method.invoke(this, req, resp);
            } catch (Exception e) {
                // e.printStackTrace();
                // 对没有的方法可以由一些良好的响应（重定向）
                resp.sendRedirect("error.jsp");
            }
        }
    
        /**
         * 在收到修改请求之后，将请求和参数id转发到updatecustomer.jsp页面，如果id为无效值则转发到error.jsp
         *
         * @param request
         * @param response
         * @throws IOException
         * @throws ServletException
         */
        private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
            String forwardPath = "/error.jsp";
    
            // 1. 获取请求参数id
            String idStr = request.getParameter("id");
            int id = -1;
            // 2. 调用CustomerDAO的get方法获取和id对应的Customer对象customer
            try {
                Customer cc = dao.get(Integer.parseInt(idStr));
                if (cc != null) {
                    forwardPath = "/updatecustomer.jsp";
                    // 3. 将customer放入request中
                    request.setAttribute("customer", cc);
                }
            } catch (NumberFormatException e) {
                e.printStackTrace();
            }
    
            // 4. 响应updatecustomer.jsp页面：转发
            request.getRequestDispatcher(forwardPath).forward(request, response);
        }
    
        private void update(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
            // 1. 获取表单参数：id，name，address，phone，oldName
            String id = request.getParameter("id");
            String name = request.getParameter("name");
            String phone = request.getParameter("phone");
            String address = request.getParameter("address");
            String oldName = request.getParameter("oldName");
    
            // 2. 比较name和oldName是否相同：若相同说明name可用。
            // 2.1 若不相同，调用CustomerDao的getCountWithName方法获取name在数据库中是否存在
            // 不分大小写
            if (!oldName.equalsIgnoreCase(name)) {
                long count = dao.getCountWithNames(name);
                // 2.2 若返回值大于0，则响应 updatecustomer.jsp页面：
                // 通过转发的方式来响应 updatecustomer.jsp
                if (count > 0) {
                    // 2.2.1 要求在 updatecustomer.jsp页面显示一个错误消息：该用户名已被占用，请重新选择！
                    // 在request中放入一个属性message：该用户名已被占用，请重新选择！
                    // 在页面上通过request.getAttribute("message")的方式来显示
                    request.setAttribute("message", "该用户名【" + name + "】已被占用，请重新选择！");
    
                    // 2.2.2 updatecustomer.jsp的表单值可以回显。
                    // 其中：address和phone显示提交表单的新的值，而name显示oldName而不是新提交的name
                    request.getRequestDispatcher("/updatecustomer.jsp").forward(request, response);
                    // 2.2.3 结束方法：return
                    return ;
                }
            }
            // 3. 若验证通过，则把表单参数封装为一个Customer对象customer
            Customer cc = new Customer(name, address, phone);
            cc.setId(Integer.parseInt(id));
            // 4. 调用CustomerDao的update方法执行更新操作
            dao.update(cc);
            // 5. 重定向到query.do
            response.sendRedirect("query.do");
        }
    
        private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException {
            String idStr = request.getParameter("id");
            int id = 0;
    
            // try catch的作用：防止idStr不能转为int类型
            // 若不能转，则id=0时，无法进行任何的删除操作
            try {
                id = Integer.parseInt(idStr);
                dao.delete(id);
            } catch (NumberFormatException e) {
                e.printStackTrace();
            }
            response.sendRedirect("query.do");
        }
    
        private void query(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // 获取模糊查询的请求参数
            String name = request.getParameter("name");
            String phone = request.getParameter("phone");
            String address = request.getParameter("address");
            // 把请求参数封装为一个CriteriaCustomer
            CriteriaCustomer cc = new CriteriaCustomer(name, address, phone);
    
            // 1. 调用CustomerDao的getAll（划去）->getForListWithCriteriaCustomer得到Customer的集合
            // List<Customer> customers = dao.getAll();
            List<Customer> customers = dao.getForListWithCriteriaCustomer(cc);
            // 2. 把Customer的集合放入request中
            request.setAttribute("customers", customers);
            // 3. 转发页面到index.jsp中（不能使用重定向）
            request.getRequestDispatcher("/index.jsp").forward(request, response);
        }
    
        private void add(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // 1. 获取表单参数：name，address，phone
            String name = request.getParameter("name");
            String address = request.getParameter("address");
            String phone = request.getParameter("phone");
    
            // 2. 检验名字是否被占用
            // 2.1 调用CustomerDao的getCountWithName方法获取name在数据库中是否存在
            long count = dao.getCountWithNames(name);
            // 2.2 若返回值大于0，则响应newcustomer.jsp页面：
            // 通过转发的方式来响应newcustomer.jsp
            if (count > 0) {
                // 2.2.1 要求在newcustomer.jsp页面显示一个错误消息：该用户名已被占用，请重新选择！
                // 在request中放入一个属性message：该用户名已被占用，请重新选择！
                // 在页面上通过request.getAttribute("message")的方式来显示
                request.setAttribute("message", "该用户名【" + name + "】已被占用，请重新选择！");
    
                // 2.2.2 newcustomer.jsp的表单值可以回显。
                // 方式：<td><input type="text" name="name" value="<%=request.getParameter("name") == null ? "": request.getParameter("name")%>"/></td>
                // 2.2.3 结束方法：return
                request.getRequestDispatcher("/newcustomer.jsp").forward(request, response);
                return;
            }
            // 3. 若验证通过，则把表单参数封装为一个Customer对象customer
            Customer cc = new Customer(name, address, phone);
            // 4. 调用CustomerDao的save方法执行保存操作
            dao.save(cc);
            // 5. 重定向到success.jsp页面：使用重定向可以避免出现表单的重复提交问题。
            // System.out.println(request.getParameter("name"));
            response.sendRedirect("success.jsp");
        }
    
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            doPost(request, response);
        }
    }
    ```

#### 6.3.8 配置切换底层存储源

- 深入理解面向接口编程：在类中调用接口的方法，而不必关心具体的实现。这将有利于代码的解耦。使程序有更好的可移植性和可扩展性。

- 即面向接口编程

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200501180939844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 动态修改Customer的存储方式：通过修改类路径下的switch.properties文件的方式来实现

  ```xml
  type = xml
  # type = jdbc
  ```

  1. CustomerServlet中不能通过`private CustomerDao dao = new CustomerDAOJdbcImpl();`的方式来写死实现类
  2. 需要通过一个类的一个方法来获取具体的实现类的对象

- 新增一个DAO工厂类，用来获取不同的DAO

  ```java
  package com.litian.mvc.dao.factory;
  
  import com.litian.mvc.dao.CustomerDao;
  import com.litian.mvc.dao.impl.CustomerDAOJdbcImpl;
  import com.litian.mvc.dao.impl.CustomerDAOXMLImpl;
  
  import java.util.HashMap;
  import java.util.Map;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: CustomerDAOFactory.java
   * @time: 2020/5/1 18:17
   * @desc: |
   */
  
  public class CustomerDAOFactory {
  
      private static CustomerDAOFactory instance = new CustomerDAOFactory();
      private String type = null;
      private Map<String, CustomerDao> daos = new HashMap<>();
  
      private CustomerDAOFactory() {
          daos.put("jdbc", new CustomerDAOJdbcImpl());
          daos.put("xml", new CustomerDAOXMLImpl());
      }
  
      public static CustomerDAOFactory getInstance() {
          return instance;
      }
  
      public void setType(String type) {
          this.type = type;
      }
  
      public CustomerDao getCustomerDAO() {
          return daos.get(type);
      }
  }
  ```

- 当前WEB应用启动的时候，InitServlet被创建，并由Servlet容器调用其init()方法

  ```java
  package com.litian.mvc.servlet;
  
  import com.litian.mvc.dao.factory.CustomerDAOFactory;
  
  import javax.servlet.ServletException;
  import javax.servlet.annotation.WebServlet;
  import javax.servlet.http.HttpServlet;
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  import java.io.IOException;
  import java.io.InputStream;
  import java.util.Properties;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: ${NAME}.java
   * @time: 2020/5/1 18:24
   * @desc: |
   */
  
  // 设置应用启动的时候，自动加载该Servlet
  @WebServlet(name = "InitServlet", loadOnStartup = 1)
  public class InitServlet extends HttpServlet {
      @Override
      public void init() throws ServletException {
  
          // 读取类路径下的配置文件
          InputStream in = getServletContext().getResourceAsStream("/WEB-INF/classes/switch.properties");
          Properties pp = new Properties();
          try {
              pp.load(in);
              // 获取type属性值
              String type = pp.getProperty("type");
              // 赋给了CustomerDAOFactory的type属性。
              CustomerDAOFactory.getInstance().setType(type);
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```

- 创建CustomerServlet时，为customerDao属性赋值的操作是通过CustomerDAOFactory的getCustomerDAO方法完成的，此时的type已经在InitServlet中被赋值。

  ```java
  private CustomerDao dao = CustomerDAOFactory.getInstance().getCustomerDAO();
  ```

## 7. Cookie

- 会话与状态管理

  - 提出问题：
    - **HTTP协议是一种无状态的协议 **，WEB服务器本身不能识别出哪些请求时同一个浏览器发出的，浏览器的每一次请求都是完全孤立的。
    - 即使HTTP1.1支持持续连接，但当用户有一段时间没有提交请求，连接也会关闭。
    - 怎么才能实现网上商店中的购物车呢：某个用户从网站的登陆页面登陆后，再进入购物页面购物时，负责处理购物请求的服务器程序必须知道处理上一次请求的程序所得到的的用户信息。
    - **作为web服务器，必须能够采用一种机制来唯一地标识一个用户，同时记录该用户的状态。**
  - 会话与会话状态
    - WEB应用中的会话是指一个客户端浏览器与WEB服务器之间连续发生的一系列请求和响应过程。
    - WEB应用的会话状态是指WEB服务器与浏览器在会话过程中产生的状态信息，**借助会话状态，WEB服务器能够把属于同一会话中的一系列的请求和响应过程关联起来。**
  - 如何实现有状态的会话
    - WEB服务器端程序要能从大量的请求消息中区分出哪些请求消息属于同一个会话，即能识别出来自同一个浏览器的访问请求，这**需要浏览器对其发出的每个请求消息都进行标识**：属于同一个会话中的请求消息都附带同样的标识号，而属于不同会话的请求消息总是附带不同的标识号，这个标识号就称为会话ID（**SessionID**）。
    - 在Servlet规范中，常用一下两种机制完成会话跟踪
      - Cookie
      - Session

- Cookie机制

  - cookie机制采用的是在**客户端保持HTTP状态信息的方案**。

  - Cookie是在浏览器访问WEB服务器的某个资源时，**由WEB服务器在HTTP响应消息头中附带传送给浏览器的一个小文本文件。**

  - 一旦WEB浏览器保存了某个Cookie，那么它在以后每次访问该WEB服务器时，**都会在HTTP请求头中将这个Cookie回传给WEB服务器。**

  - 底层的实现原理：WEB服务器通过在HTTP响应消息中**增加Set-Cookie响应头**字段将Cookie信息发送给浏览器，浏览器则通过在HTTP请求消息中**增加Cookie请求头**字段将Cookie回传给WEB服务器。

  - 一个Cookie只能标识一种信息，它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）

  - 一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie。

  - 浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。

  - Cookie的传送过程示意图

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200502131748436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 查看cookie内容

  - cookie.jsp

    ```jsp
    <%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/5/2
      Time: 13:22
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" session="false" language="java" %>
    <html>
    <head>
        <title>Title</title>
    </head>
    <body>
    <%
        // 在javaweb规范中使用Cookie类代表cookie
        // 1. 获取Cookie
        Cookie[] cs = request.getCookies();
        if (cs != null && cs.length > 0) {
            for (Cookie cc : cs) {
                // 2. 获取cookie的名字和值
                out.print(cc.getName() + ": " + cc.getValue());
                out.print("<br>");
            }
        } else {
            // 若没有cookie，则创建一个返回
            out.print("没有一个cookie，正在创建并返回...");
            // 1. 创建一个Cookie对象
            Cookie cookie = new Cookie("name", "liyingjun");
            // 设置cookie的最大时效，以秒为单位，若为0，表示立即删除该cookie
            // 若为负数，表示不存储该cookie，若为正数，表示该cookie的存储时间。
            cookie.setMaxAge(30);
    
            // 2. 调用response的一个方法，把cookie传给客户端
            response.addCookie(cookie);
        }
    %>
    
    </body>
    </html>
    ```

  - 第一次请求请求内容中没有cookie请求头，响应中有set-cookie

    ![image-20200502133820227](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200502133820227.png)

  - 再次访问后，请求内容中就有了cookie请求头

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020050213390791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
    
  - Servlet API中提供了一个javax.servlet.http.Cookie类来封装Cookie信息，它包含有生成Cookie信息和提取Cookie信息的各个属性的方法。

    - 构造方法：`public Cookie(String name, String value)`
    - getName方法
    - setValue与getValue方法
    - setMaxAge与getMaxAge方法
    - setPath和getPath方法

  - HttpServletResponse接口中定义了一个addCookie方法，它用于在发送给浏览器的HTTp响应消息中增加一个Set-Cookie响应头字段。

  - HttpServletRequest接口中定义了一个getCookies方法，它用于从HTTP请求消息的Cookie请求头字段中读取所有的Cookie项。

- Cookie的发送

  1. 创建Cookie对象
  2. 设置最大时效
  3. 将Cookie放入到HTTP响应报头
     - 如果创建了一个Cookie，并将它发送到浏览器，默认情况下它是一个会话级别的cookie，存储在浏览器的内存中，用户推出浏览器之后被删除。若希望浏览器将该cooke存储在磁盘上，则需要使用maxAge，并给出一个以秒为单位的时间。**将最大时效设为0则是命令浏览器删除该cookie。**
     - 发送cookie需要使用HttpServletResponse的addCookie方法，将cookie插入到一个set-cookie的HTTP响应报头中。由于这个方法并不修改任何之前指定的set-cookie报头，而是创建新的报头，因此将这个方法称之为addCookie而不是setCookie。

- 会话coookie和持久cookie的区别

  - 如果不设置过期时间，则表示这个cookie声明周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命周期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。
  - 如果设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。
  - 存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存的cookie，不同的浏览器有不同的处理方式。

- Cookie的读取

  - 调用request.getCookies方法获取浏览器发送来的cookie，需要调用HttpServletRequest的getCookie方法，这个调用返回Cookie对象的数组，对应由Http请求中Cookie报头输入的值。
  - 对数组进行循环，调用每个cookie 的getName方法，直到找到感兴趣的cookie为止

### 7.1 实现自动登录





------

我的CSDN：https://blog.csdn.net/qq_21579045

我的博客园：https://www.cnblogs.com/lyjun/

我的Github：https://github.com/TinyHandsome

纸上得来终觉浅，绝知此事要躬行~

欢迎大家过来OB~

by 李英俊小朋友
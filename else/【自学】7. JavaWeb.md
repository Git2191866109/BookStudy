# 尚硅谷JavaWeb学习笔记

[TOC]

## 写在前面

学习链接：[Java Web 视频教程全集（103P）](https://www.bilibili.com/video/av59545633/)

**特别注意**：该内容全是我自学时，一边听课一边做的笔记，本文的初衷是**希望每一个学习时有疑问的同学能够在这篇文章里找到答案**；里面关于吐槽的内容仅代表个人看法，白嫖党不会针对任何老师或书籍发表不合适的看法，如有冒犯，请见谅。所有传播知识的行为都应该受到尊重，该内容涉及的一切只为学习交流使用，希望每个求知进来的读者都可以满载而归。有任何问题或侵权行为，请联系本人**李英俊小朋友**，我会回应并删除；另外，做笔记真的不容易，希望大家转载时标明作者，若非个人使用的转载，请联系本人，否则必究。

学习体会：

## 1. 前言

- 在Sun的JavaServlet规范中：JavaWeb应用由一组Servlet、HTML页、类、以及其他可以被绑定的资源构成。它可以在各种供应商提供的**实现Servlet规范的Servlet容器中运行**。

- JavaWeb应用中可以包含如下内容：

  - Servlet
  - JSP
  - 实用类
  - 静态文档如HTML、图片等
  - 描述Web应用的信息（web.xml）

- Servlet与Servlet容器

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409124223247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- Servlet容器的概念

  - Servlet容器为JavaWeb应用提供运行时的环境，它负责管理Servlet和JSP的生命周期，以及管理它们的共享数据。
  - Servlet容器也称为JavaWeb应用容器，或者Servlet/HSP容器。
  - 目前最流行的Servlet容器软件包括：
    - Tomcat
    - Resin
    - J2EE服务器（如Weblogic）中也提供了内置的Servlet容器

- **Tomcat**：Apache、Sun和其他一些公司及个人共同开发完成。

  - Tomcat的目录层次结构

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409125526469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - 运行Tomcat

    1. 配置java_home或jre_home（这一步我能运行哈哈哈哈，我用的tomcat9）
    2. 双击bin目录下的startup.bat文件
    3. 在地址栏中输入http://localhost:8080/
    4. 若已经启动了一个Tomcat应用，若再启动同一个Tomcat应用，则会抛出异常（这是因为端口被占用了）

  - 关闭Tomcat&配置Tomcat的端口号

    1. 双击bin目录下的shutdown.bat文件关闭Tomcat服务器

    2. 修改Tomcat默认的端口号：

       - 打开conf目录下的server.xml文件
       - 修改端口号

       ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409130844768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - catalina：可以通过设置catalina_home环境变量的方式来通过dos启动关闭tomcat

    - 为了可以在任意目录下启动Tomcat服务器

    1. 把Tomcat的bin目录添加到path下（但是这样添加成功会，通过startup启动Tomcat会有提示：catalina的环境变量没有正确设置）
    2. 设置CATALINA_HOME环境变量：
       1. 通过阅读startup.bat文件可知，该环境变量下有一个bin目录，而bin目录下又有一个catalina.bat文件，由此可知CATALINA_HOME指向的应该是Tomcat安装的根目录
       2. 于是把Tomcat的根目录设为CATALINA_HOME环境变量
       3. 此时即可以在任意根目录下通过startup.bat、shutdown.bat启动、关闭Tomcat服务器
       4. 继续阅读startup.bat文件，发现启动tomcat服务器的是catalina.bat文件，在命令行窗口直接输入catalina会有各种命令的提示，出现各种可选参数。
       5. 常用的有：run（同窗口启动服务器）、start（新窗口启动服务器）、stop（关闭服务器）

  - Tomcat的管理程序

    - Tomcat提供了一个管理程序：manager，用于部署到Tomcat服务器中的web应用程序
    - 要访问manager web应用程序，需要添加具有管理员权限的账号，编辑conf目录下的**tomcat-users.xml**文件，添加manager角色，设置用户名和密码
    - **注意**：这里我在操作的时候，发现我用的是tomcat9嘛，所以跟视频里面将的不一样，设置的时候发现仅仅设置manager是不行的，并且**tomcat-users.xml**文件中也说了不同的用户对应着不同的管理权限，不像以前直接manager用户管所有了，因此为了解决这个问题查了百度，[参考链接](http://blog.sina.com.cn/s/blog_6ac4c6cb0101485d.html)，这样就解决了。另外，不能像视频中设置用户和密码为空，不然一直弹框也进不去。

## 2. Web程序结构

- 一个web应用程序是由一组Servlet，HTML页面，类，以及其他的资源组成的运行在web服务器上的完整的应用程序，以一种结构化的有层次的目录形式存在。

- 组成web应用程序的这些文件要部署在相应的目录层次中，根目录代表整个web应用程序的“根”。

- 通常将web应用程序的目录放在webapps目录下，在webapps目录下的每一个子目录都是一个独立的web应用程序，子目录的名字就是web应用程序的名字，也就是web应用程序的“根”。用户通过web应用程序的“根”来访问web应用程序中的资源。

- Servlet规范汇总定义了web应用程序的目录层次

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409153613329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- **注意**：跟着视频在创建jsp文件的时候，我发现并没有这个新建这个文件的选择，网上搜了搜方法，据说是：“IDEA认为我这个包建的有问题，才导致这地方不应该创建jsp文件，所以就没有创建JSP文件的选项。” [参考连接](https://blog.csdn.net/weixin_44381073/article/details/89816624)，采用这个方法之后就可以新建jsp文件了。

- JSP(Java Server Pages)是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。

- 第一个WEB应用程序：开发，并部署到Tomcat服务器下运行

  1. 新建一个JavaProject
  2. 在Java项目下创建WEB开发的目录结构
     - WebContent
       - WEN-INF
         - classes 编译后的class文件必须放在该目录下
         - lib
         - web.xml （从Tomcatwebapps\docs\WEB-INFO中复制过来，可以不做修改）
       - html 页面
       - jsp 页面
       - 图片。。。
  3. 在src下新建一个Person类
  4. 手工的Person类对应的Class文件（含包）复制到classes目录下
     - 可以通过修改默认的输出目录达到自动把编译好的class放到classes目录下
     - 由于视频中是eclipse操作的，因此我搜了一下idea的[操作方法](https://www.cnblogs.com/dslx/p/10172602.html)
  5. 在WebContent目录下新建一个JSP文件
  6. 把WebContent目录复制到Tomcat的webapps目录下，并改名为helloworld
  7. 在浏览器的地址栏中输入http://localhost:8080/WebContent/hello.jsp即可看到命令行打印的信息
  8. 使用【配置任意目录下Web应用程序2】的方式建立.xml文件，实现直接部署

- 配置任意目录下Web应用程序1

  - 在Web服务器中可以配置虚拟目录，而虚拟目录所对应的真实目录可以在任何路径下
  - 在Tomcat服务器中，主要在XML配置文件中通过`<Context>`元素的设置来完成的。一个`<Context>`元素就表示一个Web应用程序，运行在特定的虚拟主机中
  - `<Context>`元素是`<Host>`元素的子元素，可以在conf\server.xml文件中设置Context元素
  - 使用docBase属性指定Web应用程序的真实路径。将属性reloadable设置为true，Tomcat在运行时会自动监测Servlet类的改动，如果发现有类被更新，Tomcat服务器将自动重新加载该Web应用程序。这样，在开发时，就不需要频繁重启Tomcat了。

- 配置任意目录下Web应用程序2（超酷）

  - 还可以在conf目录下一次创建Catalina\localhost目录，然后在localhost目录下为test这个Web应用程序建立test.xml文件，编辑这个文件输入以下内容`<Context path="/test" docBase="c:/test" reloadable="true">`
  - 从Tomcat5开始，**不建议直接在server.xml文件中配置`<Context>`元素**，因为server.xml文件作为Tomcat的主要配置文件，一旦Tomcat启动后，将不会再读取这个文件，因此无法在Tomcat服务器启动时发布Web应用程序。如果在其他地方配置`<Context>`元素，那么在Tomcat运行时，也可以发布Web应用程序。
  - 从Tomcat5.5开始，在\conf\Catalina\localhost目录下创建XML配置文件来配置Web应用程序，**Tomcat将以XML文件的文件名作为Web应用程序的上下文路径**，而不会理会在`<Context>`元素的path属性中指定的上下文路径是什么。由于Tomcat5.5之后的版本是以XML配置文件的文件名作为Web应用程序的上下文路径的，因此在配置`<Context>`元素时，可以不使用path属性。

- 文件修改为helloworld2.xml

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <Context path="/test2" docBase="F:/BookStudy/else/JavaWebPro/WebContent" reloadable="true"/>
  ```

- 上述内容的解释

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409173352178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- **之前没有实现自动化的结果这里就不展示了**

- 自动化包含了两个，具体实现方法在上面

  - 一是将class输出的位置放到WebContent/WEB-INF/classes下
  - 二是通过配置任意目录下Web应用程序（使用第2种方法），把后面的原路径映射道虚拟路径上，实现实时更新项目的目的，这样修改了原始项目的内容，也可以不用重启Tomcat直接展示最新的结果。

- 报错问题：

  - org.apache.jasper.JasperException: Unable to compile class for JSP:
  - JSP出现 类名 cannot be resolved to a type
  - 上面两种问题是同一页面出现的。。。我查了一万个方法。。。最后发现是WEB-INF写成WEB-INFO了
  - 所以出了问题的第一件事情，一定要从自己这里找原因。。。哭！

- 最后运行成功的图如下：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409171814200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

## 3. 使用Eclipse / Idea开发JavaWeb项目

- [Idea配置1](https://blog.csdn.net/With_Her/article/details/89243777?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)、[Idea配置2](https://blog.csdn.net/chenshun123/article/details/51285890)

- Eclipse配置：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410120252614.png)

## 4. Servlet

- Java Servlet是和平台无关的服务器端组件，它运行在Servlet容器中。Servlet容器负责Servlet和客户的通信以及调用Servlet的方法，Servlet和客户的通信采用“请求/响应”的模式。

- Server Applet

- Servlet可完成如下功能：

  - 创建并返回基于客户请求的动态HTML页面
  - 创建可嵌入到现有HTML页面中的部分HTML页面（HTML片段）。
  - 与其它服务器资源（如数据库或基于Java的应用程序）进行通信。

- Servlet容器响应客户请求的过程

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410120926345.png)

- Servlet API

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410121212144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 4.1 第一个Servlet程序

- 问题：我在操作的时候，发现不能implements Servlet，网上查了查，说是没有导入对应的包

- [解决方法](https://www.cnblogs.com/ifeil/p/9378921.html)：实际上就是在Modules中的项目里的Dependences中+上Tomcat的library

- 问题：在启动自己的HelloServlet时，输出中文为乱码

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410123530828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- [解决方法](https://www.cnblogs.com/chenxianbin/p/11367954.html)：早Tomcat的conf路径下修改logging.properties文件中，将下图的位置的UTF-8改为GBK

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020041012373535.png)

- 问题：xml文件在写的时候，如何优雅的注释

- [解决方法](https://blog.csdn.net/weixin_33889245/article/details/94303669)：CTRL + SHIFT + / 直接调出注释

- **自己的解决方法**：我自己做了一个Live Template：输入<然后回车就会直接生成注释

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410125509301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- Servlet的HelloWorld

  1. 创建一个Servlet接口的实现类（记住这个时候要导入Tomcat的library，[参考链接](https://blog.csdn.net/weixin_44319545/article/details/100544309)）

  2. 在web.xml文件中配置和映射这个Servlet（目的是希望能够通过浏览器去访问java类）

     ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410124301987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 具体实现

  - HelloServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: HelloServlet.java
     * @time: 2020/4/10 12:20
     * @desc: |
     */
    
    public class HelloServlet implements Servlet {
    
        public HelloServlet() {
            System.out.println("HelloServlet构造器已启动...");
        }
    
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            System.out.println("初始化中...");
        }
    
        @Override
        public ServletConfig getServletConfig() {
            System.out.println("获取Servlet配置中...");
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            System.out.println("服务中...");
        }
    
        @Override
        public String getServletInfo() {
            System.out.println("获取Servlet信息中...");
            return null;
        }
    
        @Override
        public void destroy() {
            System.out.println("毁灭中...");
        }
    }
    ```

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
        <!-- 配置和映射Servlet -->
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.HelloServlet</servlet-class>
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello</url-pattern>
        </servlet-mapping>
    </web-app>
    ```

### 4.2 Servlet配置及生命周期方法

- Servlet容器：运行Servlet、JSP、Filter等的软件环境
  - 可以来创建Servlet，并调用Servlet的相关生命周期方法
  - JSP，Filter，Listener，Tag…
- Servlet生命周期的方法：以下方法都是由Servlet容器负责调用
  - 构造器方法：只被调用一次，只有第一次请求Servlet时，创建Servlet的实例，调用构造器。（这说明Servlet是单实例的）
  - init方法：只被调用一次，在创建好实例后立即被调用，用于初始化当前Servlet。
  - service：被多次调用。每次请求都会调用service方法，实际用于相应请求的。
  - destroy：只被调用一次，在当前Servlet所在的WEB应用被卸载前调用，用于释放当前Servlet所占用的资源。
- load-on-startup参数
  - 配置在Servlet节点中
  - load-on-startup：可以指定Servlet被创建的时机，若为负数，则在第一次请求时被创建。若为0或正数，则在当前WEB应用被Servlet容器被加载时创建实例，且数值越小越早被创建。负数，则不创建。
- Servlet容器响应客户请求的过程
  1. Servlet引擎检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第4步，否则，执行第2步
  2. 装载并创建该Servlet的第一个实例对象：调用该Servlet的构造器
  3. 调用Servlet实例对象的init()方法
  4. 创建一个用于封装请求的ServletRequest对象和一个代表响应消息的ServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传进去
  5. WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法
- Servlet的注册于运行
  - Servlet程序必须通过Servlet容器来启动运行，并且存储目录有特殊要求，通常需要存储在`<WEB应用程序目录>\WEB-INF\classes\`目录中。
  - Servlet程序必须在WEB应用程序的web.xml文件中进行注册和映射其访问路径，才可以被Servlet引擎加载和被外界访问。
  - 一个`<servlet>`元素用于注册一个Servlet，它包含有两个主要的子元素：
    - `<servlet-name>`：用于设置Servlet的注册名称
    - `<servlet-class>`：用于设置Servlet的完整类名
  - 一个`<servlet-mapping>`元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：
    - `<servlet-name>`：用于设置Servlet的注册名称
    - `<url-pattern>`：用于设置Servlet的对外访问路径
- Servlet映射的细节
  - 同一个Servlet可以被映射到多个URL上，即多个`<servlet-mapping>`元素的`<servlet-name>`子元素的设置值可以是同一个Servlet的注册名
  - 在Servlet映射到的URL中也可以使用`*`通配符，但是只能有两种固定的格式：一种是`*.扩展名`，另一种格式是以正斜杠`/`开头并以`/*`结尾
  - 注意：`/*.扩展名`，即既带/又带扩展名的不合法

### 4.3 ServletConfig & ServletContext

- 封装了Servlet的配置信息，并且可以获取ServletContext对象（ServletConfig获取的是该Servlet的初始化参数，ServletContext中可以获取全局的初始化参数）
  1. 配置Servlet的初始化参数
  2. 获取初始化参数：
     - getInitParameter(String name)：获取指定参数名的初始化参数
     - getInitParameterNames()：获取参数名组成的Enumeration对象
  3. 获取Servlet的配置名称
  4. getServletContext
     - Servlet引擎为 **每个WEB应用程序** 都创建一个对应的ServletContext对象，ServletContext对象被包含在ServletConfig对象中，调用ServletConfig.getServletContext方法可以返回ServletContext对象的应用。
     - **由于一个WEB应用程序中的所有Servlet都共享同一ServletContext对象**，所以，ServletContext对象被称为application对象（Web应用程序对象）
     - 功能：
       - 获取WEB应用程序的初始化参数
       - 记录日志
       - application域范围的属性
       - 访问资源文件
       - 获取虚拟路径所映射的本地路径
       - WEB应用程序之间的访问
       - ServletContext的其他方法

- 代码

  - HelloServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    import java.io.InputStream;
    import java.util.Enumeration;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: HelloServlet.java
     * @time: 2020/4/10 12:20
     * @desc: |
     */
    
    public class HelloServlet implements Servlet {
    
        public HelloServlet() {
            System.out.println("HelloServlet构造器已启动...");
        }
    
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            // 1. ServletConfig
            // 针对Servlet的初始化参数
            System.out.println("初始化中...");
            String user = servletConfig.getInitParameter("user");
            System.out.println("user: " + user);
            Enumeration<String> names = servletConfig.getInitParameterNames();
            while(names.hasMoreElements()){
                String name = names.nextElement();
                String value = servletConfig.getInitParameter(name);
                System.out.println(name + "-->" + value);
            }
            String servletName = servletConfig.getServletName();
            System.out.println(servletName);
    
            // 2. ServletContext
            // 针对app的初始化参数，相较于上面，该参数适用于所有Servlet，相当于全局的参数
            // 2.1 获取ServletContext对象
            ServletContext sc = servletConfig.getServletContext();
            // 获取WEB应用程序的初始化参数
            String driver = sc.getInitParameter("driver");
            System.out.println("driver: " + driver);
            Enumeration<String> names2 = sc.getInitParameterNames();
            while(names2.hasMoreElements()){
                String name = names2.nextElement();
                String value = sc.getInitParameter(name);
                System.out.println(name + "-->" + value);
            }
    
            // 2.2 获取当前WEB应用的某一个文件在服务器上的绝对路径：
            String realPath = sc.getRealPath("/index.jsp");
            System.out.println(realPath);
    
            // 2.3 获取当前WEB应用的名称
            String contextPath = sc.getContextPath();
            System.out.println(contextPath);
    
            // 2.4 获取当前WEB应用的某一个文件对应的输入流
            // path的 / 响度与当前WEB应用的根目录
            try {
                ClassLoader cl = getClass().getClassLoader();
                InputStream is = cl.getResourceAsStream("jdbc.properties");
                System.out.println("1. " + is);
    
                InputStream is2 = sc.getResourceAsStream("jdbc.properties");
                System.out.println("2. " + is2);
    
                InputStream is3 = sc.getResourceAsStream("/WEB-INF/classes/jdbc.properties");
                System.out.println("3. " + is3);
            } catch (Exception e) {
                e.printStackTrace();
            }
    
            // 2.5 和attribute相关的几个方法
    
        }
    
        @Override
        public ServletConfig getServletConfig() {
            System.out.println("获取Servlet配置中...");
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            System.out.println("服务中...");
        }
    
        @Override
        public String getServletInfo() {
            System.out.println("获取Servlet信息中...");
            return null;
        }
    
        @Override
        public void destroy() {
            System.out.println("毁灭中...");
        }
    }
    ```

  - SecondServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: SecondServlet.java
     * @time: 2020/4/11 10:11
     * @desc: |
     */
    
    public class SecondServlet implements Servlet {
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            System.out.println("第二次Servlet初始化");
        }
    
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
    
        }
    
        @Override
        public String getServletInfo() {
            return null;
        }
    
        @Override
        public void destroy() {
    
        }
    }
    ```

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
        <!-- 配置和映射Servlet -->
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.HelloServlet</servlet-class>
    
            <!-- 配置Servlet的初始化参数，且节点必须在load-on-startup节点的前面 -->
            <init-param>
                <!-- 参数名 -->
                <param-name>user</param-name>
                <!-- 参数值 -->
                <param-value>root</param-value>
            </init-param>
            <init-param>
                <param-name>password</param-name>
                <param-value>1230</param-value>
            </init-param>
    
            <!-- 可以指定Servlet被创建的时机 -->
            <load-on-startup>5</load-on-startup>
    
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello</url-pattern>
        </servlet-mapping>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello2</url-pattern>
        </servlet-mapping>
    
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>secondServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.SecondServlet</servlet-class>
            <!-- 可以指定Servlet被创建的时机 -->
            <load-on-startup>2</load-on-startup>
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>secondServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>*.html</url-pattern>
        </servlet-mapping>
    </web-app>
    ```


## 5. HTTP简介

- WEB浏览器与WEB浏览器之间的一问一答的交互过程，必须遵循一定的规则，这个规则就是HTTP协议

- HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是TCP/IP协议集中的一个应用层协议，**用于定义WEB浏览器与WEB浏览器之间交换数据的过程以及数据本身的格式**。

- HTTP协议的版本HTTP/1.0、HTTP/1.1、HTTP-NG

- HTTP的会话方式：

  - 四个步骤：建立连接、发出请求信息、回送响应信息、关闭连接
  - 浏览器与WEB服务器的连接过程是短暂的，每次连接只处理一个请求和响应。对每一个页面的访问，浏览器与WEB服务器都要建立一次单独的连接。
  - 浏览器到WEB服务器之间的所有通讯都是完全独立分开的请求和响应对。

- 浏览器范文多图网页的过程

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412145427186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- HTTP请求消息

  - 请求消息的结果：**一个请求行、若干消息头以及实体内容**，其中一些消息头和实体内容都是可选的，消息头和实体内容之间要用空行隔开。

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412145629979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- HTTP响应信息

  - 响应信息的结构：**一个状态行、若干消息头、以及实体内容**，其中一些消息头和实体内容都是可选的，消息头和实体内容之间要用空行隔开。

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412145820158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 其他细节

  - 响应消息的实体内容就是网页文件的内容，也就是在浏览器中使用查看源文件的方式所看到的内容
  - 一个使用GET方式的请求消息中不能包含实体内容，只有使用POST、PUT和DELETE方式的请求消息中才可以包含实体内容。

- 使用GET和POST方式传递参数

  - 在URL地址后面还可以附加一些参数

  - GET方式：

    - 传输的数据量是有限的，一般限制在1KB以下。
    - 在浏览器地址栏中输入某个URL地址或单击网页上的一个超链接时，浏览器发出的HTTP请求消息的请求方式为GET
    - 如果网页中的`<form>`表单元素的method属性被设置为了“GET”，浏览器提交这个FROM表单时生成的HTTP请求消息方式也为GET
    - 使用GET请求方式给WEB服务器传递参数的格式：`xxx?name=l&pwd=123`

  - POST方式：

    - POST方式将各个表单字段元素及其数据作为HTTP消息的实体内容发送给WEB服务器。传送的数据量要比GET方式传送的数据量大得多。

    - POST请求方式主要用于向WEB服务器端程序提交FORM表单中的数据。

    - 格式：

      ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412152046412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)


## 6. ServletRequest & ServletResponse

- 如何在Servlet中获取请求信息：

  - Servlet的service()方法用于应答请求：因为每次请求都会调用service()方法

- ServletRequest：封装了请求信息，可以从中获取到任何的请求信息。

- ServletResponse：封装了响应信息，如果想给用户什么响应，均可以使用该接口的方法实现。

- 这两个接口的实现类都是服务器给予实现的，并在服务器调用service方法时传入。

>  问题1：在实验的时候我发现了一个大问题，就是每次改了代码之后，都需要重启Servlet才能行。
>
>  解决方案：[参考链接](https://blog.csdn.net/Jodie_Girl/article/details/103597872)，我在参考连接的基础上对Tomcat的配置进行了修改，也就是如图所示的部分，全部修改为update classes and resources
>  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413120914681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
>
>  问题2：IDEA中重新启动一共有四种选择，分别是什么意思
>  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413122116504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
>
>  解决方案：[参考连接](https://blog.csdn.net/qq_40871734/article/details/99749715)，我发现选择重新部署，也就是第三个，才能起到刷新java类的效果

- ServletRequest：

  - 获取请求参数：
    - String getParameter(String name)：根据请求参数的名字，返回参数值（若请求参数有多个值，如checkbox，该方法只能获取到第一个提交的值）。
    - Map getParameterMap()：返回请求参数的键值对：Key：参数名；Value：参数值，String数组类型。
    - Enumeration getParameterNames()：返回参数名对应的Enumeration对象，类似于ServletConfig(或ServletContext)的getInitParameterNames()方法。
    - String[] getParameterValues(String name)：根据请求参数的名字，返回请求参数对应的字符串数组
    
  - 流程图
  
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413120207777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
  
- HttpServletRequest：是ServletRequest的子接口，针对HTTP请求所定义。里边包含了大量获取HTTP请求的方法

  - 获取请求的URL：HttpServletRequest.getRequestURI()，结果示例：`/app2/loginServLet`
  - 获取请求的方式：HttpServletRequest.getMethod()，结果示例：`GET`
  - 获取请求参数的字符串：HttpServletRequest.getQueryString()，结果示例：`user=111&password=333&interesting=reading&interesting=game&interesting=party`
  - 获取Servlet的映射路径：HttpServletRequest.getServletPath()，结果示例：`/loginServLet`
  - 和attribute相关的几个方法

- ServletResponse

  - getWriter()：返回PrintWriter对象，调用该对象的print()方法，将把print()中的参数直接打印到客户的浏览器上。
  - setContentType()：设置响应的内容类型。

- HttpServletResponse：跟HttpServletRequest同理，有一个超重要的方法

  - void sendRedirect(String location)：请求的重定向。（此方法为HttpServletResponse中定义，因此使用时需要强转）

- 上述的实现代码

  - LoginServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import java.io.IOException;
    import java.io.PrintWriter;
    import java.util.Arrays;
    import java.util.Enumeration;
    import java.util.Map;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LoginServlet.java
     * @time: 2020/4/13 11:45
     * @desc: |
     */
    
    public class LoginServlet implements Servlet {
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
    
        }
    
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            System.out.println("请求来了！");
            System.out.println(servletRequest);
    
            String user = servletRequest.getParameter("user");
            String psd = servletRequest.getParameter("password");
            System.out.println(user + "-->" + psd);
    
            String interesting = servletRequest.getParameter("interesting");
            System.out.println(interesting);
    
            String[] interestings = servletRequest.getParameterValues("interesting");
            System.out.println(interestings);
            for(String a: interestings){
                System.out.println(a);
            }
    
            Enumeration<String> names = servletRequest.getParameterNames();
            while(names.hasMoreElements()){
                String name = names.nextElement();
                String val = servletRequest.getParameter(name);
    
                System.out.println("3. " + name + ": " + val);
            }
    
            Map<String, String[]> map = servletRequest.getParameterMap();
            for(Map.Entry<String, String[]> entry: map.entrySet()){
                System.out.println("4. " + entry.getKey() + ": " + Arrays.asList(entry.getValue()));
            }
    
            HttpServletRequest hsr = (HttpServletRequest) servletRequest;
            String requestURI = hsr.getRequestURI();
            System.out.println(requestURI);
    
            String method = hsr.getMethod();
            System.out.println(method);
    
            String qs = hsr.getQueryString();
            System.out.println(qs);
    
            String sp = hsr.getServletPath();
            System.out.println(sp);
    
            // 设置响应的内容类型：这里设置成word格式，那么submit之后会让你下载一个文件，文件可以用word打开，内容是write中的内容。
            servletResponse.setContentType("application/msword");
    
            PrintWriter out = servletResponse.getWriter();
            out.println("What are you talking about?");
    
        }
    
        @Override
        public String getServletInfo() {
            return null;
        }
    
        @Override
        public void destroy() {
    
        }
    }
    ```

  - login.html

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
    <form action="loginServLet" method="get">
        user: <input type="text" name="user">
        password: <input type="password" name="password">
    
        <br><br>
    
        interesting:
        <input type="checkbox" name="interesting" value="reading" />Reading
        <input type="checkbox" name="interesting" value="game" />Game
        <input type="checkbox" name="interesting" value="party" />Party
        <input type="checkbox" name="interesting" value="shopping" />Shopping
        <input type="checkbox" name="interesting" value="sport" />Sport
        <input type="checkbox" name="interesting" value="tv" />TV
    
        <input type="submit" value="submit"/>
    </form>
    
    </body>
    </html>
    ```

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
    
        <!-- 获取WEB应用程序的初始化参数 -->
        <context-param>
            <param-name>driver</param-name>
            <param-value>com.mysql.cj.jdbc.Driver</param-value>
        </context-param>
    
        <context-param>
            <param-name>jdbcUrl</param-name>
            <param-value>jdbc:mysql://localhost:3306/testjdbc?serverTimezone=GMT%2B8</param-value>
        </context-param>
    
        <!-- 配置和映射Servlet -->
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.HelloServlet</servlet-class>
    
            <!-- 配置Servlet的初始化参数，且节点必须在load-on-startup节点的前面 -->
            <init-param>
                <!-- 参数名 -->
                <param-name>user</param-name>
                <!-- 参数值 -->
                <param-value>root</param-value>
            </init-param>
            <init-param>
                <param-name>password</param-name>
                <param-value>1230</param-value>
            </init-param>
    
            <!-- 可以指定Servlet被创建的时机 -->
            <load-on-startup>5</load-on-startup>
    
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello</url-pattern>
        </servlet-mapping>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello2</url-pattern>
        </servlet-mapping>
    
    <!--    <servlet>-->
    <!--        &lt;!&ndash; Servlet 注册的名字 &ndash;&gt;-->
    <!--        <servlet-name>secondServlet</servlet-name>-->
    <!--        &lt;!&ndash; Servlet 的全类名 &ndash;&gt;-->
    <!--        <servlet-class>com.litian.test.SecondServlet</servlet-class>-->
    <!--        &lt;!&ndash; 可以指定Servlet被创建的时机 &ndash;&gt;-->
    <!--        <load-on-startup>2</load-on-startup>-->
    <!--    </servlet>-->
    
    <!--    <servlet-mapping>-->
    <!--        &lt;!&ndash; 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 &ndash;&gt;-->
    <!--        <servlet-name>secondServlet</servlet-name>-->
    <!--        &lt;!&ndash; 映射具体的访问路径：/ 代表当前WEB应用的根目录 &ndash;&gt;-->
    <!--        <url-pattern>*.html</url-pattern>-->
    <!--    </servlet-mapping>-->
    
        <servlet>
            <servlet-name>loginServlet</servlet-name>
            <servlet-class>com.litian.test.LoginServlet</servlet-class>
        </servlet>
    
        <servlet-mapping>
            <servlet-name>loginServlet</servlet-name>
            <url-pattern>/loginServLet</url-pattern>
        </servlet-mapping>
    
    </web-app>
    ```

## 7. GenericServlet

> 小题目：在web.xml文件中设置两个WEB应用的初始化参数，user，password；定义一个login.html，里边定义两个请求字段：user，password，发送请求到loginServlet；再创建一个LoginServlet，在其中获取请求的user，password。比对其和web.xml文件中定义的请求参数是否一致，若一致，响应Hello：xxx；若不一致，响应Sorry：xxx；xxx为user。

- 新建一个工程来实现上述问题

  - 配置Tomcat和一系列设置

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
        <!-- 配置当前WEB应用的初始化参数 -->
        <context-param>
            <param-name>user</param-name>
            <param-value>litian</param-value>
        </context-param>
    
        <context-param>
            <param-name>password</param-name>
            <param-value>123</param-value>
        </context-param>
    
        <!-- 配置Servlet -->
        <servlet>
            <servlet-name>log</servlet-name>
            <servlet-class>com.litian.test.LoginServlet</servlet-class>
        </servlet>
    
        <servlet-mapping>
            <servlet-name>log</servlet-name>
            <url-pattern>/LoginServlet</url-pattern>
        </servlet-mapping>
    </web-app>
    ```

  - login.html

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>冲冲冲</title>
    </head>
    <body>
    <form action="LoginServlet" method="post">
        user: <input type="text" name="username"/>
        password: <input type="password" name="password"/>
        <input type="submit" value="Submit"/>
    </form>
    
    </body>
    </html>
    ```

  - LoginServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    import java.io.PrintWriter;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LoginServlet.java
     * @time: 2020/4/13 14:17
     * @desc: |
     */
    
    public class LoginServlet implements Servlet {
        private ServletConfig servletConfig;
    
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            this.servletConfig = servletConfig;
        }
    
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            // 1. 获取请求参数：username和password
            String username = servletRequest.getParameter("username");
            String password = servletRequest.getParameter("password");
    
            // 2. 获取当前WEB应用的初始化参数：user，password
            // 需要使用ServletContext对象
            ServletContext sc = servletConfig.getServletContext();
            String initUser = sc.getInitParameter("user");
            String initPassword = sc.getInitParameter("password");
    
            // 3. 比对
            // 设置中文乱码问题
            servletResponse.setCharacterEncoding("utf-8");
            // 设置响应的内容类型
            servletResponse.setContentType("text/html;charset=utf-8");
    
            PrintWriter out = servletResponse.getWriter();
            if(initUser.equals(username) && initPassword.equals(password)){
                // 4. 打印响应字符
                out.println("Hello: " + username);
            }else{
                out.println("Sorry: " + username + "，你甭想进来！");
            }
        }
    
        @Override
        public String getServletInfo() {
            return null;
        }
    
        @Override
        public void destroy() {
    
        }
    }
    ```

- GenericServlet







------

我的CSDN：https://blog.csdn.net/qq_21579045

我的博客园：https://www.cnblogs.com/lyjun/

我的Github：https://github.com/TinyHandsome

纸上得来终觉浅，绝知此事要躬行~

欢迎大家过来OB~

by 李英俊小朋友
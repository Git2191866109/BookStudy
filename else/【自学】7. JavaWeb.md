# 尚硅谷JavaWeb学习笔记

[TOC]

## 写在前面

学习链接：[Java Web 视频教程全集（103P）](https://www.bilibili.com/video/av59545633/)

**特别注意**：该内容全是我自学时，一边听课一边做的笔记，本文的初衷是**希望每一个学习时有疑问的同学能够在这篇文章里找到答案**；里面关于吐槽的内容仅代表个人看法，白嫖党不会针对任何老师或书籍发表不合适的看法，如有冒犯，请见谅。所有传播知识的行为都应该受到尊重，该内容涉及的一切只为学习交流使用，希望每个求知进来的读者都可以满载而归。有任何问题或侵权行为，请联系本人**李英俊小朋友**，我会回应并删除；另外，做笔记真的不容易，希望大家转载时标明作者，若非个人使用的转载，请联系本人，否则必究。

学习体会：跟以前一样，主要写不足之处，优点就不赘述了，这么多视频选择这一个看，就是优点本身的体现了哈哈哈。

> 1. P11中，关于GenericServlet中为何要写一个init()函数，我是真没搞懂，讲的弯弯绕绕，绕来绕去。先是强行假设了子类中需要出示化的需求，init之后会报错。这个假设我是没想到的，为什么会有这种假设？好吧，就算有吧，那么只要init重写的是带ServletConfig参数的，都肯定会报错啊，写个init又能怎么样呢，让别人初始化就只能用这个init吗？（**这部分主要是啰嗦太多了**，给我绕晕了，简单说的话就容易理解多了）
>
>    这里需要附上重写和重载的区别帮助理解，[参考链接](https://www.runoob.com/java/java-override-overload.html)。百度之后得到的答案是：**为了防止在重载的时候忘记调用super.init(config); 因此写个init()来帮助初始化时增加一些自己的初始化参数**，[参考连接](https://www.cnblogs.com/itmanxgl/p/fbeced7052b9ec29fa5bae652c5ceff4.html)
>
> 2. P12中，关于HttpServlet的doXxx方法讲的我云里雾里的，实在是不知道这个方法具体有什么用
>
>    调用流程是：浏览器发送请求 -> 调用service(servletRequest, servletReponse)方法，该方法将里面的两个传参转化为Http的类 -> 然后再调用service(HttpServletRequest, HttpServletResponse)方法，在这个方法中根据method的不同使用不同的**doMethod()**（即doGet，doPost），而这个方法中的内容需要自己重写。 -> 实现了根据method方式完成不同的功能。[参考链接](https://blog.csdn.net/zhaolang2009/article/details/80678660?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2)
>
>    

## 1. 前言

- 在Sun的JavaServlet规范中：JavaWeb应用由一组Servlet、HTML页、类、以及其他可以被绑定的资源构成。它可以在各种供应商提供的**实现Servlet规范的Servlet容器中运行**。

- JavaWeb应用中可以包含如下内容：

  - Servlet
  - JSP
  - 实用类
  - 静态文档如HTML、图片等
  - 描述Web应用的信息（web.xml）

- Servlet与Servlet容器

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409124223247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- Servlet容器的概念

  - Servlet容器为JavaWeb应用提供运行时的环境，它负责管理Servlet和JSP的生命周期，以及管理它们的共享数据。
  - Servlet容器也称为JavaWeb应用容器，或者Servlet/HSP容器。
  - 目前最流行的Servlet容器软件包括：
    - Tomcat
    - Resin
    - J2EE服务器（如Weblogic）中也提供了内置的Servlet容器

- **Tomcat**：Apache、Sun和其他一些公司及个人共同开发完成。

  - Tomcat的目录层次结构

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409125526469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - 运行Tomcat

    1. 配置java_home或jre_home（这一步我能运行哈哈哈哈，我用的tomcat9）
    2. 双击bin目录下的startup.bat文件
    3. 在地址栏中输入http://localhost:8080/
    4. 若已经启动了一个Tomcat应用，若再启动同一个Tomcat应用，则会抛出异常（这是因为端口被占用了）

  - 关闭Tomcat&配置Tomcat的端口号

    1. 双击bin目录下的shutdown.bat文件关闭Tomcat服务器

    2. 修改Tomcat默认的端口号：

       - 打开conf目录下的server.xml文件
       - 修改端口号

       ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409130844768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - catalina：可以通过设置catalina_home环境变量的方式来通过dos启动关闭tomcat

    - 为了可以在任意目录下启动Tomcat服务器

    1. 把Tomcat的bin目录添加到path下（但是这样添加成功会，通过startup启动Tomcat会有提示：catalina的环境变量没有正确设置）
    2. 设置CATALINA_HOME环境变量：
       1. 通过阅读startup.bat文件可知，该环境变量下有一个bin目录，而bin目录下又有一个catalina.bat文件，由此可知CATALINA_HOME指向的应该是Tomcat安装的根目录
       2. 于是把Tomcat的根目录设为CATALINA_HOME环境变量
       3. 此时即可以在任意根目录下通过startup.bat、shutdown.bat启动、关闭Tomcat服务器
       4. 继续阅读startup.bat文件，发现启动tomcat服务器的是catalina.bat文件，在命令行窗口直接输入catalina会有各种命令的提示，出现各种可选参数。
       5. 常用的有：run（同窗口启动服务器）、start（新窗口启动服务器）、stop（关闭服务器）

  - Tomcat的管理程序

    - Tomcat提供了一个管理程序：manager，用于部署到Tomcat服务器中的web应用程序
    - 要访问manager web应用程序，需要添加具有管理员权限的账号，编辑conf目录下的**tomcat-users.xml**文件，添加manager角色，设置用户名和密码
    - **注意**：这里我在操作的时候，发现我用的是tomcat9嘛，所以跟视频里面将的不一样，设置的时候发现仅仅设置manager是不行的，并且**tomcat-users.xml**文件中也说了不同的用户对应着不同的管理权限，不像以前直接manager用户管所有了，因此为了解决这个问题查了百度，[参考链接](http://blog.sina.com.cn/s/blog_6ac4c6cb0101485d.html)，这样就解决了。另外，不能像视频中设置用户和密码为空，不然一直弹框也进不去。

## 2. Web程序结构

- 一个web应用程序是由一组Servlet，HTML页面，类，以及其他的资源组成的运行在web服务器上的完整的应用程序，以一种结构化的有层次的目录形式存在。

- 组成web应用程序的这些文件要部署在相应的目录层次中，根目录代表整个web应用程序的“根”。

- 通常将web应用程序的目录放在webapps目录下，在webapps目录下的每一个子目录都是一个独立的web应用程序，子目录的名字就是web应用程序的名字，也就是web应用程序的“根”。用户通过web应用程序的“根”来访问web应用程序中的资源。

- Servlet规范汇总定义了web应用程序的目录层次

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409153613329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- **注意**：跟着视频在创建jsp文件的时候，我发现并没有这个新建这个文件的选择，网上搜了搜方法，据说是：“IDEA认为我这个包建的有问题，才导致这地方不应该创建jsp文件，所以就没有创建JSP文件的选项。” [参考连接](https://blog.csdn.net/weixin_44381073/article/details/89816624)，采用这个方法之后就可以新建jsp文件了。

- JSP(Java Server Pages，java服务器端网页)是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。

- 第一个WEB应用程序：开发，并部署到Tomcat服务器下运行

  1. 新建一个JavaProject
  2. 在Java项目下创建WEB开发的目录结构
     - WebContent
       - WEN-INF
         - classes 编译后的class文件必须放在该目录下
         - lib
         - web.xml （从Tomcatwebapps\docs\WEB-INFO中复制过来，可以不做修改）
       - html 页面
       - jsp 页面
       - 图片。。。
  3. 在src下新建一个Person类
  4. 手工的Person类对应的Class文件（含包）复制到classes目录下
     - 可以通过修改默认的输出目录达到自动把编译好的class放到classes目录下
     - 由于视频中是eclipse操作的，因此我搜了一下idea的[操作方法](https://www.cnblogs.com/dslx/p/10172602.html)
  5. 在WebContent目录下新建一个JSP文件
  6. 把WebContent目录复制到Tomcat的webapps目录下，并改名为helloworld
  7. 在浏览器的地址栏中输入http://localhost:8080/WebContent/hello.jsp即可看到命令行打印的信息
  8. 使用【配置任意目录下Web应用程序2】的方式建立.xml文件，实现直接部署

- 配置任意目录下Web应用程序1

  - 在Web服务器中可以配置虚拟目录，而虚拟目录所对应的真实目录可以在任何路径下
  - 在Tomcat服务器中，主要在XML配置文件中通过`<Context>`元素的设置来完成的。一个`<Context>`元素就表示一个Web应用程序，运行在特定的虚拟主机中
  - `<Context>`元素是`<Host>`元素的子元素，可以在conf\server.xml文件中设置Context元素
  - 使用docBase属性指定Web应用程序的真实路径。将属性reloadable设置为true，Tomcat在运行时会自动监测Servlet类的改动，如果发现有类被更新，Tomcat服务器将自动重新加载该Web应用程序。这样，在开发时，就不需要频繁重启Tomcat了。

- 配置任意目录下Web应用程序2（超酷）

  - 还可以在conf目录下一次创建Catalina\localhost目录，然后在localhost目录下为test这个Web应用程序建立test.xml文件，编辑这个文件输入以下内容`<Context path="/test" docBase="c:/test" reloadable="true">`
  - 从Tomcat5开始，**不建议直接在server.xml文件中配置`<Context>`元素**，因为server.xml文件作为Tomcat的主要配置文件，一旦Tomcat启动后，将不会再读取这个文件，因此无法在Tomcat服务器启动时发布Web应用程序。如果在其他地方配置`<Context>`元素，那么在Tomcat运行时，也可以发布Web应用程序。
  - 从Tomcat5.5开始，在\conf\Catalina\localhost目录下创建XML配置文件来配置Web应用程序，**Tomcat将以XML文件的文件名作为Web应用程序的上下文路径**，而不会理会在`<Context>`元素的path属性中指定的上下文路径是什么。由于Tomcat5.5之后的版本是以XML配置文件的文件名作为Web应用程序的上下文路径的，因此在配置`<Context>`元素时，可以不使用path属性。

- 文件修改为helloworld2.xml

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <Context path="/test2" docBase="F:/BookStudy/else/JavaWebPro/WebContent" reloadable="true"/>
  ```

- 上述内容的解释

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409173352178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- **之前没有实现自动化的结果这里就不展示了**

- 自动化包含了两个，具体实现方法在上面

  - 一是将class输出的位置放到WebContent/WEB-INF/classes下
  - 二是通过配置任意目录下Web应用程序（使用第2种方法），把后面的原路径映射道虚拟路径上，实现实时更新项目的目的，这样修改了原始项目的内容，也可以不用重启Tomcat直接展示最新的结果。

- 报错问题：

  - org.apache.jasper.JasperException: Unable to compile class for JSP:
  - JSP出现 类名 cannot be resolved to a type
  - 上面两种问题是同一页面出现的。。。我查了一万个方法。。。最后发现是WEB-INF写成WEB-INFO了
  - 所以出了问题的第一件事情，一定要从自己这里找原因。。。哭！

- 最后运行成功的图如下：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200409171814200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

## 3. 使用Eclipse / Idea开发JavaWeb项目

- [Idea配置1](https://blog.csdn.net/With_Her/article/details/89243777?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)、[Idea配置2](https://blog.csdn.net/chenshun123/article/details/51285890)

- Eclipse配置：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410120252614.png)

## 4. Servlet

- Java Servlet是和平台无关的服务器端组件，它运行在Servlet容器中。Servlet容器负责Servlet和客户的通信以及调用Servlet的方法，Servlet和客户的通信采用“请求/响应”的模式。

- Server Applet

- Servlet可完成如下功能：

  - 创建并返回基于客户请求的动态HTML页面
  - 创建可嵌入到现有HTML页面中的部分HTML页面（HTML片段）。
  - 与其它服务器资源（如数据库或基于Java的应用程序）进行通信。

- Servlet容器响应客户请求的过程

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410120926345.png)

- Servlet API

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410121212144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 4.1 第一个Servlet程序

- 问题：我在操作的时候，发现不能implements Servlet，网上查了查，说是没有导入对应的包

- [解决方法](https://www.cnblogs.com/ifeil/p/9378921.html)：实际上就是在Modules中的项目里的Dependences中+上Tomcat的library

- 问题：在启动自己的HelloServlet时，输出中文为乱码

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410123530828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- [解决方法](https://www.cnblogs.com/chenxianbin/p/11367954.html)：早Tomcat的conf路径下修改logging.properties文件中，将下图的位置的UTF-8改为GBK

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020041012373535.png)

- 问题：xml文件在写的时候，如何优雅的注释

- [解决方法](https://blog.csdn.net/weixin_33889245/article/details/94303669)：CTRL + SHIFT + / 直接调出注释

- **自己的解决方法**：我自己做了一个Live Template：输入<然后回车就会直接生成注释

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410125509301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- Servlet的HelloWorld

  1. 创建一个Servlet接口的实现类（记住这个时候要导入Tomcat的library，[参考链接](https://blog.csdn.net/weixin_44319545/article/details/100544309)）

  2. 在web.xml文件中配置和映射这个Servlet（目的是希望能够通过浏览器去访问java类）

     ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410124301987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 具体实现

  - HelloServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: HelloServlet.java
     * @time: 2020/4/10 12:20
     * @desc: |
     */
    
    public class HelloServlet implements Servlet {
    
        public HelloServlet() {
            System.out.println("HelloServlet构造器已启动...");
        }
    
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            System.out.println("初始化中...");
        }
    
        @Override
        public ServletConfig getServletConfig() {
            System.out.println("获取Servlet配置中...");
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            System.out.println("服务中...");
        }
    
        @Override
        public String getServletInfo() {
            System.out.println("获取Servlet信息中...");
            return null;
        }
    
        @Override
        public void destroy() {
            System.out.println("毁灭中...");
        }
    }
    ```

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
        <!-- 配置和映射Servlet -->
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.HelloServlet</servlet-class>
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello</url-pattern>
        </servlet-mapping>
    </web-app>
    ```

### 4.2 Servlet配置及生命周期方法

- Servlet容器：运行Servlet、JSP、Filter等的软件环境
  - 可以来创建Servlet，并调用Servlet的相关生命周期方法
  - JSP，Filter，Listener，Tag…
- Servlet生命周期的方法：以下方法都是由Servlet容器负责调用
  - 构造器方法：只被调用一次，只有第一次请求Servlet时，创建Servlet的实例，调用构造器。（这说明Servlet是单实例的）
  - init方法：只被调用一次，在创建好实例后立即被调用，用于初始化当前Servlet。
  - service：被多次调用。每次请求都会调用service方法，实际用于相应请求的。
  - destroy：只被调用一次，在当前Servlet所在的WEB应用被卸载前调用，用于释放当前Servlet所占用的资源。
- load-on-startup参数
  - 配置在Servlet节点中
  - load-on-startup：可以指定Servlet被创建的时机，若为负数，则在第一次请求时被创建。若为0或正数，则在当前WEB应用被Servlet容器被加载时创建实例，且数值越小越早被创建。负数，则不创建。
- Servlet容器响应客户请求的过程
  1. Servlet引擎检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第4步，否则，执行第2步
  2. 装载并创建该Servlet的第一个实例对象：调用该Servlet的构造器
  3. 调用Servlet实例对象的init()方法
  4. 创建一个用于封装请求的ServletRequest对象和一个代表响应消息的ServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传进去
  5. WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法
- Servlet的注册于运行
  - Servlet程序必须通过Servlet容器来启动运行，并且存储目录有特殊要求，通常需要存储在`<WEB应用程序目录>\WEB-INF\classes\`目录中。
  - Servlet程序必须在WEB应用程序的web.xml文件中进行注册和映射其访问路径，才可以被Servlet引擎加载和被外界访问。
  - 一个`<servlet>`元素用于注册一个Servlet，它包含有两个主要的子元素：
    - `<servlet-name>`：用于设置Servlet的注册名称
    - `<servlet-class>`：用于设置Servlet的完整类名
  - 一个`<servlet-mapping>`元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：
    - `<servlet-name>`：用于设置Servlet的注册名称
    - `<url-pattern>`：用于设置Servlet的对外访问路径
- Servlet映射的细节
  - 同一个Servlet可以被映射到多个URL上，即多个`<servlet-mapping>`元素的`<servlet-name>`子元素的设置值可以是同一个Servlet的注册名
  - 在Servlet映射到的URL中也可以使用`*`通配符，但是只能有两种固定的格式：一种是`*.扩展名`，另一种格式是以正斜杠`/`开头并以`/*`结尾
  - 注意：`/*.扩展名`，即既带/又带扩展名的不合法

### 4.3 ServletConfig & ServletContext

- 封装了Servlet的配置信息，并且可以获取ServletContext对象（ServletConfig获取的是该Servlet的初始化参数，ServletContext中可以获取全局的初始化参数）
  1. 配置Servlet的初始化参数
  2. 获取初始化参数：
     - getInitParameter(String name)：获取指定参数名的初始化参数
     - getInitParameterNames()：获取参数名组成的Enumeration对象
  3. 获取Servlet的配置名称
  4. getServletContext
     - Servlet引擎为 **每个WEB应用程序** 都创建一个对应的ServletContext对象，ServletContext对象被包含在ServletConfig对象中，调用ServletConfig.getServletContext方法可以返回ServletContext对象的应用。
     - **由于一个WEB应用程序中的所有Servlet都共享同一ServletContext对象**，所以，ServletContext对象被称为application对象（Web应用程序对象）
     - 功能：
       - 获取WEB应用程序的初始化参数
       - 记录日志
       - application域范围的属性
       - 访问资源文件
       - 获取虚拟路径所映射的本地路径
       - WEB应用程序之间的访问
       - ServletContext的其他方法

- 代码

  - HelloServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    import java.io.InputStream;
    import java.util.Enumeration;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: HelloServlet.java
     * @time: 2020/4/10 12:20
     * @desc: |
     */
    
    public class HelloServlet implements Servlet {
    
        public HelloServlet() {
            System.out.println("HelloServlet构造器已启动...");
        }
    
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            // 1. ServletConfig
            // 针对Servlet的初始化参数
            System.out.println("初始化中...");
            String user = servletConfig.getInitParameter("user");
            System.out.println("user: " + user);
            Enumeration<String> names = servletConfig.getInitParameterNames();
            while(names.hasMoreElements()){
                String name = names.nextElement();
                String value = servletConfig.getInitParameter(name);
                System.out.println(name + "-->" + value);
            }
            String servletName = servletConfig.getServletName();
            System.out.println(servletName);
    
            // 2. ServletContext
            // 针对app的初始化参数，相较于上面，该参数适用于所有Servlet，相当于全局的参数
            // 2.1 获取ServletContext对象
            ServletContext sc = servletConfig.getServletContext();
            // 获取WEB应用程序的初始化参数
            String driver = sc.getInitParameter("driver");
            System.out.println("driver: " + driver);
            Enumeration<String> names2 = sc.getInitParameterNames();
            while(names2.hasMoreElements()){
                String name = names2.nextElement();
                String value = sc.getInitParameter(name);
                System.out.println(name + "-->" + value);
            }
    
            // 2.2 获取当前WEB应用的某一个文件在服务器上的绝对路径：
            String realPath = sc.getRealPath("/index.jsp");
            System.out.println(realPath);
    
            // 2.3 获取当前WEB应用的名称
            String contextPath = sc.getContextPath();
            System.out.println(contextPath);
    
            // 2.4 获取当前WEB应用的某一个文件对应的输入流
            // path的 / 响度与当前WEB应用的根目录
            try {
                ClassLoader cl = getClass().getClassLoader();
                InputStream is = cl.getResourceAsStream("jdbc.properties");
                System.out.println("1. " + is);
    
                InputStream is2 = sc.getResourceAsStream("jdbc.properties");
                System.out.println("2. " + is2);
    
                InputStream is3 = sc.getResourceAsStream("/WEB-INF/classes/jdbc.properties");
                System.out.println("3. " + is3);
            } catch (Exception e) {
                e.printStackTrace();
            }
    
            // 2.5 和attribute相关的几个方法
    
        }
    
        @Override
        public ServletConfig getServletConfig() {
            System.out.println("获取Servlet配置中...");
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            System.out.println("服务中...");
        }
    
        @Override
        public String getServletInfo() {
            System.out.println("获取Servlet信息中...");
            return null;
        }
    
        @Override
        public void destroy() {
            System.out.println("毁灭中...");
        }
    }
    ```

  - SecondServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: SecondServlet.java
     * @time: 2020/4/11 10:11
     * @desc: |
     */
    
    public class SecondServlet implements Servlet {
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            System.out.println("第二次Servlet初始化");
        }
    
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
    
        }
    
        @Override
        public String getServletInfo() {
            return null;
        }
    
        @Override
        public void destroy() {
    
        }
    }
    ```

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
        <!-- 配置和映射Servlet -->
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.HelloServlet</servlet-class>
    
            <!-- 配置Servlet的初始化参数，且节点必须在load-on-startup节点的前面 -->
            <init-param>
                <!-- 参数名 -->
                <param-name>user</param-name>
                <!-- 参数值 -->
                <param-value>root</param-value>
            </init-param>
            <init-param>
                <param-name>password</param-name>
                <param-value>1230</param-value>
            </init-param>
    
            <!-- 可以指定Servlet被创建的时机 -->
            <load-on-startup>5</load-on-startup>
    
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello</url-pattern>
        </servlet-mapping>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello2</url-pattern>
        </servlet-mapping>
    
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>secondServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.SecondServlet</servlet-class>
            <!-- 可以指定Servlet被创建的时机 -->
            <load-on-startup>2</load-on-startup>
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>secondServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>*.html</url-pattern>
        </servlet-mapping>
    </web-app>
    ```

### 4.4 HTTP简介

- WEB浏览器与WEB浏览器之间的一问一答的交互过程，必须遵循一定的规则，这个规则就是HTTP协议

- HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是TCP/IP协议集中的一个应用层协议，**用于定义WEB浏览器与WEB浏览器之间交换数据的过程以及数据本身的格式**。

- HTTP协议的版本HTTP/1.0、HTTP/1.1、HTTP-NG

- HTTP的会话方式：

  - 四个步骤：建立连接、发出请求信息、回送响应信息、关闭连接
  - 浏览器与WEB服务器的连接过程是短暂的，每次连接只处理一个请求和响应。对每一个页面的访问，浏览器与WEB服务器都要建立一次单独的连接。
  - 浏览器到WEB服务器之间的所有通讯都是完全独立分开的请求和响应对。

- 浏览器范文多图网页的过程

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412145427186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- HTTP请求消息

  - 请求消息的结果：**一个请求行、若干消息头以及实体内容**，其中一些消息头和实体内容都是可选的，消息头和实体内容之间要用空行隔开。

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412145629979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- HTTP响应信息

  - 响应信息的结构：**一个状态行、若干消息头、以及实体内容**，其中一些消息头和实体内容都是可选的，消息头和实体内容之间要用空行隔开。

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412145820158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 其他细节

  - 响应消息的实体内容就是网页文件的内容，也就是在浏览器中使用查看源文件的方式所看到的内容
  - 一个使用GET方式的请求消息中不能包含实体内容，只有使用POST、PUT和DELETE方式的请求消息中才可以包含实体内容。

- 使用GET和POST方式传递参数

  - 在URL地址后面还可以附加一些参数

  - GET方式：

    - 传输的数据量是有限的，一般限制在1KB以下。
    - 在浏览器地址栏中输入某个URL地址或单击网页上的一个超链接时，浏览器发出的HTTP请求消息的请求方式为GET
    - 如果网页中的`<form>`表单元素的method属性被设置为了“GET”，浏览器提交这个FROM表单时生成的HTTP请求消息方式也为GET
    - 使用GET请求方式给WEB服务器传递参数的格式：`xxx?name=l&pwd=123`

  - POST方式：

    - POST方式将各个表单字段元素及其数据作为HTTP消息的实体内容发送给WEB服务器。传送的数据量要比GET方式传送的数据量大得多。

    - POST请求方式主要用于向WEB服务器端程序提交FORM表单中的数据。

    - 格式：

      ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412152046412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 4.5 ServletRequest & ServletResponse

- 如何在Servlet中获取请求信息：

  - Servlet的service()方法用于应答请求：因为每次请求都会调用service()方法

- ServletRequest：封装了请求信息，可以从中获取到任何的请求信息。

- ServletResponse：封装了响应信息，如果想给用户什么响应，均可以使用该接口的方法实现。

- 这两个接口的实现类都是服务器给予实现的，并在服务器调用service方法时传入。

>  问题1：在实验的时候我发现了一个大问题，就是每次改了代码之后，都需要重启Servlet才能行。
>
>  解决方案：[参考链接](https://blog.csdn.net/Jodie_Girl/article/details/103597872)，我在参考连接的基础上对Tomcat的配置进行了修改，也就是如图所示的部分，全部修改为update classes and resources
>  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413120914681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
>
>  问题2：IDEA中重新启动一共有四种选择，分别是什么意思
>  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413122116504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
>
>  解决方案：[参考连接](https://blog.csdn.net/qq_40871734/article/details/99749715)，我发现选择重新部署，也就是第三个，才能起到刷新java类的效果

- ServletRequest：

  - 获取请求参数：
    - String getParameter(String name)：根据请求参数的名字，返回参数值（若请求参数有多个值，如checkbox，该方法只能获取到第一个提交的值）。
    - Map getParameterMap()：返回请求参数的键值对：Key：参数名；Value：参数值，String数组类型。
    - Enumeration getParameterNames()：返回参数名对应的Enumeration对象，类似于ServletConfig(或ServletContext)的getInitParameterNames()方法。
    - String[] getParameterValues(String name)：根据请求参数的名字，返回请求参数对应的字符串数组
    
  - 流程图
  
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413120207777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
  
- HttpServletRequest：是ServletRequest的子接口，针对HTTP请求所定义。里边包含了大量获取HTTP请求的方法

  - 获取请求的URL：HttpServletRequest.getRequestURI()，结果示例：`/app2/loginServLet`
  - 获取请求的方式：HttpServletRequest.getMethod()，结果示例：`GET`
  - 获取请求参数的字符串：HttpServletRequest.getQueryString()，结果示例：`user=111&password=333&interesting=reading&interesting=game&interesting=party`
  - 获取Servlet的映射路径：HttpServletRequest.getServletPath()，结果示例：`/loginServLet`
  - 和attribute相关的几个方法

- ServletResponse

  - getWriter()：返回PrintWriter对象，调用该对象的print()方法，将把print()中的参数直接打印到客户的浏览器上。
  - setContentType()：设置响应的内容类型。

- HttpServletResponse：跟HttpServletRequest同理，有一个超重要的方法

  - void sendRedirect(String location)：请求的重定向。（此方法为HttpServletResponse中定义，因此使用时需要强转）

- 上述的实现代码

  - LoginServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import java.io.IOException;
    import java.io.PrintWriter;
    import java.util.Arrays;
    import java.util.Enumeration;
    import java.util.Map;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LoginServlet.java
     * @time: 2020/4/13 11:45
     * @desc: |
     */
    
    public class LoginServlet implements Servlet {
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
    
        }
    
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            System.out.println("请求来了！");
            System.out.println(servletRequest);
    
            String user = servletRequest.getParameter("user");
            String psd = servletRequest.getParameter("password");
            System.out.println(user + "-->" + psd);
    
            String interesting = servletRequest.getParameter("interesting");
            System.out.println(interesting);
    
            String[] interestings = servletRequest.getParameterValues("interesting");
            System.out.println(interestings);
            for(String a: interestings){
                System.out.println(a);
            }
    
            Enumeration<String> names = servletRequest.getParameterNames();
            while(names.hasMoreElements()){
                String name = names.nextElement();
                String val = servletRequest.getParameter(name);
    
                System.out.println("3. " + name + ": " + val);
            }
    
            Map<String, String[]> map = servletRequest.getParameterMap();
            for(Map.Entry<String, String[]> entry: map.entrySet()){
                System.out.println("4. " + entry.getKey() + ": " + Arrays.asList(entry.getValue()));
            }
    
            HttpServletRequest hsr = (HttpServletRequest) servletRequest;
            String requestURI = hsr.getRequestURI();
            System.out.println(requestURI);
    
            String method = hsr.getMethod();
            System.out.println(method);
    
            String qs = hsr.getQueryString();
            System.out.println(qs);
    
            String sp = hsr.getServletPath();
            System.out.println(sp);
    
            // 设置响应的内容类型：这里设置成word格式，那么submit之后会让你下载一个文件，文件可以用word打开，内容是write中的内容。
            servletResponse.setContentType("application/msword");
    
            PrintWriter out = servletResponse.getWriter();
            out.println("What are you talking about?");
    
        }
    
        @Override
        public String getServletInfo() {
            return null;
        }
    
        @Override
        public void destroy() {
    
        }
    }
    ```

  - login.html

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
    <form action="loginServLet" method="get">
        user: <input type="text" name="user">
        password: <input type="password" name="password">
    
        <br><br>
    
        interesting:
        <input type="checkbox" name="interesting" value="reading" />Reading
        <input type="checkbox" name="interesting" value="game" />Game
        <input type="checkbox" name="interesting" value="party" />Party
        <input type="checkbox" name="interesting" value="shopping" />Shopping
        <input type="checkbox" name="interesting" value="sport" />Sport
        <input type="checkbox" name="interesting" value="tv" />TV
    
        <input type="submit" value="submit"/>
    </form>
    
    </body>
    </html>
    ```

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
    
        <!-- 获取WEB应用程序的初始化参数 -->
        <context-param>
            <param-name>driver</param-name>
            <param-value>com.mysql.cj.jdbc.Driver</param-value>
        </context-param>
    
        <context-param>
            <param-name>jdbcUrl</param-name>
            <param-value>jdbc:mysql://localhost:3306/testjdbc?serverTimezone=GMT%2B8</param-value>
        </context-param>
    
        <!-- 配置和映射Servlet -->
        <servlet>
            <!-- Servlet 注册的名字 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- Servlet 的全类名 -->
            <servlet-class>com.litian.test.HelloServlet</servlet-class>
    
            <!-- 配置Servlet的初始化参数，且节点必须在load-on-startup节点的前面 -->
            <init-param>
                <!-- 参数名 -->
                <param-name>user</param-name>
                <!-- 参数值 -->
                <param-value>root</param-value>
            </init-param>
            <init-param>
                <param-name>password</param-name>
                <param-value>1230</param-value>
            </init-param>
    
            <!-- 可以指定Servlet被创建的时机 -->
            <load-on-startup>5</load-on-startup>
    
        </servlet>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello</url-pattern>
        </servlet-mapping>
        <servlet-mapping>
            <!-- 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 -->
            <servlet-name>helloServlet</servlet-name>
            <!-- 映射具体的访问路径：/ 代表当前WEB应用的根目录 -->
            <url-pattern>/hello2</url-pattern>
        </servlet-mapping>
    
    <!--    <servlet>-->
    <!--        &lt;!&ndash; Servlet 注册的名字 &ndash;&gt;-->
    <!--        <servlet-name>secondServlet</servlet-name>-->
    <!--        &lt;!&ndash; Servlet 的全类名 &ndash;&gt;-->
    <!--        <servlet-class>com.litian.test.SecondServlet</servlet-class>-->
    <!--        &lt;!&ndash; 可以指定Servlet被创建的时机 &ndash;&gt;-->
    <!--        <load-on-startup>2</load-on-startup>-->
    <!--    </servlet>-->
    
    <!--    <servlet-mapping>-->
    <!--        &lt;!&ndash; 需要和某一个Servlet节点的servlet-name子节点的文本节点一致 &ndash;&gt;-->
    <!--        <servlet-name>secondServlet</servlet-name>-->
    <!--        &lt;!&ndash; 映射具体的访问路径：/ 代表当前WEB应用的根目录 &ndash;&gt;-->
    <!--        <url-pattern>*.html</url-pattern>-->
    <!--    </servlet-mapping>-->
    
        <servlet>
            <servlet-name>loginServlet</servlet-name>
            <servlet-class>com.litian.test.LoginServlet</servlet-class>
        </servlet>
    
        <servlet-mapping>
            <servlet-name>loginServlet</servlet-name>
            <url-pattern>/loginServLet</url-pattern>
        </servlet-mapping>
    
    </web-app>
    ```

### 4.6 GenericServlet

> 小题目：在web.xml文件中设置两个WEB应用的初始化参数，user，password；定义一个login.html，里边定义两个请求字段：user，password，发送请求到loginServlet；再创建一个LoginServlet，在其中获取请求的user，password。比对其和web.xml文件中定义的请求参数是否一致，若一致，响应Hello：xxx；若不一致，响应Sorry：xxx；xxx为user。

- 新建一个工程来实现上述问题

  - 配置Tomcat和一系列设置

  - web.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
             version="4.0">
        <!-- 配置当前WEB应用的初始化参数 -->
        <context-param>
            <param-name>user</param-name>
            <param-value>litian</param-value>
        </context-param>
    
        <context-param>
            <param-name>password</param-name>
            <param-value>123</param-value>
        </context-param>
    
        <!-- 配置Servlet -->
        <servlet>
            <servlet-name>log</servlet-name>
            <servlet-class>com.litian.test.LoginServlet</servlet-class>
        </servlet>
    
        <servlet-mapping>
            <servlet-name>log</servlet-name>
            <url-pattern>/LoginServlet</url-pattern>
        </servlet-mapping>
    </web-app>
    ```

  - login.html

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>冲冲冲</title>
    </head>
    <body>
    <form action="LoginServlet" method="post">
        user: <input type="text" name="username"/>
        password: <input type="password" name="password"/>
        <input type="submit" value="Submit"/>
    </form>
    
    </body>
    </html>
    ```

  - LoginServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.*;
    import java.io.IOException;
    import java.io.PrintWriter;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LoginServlet.java
     * @time: 2020/4/13 14:17
     * @desc: |
     */
    
    public class LoginServlet implements Servlet {
        private ServletConfig servletConfig;
    
        @Override
        public void init(ServletConfig servletConfig) throws ServletException {
            this.servletConfig = servletConfig;
        }
    
        @Override
        public ServletConfig getServletConfig() {
            return null;
        }
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
            // 1. 获取请求参数：username和password
            String username = servletRequest.getParameter("username");
            String password = servletRequest.getParameter("password");
    
            // 2. 获取当前WEB应用的初始化参数：user，password
            // 需要使用ServletContext对象
            ServletContext sc = servletConfig.getServletContext();
            String initUser = sc.getInitParameter("user");
            String initPassword = sc.getInitParameter("password");
    
            // 3. 比对
            // 设置中文乱码问题
            servletResponse.setCharacterEncoding("utf-8");
            // 设置响应的内容类型
            servletResponse.setContentType("text/html;charset=utf-8");
    
            PrintWriter out = servletResponse.getWriter();
            if(initUser.equals(username) && initPassword.equals(password)){
                // 4. 打印响应字符
                out.println("Hello: " + username);
            }else{
                out.println("Sorry: " + username + "，你甭想进来！");
            }
        }
    
        @Override
        public String getServletInfo() {
            return null;
        }
    
        @Override
        public void destroy() {
    
        }
    }
    ```

- GenericServlet（不常用，了解，因为常用HttpServlet）

  - 是一个Servlet，是Servlet接口和ServletConfig接口的实现类，但是是一个抽象类，其中service方法为抽象方法。

  - 存在的意义：如果新建的Servlet程序直接继承GenericServlet会使得开发更简洁。

  - 具体实现

    - 在GenericServlet中声明了一个**ServletConfig**类型的成员变量，在init(ServletConfig)方法中对其进行了初始化。
    - 利用ServletConfig成员变量的方法实现了ServletConfig接口的方法。
    - 还定义了一个**init方法**，在init(ServletConfig)方法中对其进行调用，子类可以直接覆盖init()在其中实现对Servlet的初始化。
    - 不建议直接覆盖带参init，忘记编写super(ServletConfig)，还使用了ServletConfig接口的方法时会报空指针异常。
    - 新建的init()并非Servlet的声明周期方法，而带参的那个是。

  - 手写GenericServlet的原理（实际上还有log日志方法）

    - 自定义一个Servlet接口的实现类：让开发的任何Servlet都继承该类，以简化开发

      ```java
      package com.litian.test;
      
      import javax.servlet.*;
      import java.util.Enumeration;
      
      /**
       * @author: Li Tian
       * @contact: litian_cup@163.com
       * @software: IntelliJ IDEA
       * @file: MyGenericServlet.java
       * @time: 2020/4/14 15:29
       * @desc: |自定义一个Servlet接口的实现类：让开发的任何Servlet都继承该类，以简化开发
       */
      
      public abstract class MyGenericServlet implements Servlet, ServletConfig {
          private ServletConfig servletConfig;
      
          // 以下方法为Servlet接口的方法
          @Override
          public void init(ServletConfig servletConfig) throws ServletException {
              this.servletConfig = servletConfig;
          }
      
          @Override
          public ServletConfig getServletConfig() {
              return servletConfig;
          }
      
          @Override
          public abstract void service(ServletRequest servletRequest, ServletResponse servletResponse);
      
          @Override
          public String getServletInfo() {
              return null;
          }
      
          @Override
          public void destroy() {
      
          }
      
          // 以下方法为ServletConfig接口的方法
          @Override
          public String getServletName() {
              return servletConfig.getServletName();
          }
      
          @Override
          public ServletContext getServletContext() {
              return servletConfig.getServletContext();
          }
      
          @Override
          public String getInitParameter(String s) {
              return servletConfig.getInitParameter(s);
          }
      
          @Override
          public Enumeration<String> getInitParameterNames() {
              return servletConfig.getInitParameterNames();
          }
      }
      ```

    - 利用手写的GenericServlet简化开发

      ```java
      package com.litian.test;
      
      import javax.servlet.*;
      import java.io.IOException;
      import java.io.PrintWriter;
      
      /**
       * @author: Li Tian
       * @contact: litian_cup@163.com
       * @software: IntelliJ IDEA
       * @file: LoginServlet.java
       * @time: 2020/4/13 14:17
       * @desc: |继承MyGenericServlet来实现简化开发
       */
      
      public class LoginServlet2 extends MyGenericServlet {
      
          @Override
          public void service(ServletRequest servletRequest, ServletResponse servletResponse) {
              // 1. 获取请求参数：username和password
              String username = servletRequest.getParameter("username");
              String password = servletRequest.getParameter("password");
      
              // 2. 获取当前WEB应用的初始化参数：user，password
              // 需要使用ServletContext对象
              String initUser = getServletContext().getInitParameter("user");
              String initPassword = getServletContext().getInitParameter("password");
      
              // 3. 比对
              // 设置中文乱码问题
              servletResponse.setCharacterEncoding("utf-8");
              // 设置响应的内容类型
              servletResponse.setContentType("text/html;charset=utf-8");
      
              PrintWriter out = null;
              try {
                  out = servletResponse.getWriter();
              } catch (IOException e) {
                  e.printStackTrace();
              }
              if(initUser.equals(username) && initPassword.equals(password)){
                  // 4. 打印响应字符
                  out.println("Hello: " + username);
              }else{
                  out.println("Sorry: " + username + "，你甭想进来！");
              }
          }
      }
      ```

  - GenericServlet中有一个init()函数（**下面写的是视频的解释，个人查证后的在开头的学习体会中**）

    - 因为在子类LoginServlet2中存在一种需求：对当前的Servlet进行初始化，即覆盖init方法

      ```java
      @Override
      public void init(ServletConfig servletConfig) throws ServletException {
      	System.out.println("初始化");
      }
      ```

    - 运行后会报空指针异常，这是因为初始化的时候覆盖了父类初始化方法，这样ServletConfig就没有传参过去，因此就不能调用ServletConfig的各个函数。

    - 因此加入一个init()函数，里面不传参

      ```java
      @Override
      public void init(ServletConfig servletConfig) throws ServletException {
          this.servletConfig = servletConfig;
          init();
      }
      
      public void init() throws ServletException {
      }
      ```

    - 这时，再在LoginServlet2中初始化时，会使用init()函数，则不会再报错。

### 4.7 HttpServlet

- 若有个需求：获取请求方式是get还是post

  - 这样每次使用的时候都需要将request强转为HttpServletRequest

- 定义GenericServlet是为了集成ServletConfig中的方法，从而直接获得更多的内容，就不用new ServletConfig了

- 在GenericServlet的基础上HttpServlet继承了GenericServlet类，集成了HttpServletRequest和HttpServletResponse的各种方法，就不用强转了。

- HttpServlet是一个Servlet，继承自GenericServlet，针对HTTP协议所定制。

- 在service方法中直接把ServletRequest和ServletResponse转为HttpServletRequest和HttpServletResponse，并调用了重载的service(HttpServletRequest, HttpServletResponse)；在这个重载的service中获取了请求方式：request.getMethod()，根据请求方式又创建了doXxx()方法（Xxx为具体的请求方式，如doGet，doPost）

- **实际开发中，直接继承HttpServlet，并根据请求方式重写doXxx方法接口**。（主要指doGet，doPost）

- 好处：

  - 直接有针对性的覆盖doXxx方法
  - 直接使用HttpServletRequest和HttpServletResponse，不再需要强转。

- 手写HttpServlet的原理

  - MyHttpServlet.java

    ```java
    package com.litian.test;
    
    import javax.servlet.ServletException;
    import javax.servlet.ServletRequest;
    import javax.servlet.ServletResponse;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: MyHttpServletRequest.java
     * @time: 2020/4/14 16:30
     * @desc: |针对http协议定义的Servlet基类
     */
    
    public class MyHttpServlet extends MyGenericServlet{
        @Override
        public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
            HttpServletRequest request;
            HttpServletResponse response;
            try {
                request = (HttpServletRequest)req;
                response = (HttpServletResponse)res;
            } catch (ClassCastException var6) {
                throw new ServletException("http.non_http");
            }
    
            this.service(request, response);
        }
    
        public void service(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
            // 1. 获取请求方式
            String method = servletRequest.getMethod();
    
            // 2. 根据请求方式再调用对应的处理方法
            if("GET".equalsIgnoreCase(method)){
                doGet(servletRequest, servletResponse);
            }
    
            if("POST".equalsIgnoreCase(method)){
                doPost(servletRequest, servletResponse);
            }
        }
    
        public void doPost(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
        }
    
        public void doGet(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
        }
    }
    ```

  - 继承MyHttpServlet来实现简化开发

    ```java
    package com.litian.test;
    
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    import java.io.PrintWriter;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LoginServlet.java
     * @time: 2020/4/13 14:17
     * @desc: |继承MyHttpServlet来实现简化开发
     */
    
    public class LoginServlet3 extends MyHttpServlet {
        @Override
        public void doPost(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
            // 获取的请求方式是GET还是POST
            String method = servletRequest.getMethod();
            System.out.println(method);
    
            // 1. 获取请求参数：username和password
            String username = servletRequest.getParameter("username");
            String password = servletRequest.getParameter("password");
    
            // 2. 获取当前WEB应用的初始化参数：user，password
            // 需要使用ServletContext对象
            String initUser = getServletContext().getInitParameter("user");
            String initPassword = getServletContext().getInitParameter("password");
    
            // 3. 比对
            // 设置中文乱码问题
            servletResponse.setCharacterEncoding("utf-8");
            // 设置响应的内容类型
            servletResponse.setContentType("text/html;charset=utf-8");
    
            PrintWriter out = null;
            try {
                out = servletResponse.getWriter();
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (initUser.equals(username) && initPassword.equals(password)) {
                // 4. 打印响应字符
                out.println("Hello: " + username);
            } else {
                out.println("Sorry: " + username + "，你甭想进来！");
            }
        }
    }
    ```

- 利用HttpServ实现上述小题目

> 小题目：
> 在MySQL数据库中穿件一个test_users.users数据表，添加3个字段：id，user，password，并录入几条记录。
> 定义一个login.html，里边定义两个请求字段：user，password，发送请求到loginServlet；再创建一个LoginServlet4（使用HttpServlet），在其中获取请求的user，password。
> 利用JDBC从test_users.users中查询有没有和页面输入的user，password对应的记录。
> select count(id) from users where user=? and password=?
> 若有，响应Hello：xxx；若没有，响应Sorry：xxx；xxx为user。

- 代码

  ```java
  package com.litian.test;
  
  import javax.servlet.ServletException;
  import javax.servlet.http.HttpServlet;
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  import java.io.IOException;
  import java.io.PrintWriter;
  import java.sql.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: LoginServlet.java
   * @time: 2020/4/13 14:17
   * @desc: |
   */
  
  public class LoginServlet4 extends HttpServlet {
      @Override
      protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          String username = req.getParameter("username");
          String password = req.getParameter("password");
  
          // 设置中文乱码问题
          resp.setCharacterEncoding("utf-8");
          // 设置响应的内容类型
          resp.setContentType("text/html;charset=utf-8");
  
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
  
          PrintWriter out = resp.getWriter();
  
          try {
              Class.forName("com.mysql.cj.jdbc.Driver");
              String url = "jdbc:mysql://localhost:3306/test_users?serverTimezone=GMT%2B8";
              String ur = "root";
              String psd = "123456";
              conn = DriverManager.getConnection(url, ur, psd);
              String sql = "select count(id) from users where user=? and password=?";
              ps = conn.prepareStatement(sql);
              ps.setString(1, username);
              ps.setString(2, password);
  
              rs = ps.executeQuery();
              if (rs.next()) {
                  int count = rs.getInt(1);
                  if (count > 0) {
                      out.println("登陆成功：" + username);
                  } else {
                      out.println("登陆失败：" + username + "，自己赶紧滚！");
                  }
              }
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
              try {
                  if (rs != null) {
                      rs.close();
                  }
              } catch (SQLException e) {
                  e.printStackTrace();
              }
              try {
                  if (ps != null) {
                      ps.close();
                  }
              } catch (SQLException e) {
                  e.printStackTrace();
              }
              try {
                  if (conn != null) {
                      conn.close();
                  }
              } catch (SQLException e) {
                  e.printStackTrace();
              }
          }
      }
  }
  ```

- idea报错：java.lang.ClassNotFoundException: com.mysql.cj.jdbc.Driver解决方案：

  这是因为没有导入mysql的包，注意：只需要把包复制到对应的lib目录，这点很重要，一定要复制，并且不用配置工程中lib的路径，只需要复制，就行（不复制，怎么配置路径都没用，我试了）

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200414182805564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 运行结果

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020041418341943.png)

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200414183442404.png)

## 5. JSP

### 5.1 JSP概述

- Why?：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200415122337507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- helloword：

  - 新建一个JSP页面，在body节点内的`<%%>`中即可编写java代码

- 建立对JSP的直观认识

  - JSP页面是由HTML语句和嵌套在其中的Java代码组成的一个普通文本文件，JSP页面的文件扩展名必须为.jsp。
  - 在JSP页面中编写的Java代码需要嵌套在`<%`和`%>`中，嵌套在`<%`和`%>`之间的Java代码被称之为**脚本片段**（Scriptlets），没有嵌套在`<%`和`%>`之间的内容被称为JSP的模板元素。
  - JSP中的Java代码可以使用out.println语句将其他Java程序代码缠身的结果字符串输出给客户端，也可以使用System.out.println语句将它们打印到命令行窗口。
  - JSP文件就像普通的HTML文件一样，它们可以**放置在WEB应用程序中的除了WEB-INF及其子目录外的其他任何目录中，JSP页面的访问路径与普通HTML页面的访问路径形式也是完全一样。**
  - 在JSP页面中也可以使用一种称之为**JSP表达式**的元素，只需要将输出的变量或表达式直接封装在`<%=`和`%>`之中，就可以向客户端输出这个变量或表达式的运算结果。**在JSP表达式中嵌套的变量或表达式后面不能有分号。**

- JSP的运行原理：**JSP本质是一个Servlet**

  - WEB容器（Servlet引擎）接收到以.jsp为扩展名的URL的访问请求时，它将把该访问请求交给**JSP引擎**去处理。
  - 每个JSP页面在第一次被访问时，JSP引擎将它翻译成一个Servlet源程序，接着再把这个Servlet源程序编译成Servlet的class类文件，然后再由**WEB容器（Servlet引擎）**像调用普通Servlet程序一样的方式来装载和解释这个由JSP页面翻译成的Servlet程序。
  - JSP规范也没有明确要求JSP中的脚本程序代码必须采用Java语言，JSP中的脚本程序代码可以采用Java语言之外的其他脚本语言来编写，但是，JSP页面最终必须转换成Java Servlet程序。
  - 可以在WEB应用程序正是发布之前，将其中的所有JSP页面预先编译成Servlet程序。

### 5.2 JSp页面的9个隐含对象

- JSP页面的9个隐含变量：没有声明就可以使用的对象

  1. **out**： JspWriter对象，调用out.println()直接把字符串打印到浏览器上

  2. **request**：HttpServletRequest对象

  3. **response**：HttpServletResponse对象(在jsp页面几乎用不到)

  4. **pageContext**：页面上下文，是pageContext的一个对象，可以从该对象中获取其他对象信息（可以从该对象获取到其他8个隐含对象，也可以从中获取到当前页面的其他信息，学习自定义标签时使用）

  5. **session**：来源于javax.servlet.http.HttpSession。代表浏览器和服务器的一次会话，它用于存储客户端请求的信息，因此它是有状态交互式的。

  6. **application**：代表当前web应用，来源于javax.servlet.servletcontext

  7. **config**：来源于ServletConfig，它包含了当前JSP/Servlet所在的WEB应用的配置信息，若需要访问当前jsp配置的初始化参数，需要通过映射才可以（开发的时候几乎不用）

      ```xml
      <servlet>
          <servlet-name>hellojsp</servlet-name>
          <jsp-file>/hello.jsp</jsp-file>
          <init-param>
              <param-name>test</param-name>
            <param-value>testValue</param-value>
          </init-param>
      </servlet>
      <servlet-mapping>
          <servlet-name>hellojsp</servlet-name>
          <url-pattern>/hellojsp</url-pattern>
      </servlet-mapping>
      ```
  
  8. **page**：指向当前jsp对应的Servlet对象的引用，但为Object类型，只能调用Object类方法（几乎不使用）
  
  9. **exception**：用于捕获JSP抛出的异常。它只有在JSP页面属性isErrorPage=true时才可用。
  
      ```jsp
      <%@ page contentType="text/html;charset=UTF-8" language="java" %>
      <%@ page isErrorPage="true" %>
      <html>
      <head>
          <title>Title</title>
      </head>
      <body>
      <%
          exception.printStackTrace();
      %>
      </body>
      </html>
      ```
  
- **常用的对象（对属性作用于的范围从小到大）：pageContext，request，session，application**

- 其他对象：out，response，config，page，exception

### 5.3 JSP语法

- JSP模板元素
  - JSP页面中的静态HTML内容称之为JSP模板元素，在静态的HTML内容之中可以嵌套JSP的其他各种元素来产生动态内容和执行业务逻辑。
  - JSP模板元素定义了网页的基本骨架，即定义了页面的结构和外观。
  
- 相关编码问题：[参考链接](https://blog.csdn.net/fengqing5578/article/details/80648753)

- JSP表达式
  - JSP表达式（expression）提供了将一个java变量或表达式的计算结果输出到客户端的简化方式，它将要输出的变量或表达式直接封装在`<%=`和`%>`之中。（如：Current time: <%= new java.util.Date() %>）
  
  - JSP表达式中的变量或表达式的计算结果将被转换成一个字符串，然后被插入进整个JSP页面输出结果的相应位置处。
  
  - JSP表达式中的变量或表达式后面不能有分号（;），JSP表达式被翻译成Servlet程序中的一条out.print()语句。
  
    ```jsp
    <%@ page import="java.util.Date" %><%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/4/17
      Time: 9:34
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
    <head>
        <title>Title</title>
    </head>
    <body>
    <%
        Date date = new Date(System.currentTimeMillis());
        out.println(date);
    %>
    <br>
    <%= date %>
    </body>
    </html>
    ```
  
- JSP脚本片段

  - JSP脚本片段（scriptlet）是指嵌套在`<%`和`%>`之间的一条或多条Java程序代码。

  - 在JSP脚本片段中，可以定义变量、执行基本的程序运算、调用其他Java类、访问数据库、访问文件系统等普通Java程序所能实现的功能。

  - 在JSP脚本片段可以直接使用JSP提供的隐式对象来完成WEB应用程序特有的功能。

  - JSP脚本片段中的Java代码**将被原封不动地搬移进由JSP页面所翻译成的Servlet的jspService方法中**，所以，JSP脚本片段之中只能是符合Java语法要求的程序代码，除此之外的任何文本、HTML标记、其他JSP元素都必须在脚本片段之外编写。

  - JSP脚本片段中的Java代码必须严格遵循Java语法，例如，每条命令执行语句后面必须用分号（;）结束。

  - 在一个JSP页面中可以由多个脚本片段（每个脚本片段代码嵌套在各自独立的一对`<%`和`%>`之间），在两个或多个脚本片段之间可以嵌入文本、HTML标记和其他JSP元素。

    ```jsp
    <%@ page import="java.util.Date" %><%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/4/17
      Time: 9:34
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" language="java" pageEncoding="UTF-8" %>
    <html>
    <head>
        <title>Title</title>
    </head>
    <body>
    <%
        Date date = new Date(System.currentTimeMillis());
        out.println(date);
    %>
    <br>
    <%= date %>
    <%
        String ageStr = request.getParameter("age");
        Integer age = Integer.parseInt(ageStr);
        if (age >= 18) {
    %>
    成人...
    <%
        } else {
            out.print("未成年人！");
        }
    %>
    </body>
    </html>
    ```

- JSP声明

  - JSP声明将Java代码封装在`<%!`和`%>`之中，它里面的代码**将被插入进Servlet的jspService方法的外面**，所以，JSP声明可用于定义JSP页面转换成的Servlet程序的静态代码块、成员变量和方法。（在JSP页面中几乎不用）

  - 多个静态代码块、变量和函数可以定义在一个JSP声明中，也可以分别单独定义在多个JSP声明中。

  - **JSP隐式对象的作用范围仅限于Servlet的jspService方法，所以在JSP声明中不能使用这些隐式对象。**

    ```jsp
    <%!
        void test(){}
    %>
    ```

- JSP注释

  - JSP注释的格式：`<%-- 注释信息 --%>`；HTML注释：`<!-- HTML注释 -->`
  - 区别：JSP注释可以阻止Java代码的执行

### 5.4 域对象的属性操作

- 和属性相关的方法：
    - Object getAttribute(String name)：获取指定的属性
    - Enumeration getAttributeNames()：获取所有属性的名字组成的Enumeration对象
    - removeAttribute(String name)：移除指定的属性。
    - void setAttribute(String name, Object o)：设置属性
- pageContext，request，session，application对象都有这些方法，这四个方法也称之为域对象。
- pageContext：属性的作用范围仅限于当前JSP页面
- request：属性的作用范围仅限于同一个请求（**在有转发的情况下可以跨页面获取属性值**）
- session：属性的作用范围仅限于一次会话（浏览器打开直到关闭称之为一次会话（在此期间会话不失效））
- application：getServletConfig()，属性的作用范围仅限于当前WEB应用，是范围最大的属性作用范围，只要在一处设置属性，在其他各处的JSP或Servlet中都可以获取。
- 测试代码就不写了，主要是为了了解四个对象的作用域的区别。

### 5.5 请求的转发和重定向

- 本质区别：**请求的转发只发出了一次请求；而重定向则发出了两次请求**

- 具体特点：

  1. 转发：地址栏是初次发出请求的地址。

     重定向：地址栏不再是初次发出的请求地址，地址栏为最后响应的地址。

  2. 转发：在最终的Servlet中，request对象和中转的那个request是同一个对象。

     重定向：request不是同一个对象。

  3. 转发：只能转发给当前WEB应用的资源（内部资源）。

     重定向：可以重定向到任何资源。

  4. 转发：/ 代表的是当前WEB应用的根目录。

     重定向：/ 代表的是当前WEB站点的根目录。

- 根目录：

  - 当前WEB应用的根目录：`http://localhost:8080/app3`
  - 站点的根目录：`http://localhost:8080`

- 测试结果

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200417144910573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  > 问题：如果控制台输出中文乱码
  >
  > 解决办法：设置Tomcat 的配置中VM option加上：`-Dfile.encoding=GBK`
  >
  > [参考连接](https://blog.csdn.net/rznice/article/details/41006913)，有时候UTF-8没用还是乱码，我测试后发现GBK有效

- RequestDispatcher接口

  - RequestDispatcher实例对象是由Servlet引擎创建的，它用于包装一个要被其他资源调用的资源（例如，Servlet、HTML文件、JSP文件等），并可以通过其中的方法将客户端的请求转发给所包装的资源。

  - RequestDispatcher接口中定义了两个方法：forward方法和include方法

  - forward方法和include方法接受的两个参数必须是传递给当前Servlet的service方法的那两个ServletRequest和ServletResponse对象，或者是对它们进行了包装的ServletRequestWrapper或ServletResponseWrapper对象。

  - 获取RequestDispatcher对象的方法：

    - ServletContext.getRequestDispatcher(**参数只能是以"/"开头的路径**)
    - ServletContext.getNamedDispatcher
    - ServletRequest.getRequestDispatcher(**参数可以是不以"/"开头的路径**)

  - 在实际操作的过程中可以不配置web.xml，而是通过类前加入注释的方式，达到配置的效果[参考连接](https://www.zhihu.com/question/45118798)

    ```java
    @WebServlet(name = "TestServlet", urlPatterns = "/testServlet")
    ```
    
  - 在配置的时候一定要注意加`/`，不然就会报错：`java.lang.IllegalStateException: Error starting child`

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421194824520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 转发和重定向测试代码

  - 转发Servlet（这里采用的是配置web.xml文件）

    ```java
    package com.litian.test;
    
    import javax.servlet.RequestDispatcher;
    import javax.servlet.ServletException;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ${NAME}.java
     * @time: 2020/4/17 14:18
     * @desc: |
     */
    
    public class ForwardServlet extends HttpServlet {
        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    
        }
    
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            System.out.println("ForwardServlet's doGet! ↓");
    
            request.setAttribute("name", "ForwardServlet");
            System.out.println(request.getAttribute("name"));
    
            // 请求的转发
            // 1. 调用HttServletRequest的getRequestDispatcher()方法获取RequestDispatcher对象
            // 调用getRequestDispatcher()需要传入要转发的地址
            String path = "testServlet";
            RequestDispatcher rd = request.getRequestDispatcher("/" + path);
    
            // 2. 调用HttpServletRequest的forward(request, response)方法进行请求的转发
            rd.forward(request, response);
        }
    }
    ```

  - 重定向Servlet（这里采用的是配置注释文件）

    ```java
    package com.litian.test;
    
    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ${NAME}.java
     * @time: 2020/4/17 14:31
     * @desc: |
     */
    
    @WebServlet(name = "RedirectServlet", urlPatterns = "/redirectServlet")
    public class RedirectServlet extends HttpServlet {
        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    
        }
    
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            System.out.println("RedirectServlet's doGet method! ↓");
    
            request.setAttribute("name", "RedirectServlet");
            System.out.println(request.getAttribute("name"));
    
            // 执行请求的重定向，直接调用response的sendRedirect方法
            // 其中path为要重定向的地址
            String location = "testServlet";
            response.sendRedirect(location);
        }
    }
    ```

  - 目标页面

    ```java
    package com.litian.test;
    
    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ${NAME}.java
     * @time: 2020/4/17 14:26
     * @desc: |
     */
    
    @WebServlet(name = "TestServlet", urlPatterns = "/testServlet")
    public class TestServlet extends HttpServlet {
        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    
        }
    
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            System.out.println("testServlet's doGet method! ↓");
            System.out.println(request.getAttribute("name"));
        }
    }
    ```

  - abc的测试用例我写了，就不粘了，都是为了说明，转发和重定向的区别的，转发是在b网页显示c的内容，重定向是在c网页显示c的内容。（代码传到github上面了）

### 5.6 JSP指令

- JSP指令（directive）是为JSP引擎而设计的，它们并不直接产生任何可见输出，而只是**告诉引擎如何处理JSP页面中的其余部分**。

- JSP指令的基本语法格式：`<%@ 指令 属性名="值" %>`

  举例：`<%@ page contentType="text/html;charset=gb2312" %>`

  注意：属性名部分是大小写敏感的

- 在目前的JSP2.0中，定义了**page、include和taglib**这三种指令，每种指令中又定义了一些各自的属性。

- 如果要在一个JSP页面中设置同一个条指令的多个属性，可以使用多条指令语句单独设置每个属性，也可以使用同一条指令语句设置该指令的多个属性。

  第一种：

  ```jsp
  <%@ page contentType="text/html;charset=gb2312" %>
  <%@ page import="java.util.Date" %>
  ```

  第二种：

  ```jsp
  <%@ page contentType="text/html;charset=gb2312" import="java.util.Date" pageEncoding="utf-8" %>
  ```

- **Page指令**

  - page指令用于定义JSP页面的各种属性，无论page指令出现在JSP页面中的什么地方，它作用的都是整个JSP页面，为了保持程序的可读性和遵循良好的编程习惯，**page指令最好是放在整个JSP页面的起始位置**。

  - JSP2.0规范中定义的page指令的完整语法：

    ```jsp
    <%@ page
        [language="java"]
        [extends="package.class"]
        [import="{package.class | package.*}, ..."]
        [session="true | false"]
        [buffer="none | 8kb | sizekb"]
        [autoFlush="true | false"]
        [isThreadSafe="true | false"]
        [info="text"]
        [errorPage="relative_url"]	# 错误页面的地址（该页面有错之后转到的页面），转发机制
        [isErrorPage="true | false"]	# 该页面是否是错误页面，设置之后就可以用exception了，测试中就可以输出 <% exception.getMessage() %> 来输出错误信息
        [contentType="mimeType [;charset=characterSet]" | "text/html; charset=ISO-8859-1"]
        [pageEncoding="characterSet | ISO-8859-1"]
        [isELIgnored="true | false"]
    %>
    ```

  - page指令常用的属性：
  
    - import：指定当前JSP页面对应的Servlet需要导入的类。
  
    - session：取值为true或false，指定当前页面的session隐藏变量是否可用，也可以说访问当前页面时是否一定要生成HttpSession对象。
  
    - errorPage和isErrorPage：
  
      - errorPage指定若当前页面出现错误的实际响应页面是什么，其中/表示的是当前WEB应用的根目录，`<%@ page errorPage="/error.jsp" %>`
  
      - 在响应error.jsp时，在JSP引擎使用的是请求转发的方式。
  
      - isErrorPage指定当前页面是否为错误处理页面，可以说明当前页面是否可以使用exception隐藏变量，需要注意的是：若指定isErrorPage="true"，并使用exception的方法，一般不建议能够直接访问该页面。（也就是用转发而不是重定向）
  
      - 如何使客户不能直接访问某一个页面呢？对于tomcat服务器而言，WEB-INF下的文件时不能通过在浏览器中直接输入地址的方式来访问的。
  
      - 还可以在web.xml文件中配置错误页面
  
        ```xml
        <error-page>
            <!-- 指定出错的代码：404没有指定的资源，500内部错误 -->
            <error-code>404</error-code>
            <!-- 指定响应页面的位置 -->
            <location>/hello.jsp</location>
        </error-page>
        
        <error-page>
            <!-- 指定异常的类型 -->
            <exception-type>java.lang.ArithmeticException</exception-type>
            <location>/WEB-INF/error.jsp</location>
        </error-page>
        ```
  
    - contentType：指定当前JSP页面的响应类型，实际调用的是`response.setContentType("text/html; charset=UTF-8");`通常情况下，对于JSP页面而言，其取值均为`response.setContentType("text/html; charset=UTF-8");`
  
      - charset：指定返回的页面的字符编码是什么，通常取值为UTF-8
  
    - pageEncoding：指定当前JSP页面的字符编码，通常情况下该值和contentType中的charset一致。
  
    - isELIgnored：指定当前JSP页面是否可以使用EL表达式，通常取值为false，表示不忽略。
  
- **include指令**

  - inlude指令用于通知JSP引擎**在翻译当前JSP页面时**将其他文件的内容合并进当前JSP页面转换成的Servlet源文件中，这种在源文件级别进行引入的方式称之为静态引入，**当前JSP页面与静态引入的页面紧密结合为一个Servlet**。
  
  - 语法：`<%@ include file="relativeURL" %>`，其中的file属性用于指定被引入文件的**相对路径**。**推荐使用`/`的方式来包含页面**，使用绝对路径肯定没问题，使用相对路径可能会有问题！
  
  - 细节1：
    - 被引入的而文件必须遵循JSP语法，其中的内容可以包含静态HTML、JSP脚本元素、JSP指令和JSP行为元素等普通JSP页面所具有的一切内容。
    - 被引入的文件可以使用任意的扩展名，即使其扩展名是html，JSP引擎也会按照处理jsp页面的方式处理它里面的内容，为了见名知意，JSP规范建议使用.jspf（JSP fragments）最为静态引入文件的扩展名。
    - 在将JSP文件翻译成Servlet源文件时，JSP引擎将合并被引入的文件与当前JSP页面中的指令元素（**设置pageEncoding指令除外**），所以，**除了import和pageEncoding属性之外，page指令的其他属性不能在这两个页面中有不同的设置值。**
    
  - 细节2：
  
    - 除了指令元素之外，被引入的文件中的其他元素都被转换成相应的Java源代码，然后插入进当前的JSP页面所翻译成的Servlet源文件中，插入位置与include指令在当前JSP页面中的位置保持一致。
    - **引入文件与被引入文件时在被JSP引擎翻译成Servlet的过程中进行合并，而不是先合并源文件后再对合并的结果进行翻译。**当前JSP页面的源文件与被引入文件的源文件可以采用不同的字符集编码，即使在一个页面中使用page指令的pageEncoding或contentType属性指定了其源文件的字符集编码，在另外一个页面中还需要用page指令的pageEncoding或contentType属性指定其源文件所使用的的字符集。
    - Tomcat5.x在访问JSP页面时，可以检测它所引入的其他文件是否发生了修改，如果发生了修改，则重新编译当前JSP页面。
    - **file属性的设置值必须使用相对路径**，如果以`/`开头，表示相对于当前WEB应用程序的根目录（注意不是站点根目录），否则，表示相对于当前文件。
  
  - 代码：在a.jsp文件中通过include指令插入b.jsp
  
    - a.jsp
  
      ```jsp
      <%--
        Created by IntelliJ IDEA.
        User: Administrator
        Date: 2020/4/19
        Time: 13:16
        To change this template use File | Settings | File Templates.
      --%>
      <%@ page contentType="text/html;charset=UTF-8" language="java" %>
      <html>
      <head>
          <title>a</title>
      </head>
      <body>
      <h3>aaa page</h3>
      <% String ss = "what!";%>
      <%-- 在a.jsp 中包含b.jsp --%>
      <%@ include file="b.jsp" %>
      </body>
      </html>
      ```
  
    - b.jsp
  
      ```jsp
      <%--
        Created by IntelliJ IDEA.
        User: Administrator
        Date: 2020/4/19
        Time: 13:16
        To change this template use File | Settings | File Templates.
      --%>
      <%@ page contentType="text/html;charset=UTF-8" language="java" %>
      <html>
      <head>
          <title>b</title>
      </head>
      <body>
      <h3>bbb page</h3>
      <%= ss %>
      </body>
      </html>
      ```
  
    - 运行结果
  
      ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020041923014836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
  

### 5.7 JSP标签

- 概念

  - JSP还提供了一种称之为Action的元素，在JSP页面中使用Action元素**可以完成各种通用的JSP页面功能**，也可以实现一些处理复杂业务逻辑的专用功能。
  - Action元素采用XML元素的语法格式，即每个Action元素在JSP页面中都已XML标签的形式出现。
  - JSP规范中定义了一些标准的Action元素，这些元素的**标签名都以jsp作为前缀，并且全部采用小写**，例如：`<jsp:include>、<jsp:forward>`等等。

- `<jsp:include>`标签

  - 用于把另外一个资源的输出内容插入进当前JSP页面的输出内容中，这种在**JSP页面执行的引入方式称之为动态引入**。
  - 语法：`<jsp:include page="relativeURL | <%= expression %>" flush="true|false" />`
  - 实用：`<jsp:include page="b.jsp"></jsp:include>`
  - page属性用于指定被引入资源的**相对路径**，它也可以通过执行一个表达式来获得。
  - flush属性指定在插入其他资源的输出内容时，是否先将当前JSP页面的已输出内容刷新到客户端。
  - **区别简述**：并不是像include指令一样生成一个Servlet源文件，而是生成两个Servlet源文件，然后通过一个方法的方式把目标页面包含进来。

- `<jsp:include>`标签与include指令的比较（理解，记住上面简单区别就行）

  - `<jsp:include>`标签是在当前JSP页面的**执行期间**插入被引入资源的输出内容，当前JSP页面与被动态引入的资源时两个彼此独立的执行实体，**被动态引入的资源必须是一个能独立被WEB容器调用和执行的资源**。include指令只能引入遵循JSP格式的文件，被引入文件与当前JSP文件共同合并被翻译成一个Servlet的源文件。
  - 使用`<jsp:include>`标签和include指令都可以把一个页面的内容分成多个组件来生成，开发者不必再把页眉和页脚部分的相同HTML代码复制到每个JSP文件中，从而可以更轻松地完成维护工作，但是**都应注意最终的输出结果内容应遵循HTML语法结构**，例如：如果当前页面产生了`<html>、</html>、<body>、</body>`等标记，那么在被引入文件中就不能再输出`<html>、</html>、<body>、</body>`等标记。
  - **`<jsp:include>`标签对JSP引擎翻译JSP页面的过程不起作用**，它是在JSP页面的执行期间才被调用，因此不会影响两个页面的编译。由于**include指令是在JSP引擎翻译JSP页面的过程中被解释处理的，所以它对JSP引擎翻译JSP页面的过程起作用**，如果多个JSP页面中都要用到一些相同的声明，那么就可以把这些声明语句放在一个单独的文件中编写，然后在每个JSP页面中使用include指令将那个文件包含进来。

- `<jsp:forward>`标签

  - `<jsp:forward page="/include/b.jsp"></jsp:forward>`

  - 相当于

    ```jsp
    <%
        request.getRequestDispatcher("/include/b.jsp").forward(request, response);
    %>
    ```

  - 但使用jsp:forward可以使用jsp:param子标签向b.jsp传入一些参数。同样jsp:include也可以使用jsp:param子标签。**即在目标jsp页面，可以通过`request.getParameter("参数名")`获取到传入的请求参数**

    ```jsp
    a.jsp
    <jsp:forward page="/include2/b.jsp">
        <jsp:param name="username" value="abcd"/>
    </jsp:forward>
    
    b.jsp
    <%= request.getParameter("username") %>
    ```

### 5.8 JSP中文乱码问题

1. 在JSP页面上输入中文，请求页面后不出现乱码：保证 `contentType="text/html;charset=UTF-8" pageEncoding="UTF-8"`。即charset和pageEncoding的编码一致，且都支持中文。通常建议取值为UTF-8。同时还需要保证浏览器的显示的字符编码也和请求的JSP页面的编码一致。

2. 获取中文参数值：默认参数在传输过程中使用的编码为ISO-8859-1

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200420162336515.png)

   - 对于POST请求：设置请求的编码为UTF-8：`request.setCharacterEncoding("UTF-8");`（在获取请求参数之前使用）

   - 对个GET请求：前面的方式对GET无效，先解码再编码（这里我get请求中文是正常的）；或者通过修改Tomcat的server.xml文件的方式：为connector节点添加userBodyEncodingForURI属性，并设置为true。

     ```jsp
     <%
         String val = request.getParameter("username");
         String username = new String(val.getBytes("iso-8859-1"), "UTF-8");
         out.print(username);
     %>
     ```

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200420162439955.png)

## 6. MVC设计模式

- JavaEE开发中常见的组件：beanutils、dbcp、dbutils、fileipload、logging、hibernate、jbpm

- JavaEE开发流程（Servlet）：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421174047179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- JavaEE开发流程（JSP）：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020042117423629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- MVC处理过程，图中转向是转发或重定向：

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421174335538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- MVC是Model-View-Controller的简称，即模型-视图-控制器。

- MVC是一种设计模式，它把应用程序分成三个核心模块：模型、视图、控制器，它们各自处理自己的任务。

  - 模型：
    - 模型是应用程序的主体部分，模型表示业务数据和业务逻辑。
    - 一个模型能为多个视图提供数据。
    - 由于应用于模型的代码只需写一次就可以被多个视图重用，所以提高了代码的**可重用性**。
  - 视图：
    - 视图是用户看到并与之交互的界面，作用如下：
      - 视图向用户显示相关的数据
      - 接受用户的输入
      - 不进行任何实际的业务处理
  - 控制器：
    - 控制器接受用户的输入并调用模型和视图去完成用户的需求
    - 控制器接受请求并决定调用哪个模型组件去处理请求，然后决定调用哪个视图来显示模型处理返回的数据

### 6.1 MVC案例1：查询

- 技术路线

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421180618350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 代码：在test.jsp点击链接查看学生信息的表格

  - test.jsp，点击后转到`/listAllStudents`链接

    ```jsp
    <%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/4/21
      Time: 19:20
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
    <head>
        <title>Test</title>
    </head>
    <body>
    <a href="listAllStudents">List All Students</a>
    </body>
    </html>
    ```

  - 学生类

    ```java
    package com.litian.mvc;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Student.java
     * @time: 2020/4/21 19:57
     * @desc: |
     */
    
    public class Student {
        private Integer id;
        private String user;
        private String password;
    
        public Student() {
        }
    
        public Student(Integer id, String user, String password) {
            this.id = id;
            this.user = user;
            this.password = password;
        }
    
        public Integer getId() {
            return id;
        }
    
        public void setId(Integer id) {
            this.id = id;
        }
    
        public String getUser() {
            return user;
        }
    
        public void setUser(String user) {
            this.user = user;
        }
    
        public String getPassword() {
            return password;
        }
    
        public void setPassword(String password) {
            this.password = password;
        }
    }
    ```

  - 操作数据库获取信息的方法

    ```java
    package com.litian.mvc;
    
    import java.sql.Connection;
    import java.sql.DriverManager;
    import java.sql.PreparedStatement;
    import java.sql.ResultSet;
    import java.util.ArrayList;
    import java.util.List;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: StudentDao.java
     * @time: 2020/4/21 20:00
     * @desc: |
     */
    
    public class StudentDao {
        public List<Student> getAll(){
    
            List<Student> students = new ArrayList<>();
    
            Connection conn = null;
            PreparedStatement ps = null;
            ResultSet rs = null;
    
            try {
                String driverClass = "com.mysql.cj.jdbc.Driver";
                String url = "jdbc:mysql://localhost:3306/test_users?serverTimezone=GMT%2B8";
                String user = "root";
                String password = "123456";
                Class.forName(driverClass);
                conn = DriverManager.getConnection(url, user, password);
    
                String sql = "select id, user, password from users";
    
                ps = conn.prepareStatement(sql);
                rs = ps.executeQuery();
    
                while(rs.next()){
                    int id = rs.getInt(1);
                    String username = rs.getString(2);
                    String psd = rs.getString(3);
    
                    Student st = new Student(id, username, psd);
                    students.add(st);
                }
    
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                try{
                    if(rs != null){
                        rs.close();
                    }
                }catch (Exception e){
                    e.printStackTrace();
                }
                try{
                    if(ps != null){
                        ps.close();
                    }
                }catch (Exception e){
                    e.printStackTrace();
                }
                try{
                    if(conn != null){
                        conn.close();
                    }
                }catch (Exception e){
                    e.printStackTrace();
                }
            }
            return students;
        }
    }
    ```

  - `/listAllStudents`链接的Servlet，目的是转发请求到页面`/students.jsp`，请求中包含students的信息

    ```java
    package com.litian.mvc;
    
    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;
    import java.util.Arrays;
    import java.util.List;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ${NAME}.java
     * @time: 2020/4/21 19:21
     * @desc: |
     */
    
    @WebServlet(name = "ListAllStudentsServlet", urlPatterns = "/listAllStudents")
    public class ListAllStudentsServlet extends HttpServlet {
        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    
        }
    
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // request.setAttribute("lists", Arrays.asList("AA", "BB", "CC"));
            // request.getRequestDispatcher("/students.jsp").forward(request, response);
    
            StudentDao sd = new StudentDao();
            List<Student> students = sd.getAll();
    
            request.setAttribute("students", students);
            request.getRequestDispatcher("/students.jsp").forward(request, response);
        }
    }
    ```

  - `/students.jsp`页面，获取请求中的参数，显示信息，由于是转发而不是重定向，所以最终显示的地址是`http://localhost:8080/MVCApp/listAllStudents`而不是`/students.jsp`

    ```jsp
    <%@ page import="com.litian.mvc.Student" %>
    <%@ page import="java.util.List" %><%--
      Created by IntelliJ IDEA.
      User: Administrator
      Date: 2020/4/21
      Time: 19:23
      To change this template use File | Settings | File Templates.
    --%>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
    <head>
        <title>Students</title>
    </head>
    <body>
    <%--
    <%=
    request.getAttribute("lists")
    %>
    <br><br>
    <%
        List<String> names = (List) request.getAttribute("lists");
        for (String name : names) {
            out.print(name + "<br>");
        }
    %>
    --%>
    
    <%
        List<Student> stus = (List<Student>) request.getAttribute("students");
    %>
    
    <table>
        <tr>
            <th>id</th>
            <th>user</th>
            <th>password</th>
        </tr>
        <%
            for (Student st : stus) {
        %>
        <tr>
            <td><%= st.getId() %></td>
            <td><%= st.getUser() %></td>
            <td><%= st.getPassword() %></td>
        </tr>
    
        <%
            }
        %>
    </table>
    </body>
    </html>
    ```

  - 部署成功

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421203705862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 6.2 MVC案例2：删除

- 





------

我的CSDN：https://blog.csdn.net/qq_21579045

我的博客园：https://www.cnblogs.com/lyjun/

我的Github：https://github.com/TinyHandsome

纸上得来终觉浅，绝知此事要躬行~

欢迎大家过来OB~

by 李英俊小朋友
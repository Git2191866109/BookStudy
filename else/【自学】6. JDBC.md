# 尚硅谷JDBC学习笔记

[TOC]

## 写在前面

学习链接：[Java JDBC 视频教程全集](https://www.bilibili.com/video/av59534040/)

学习体会：

1. 我觉得废话有点多，同一个知识点翻来覆去的讲，并且有的疑点还没解决。比如说：比如说：利用Driver和DriverManager都能用不同的数据库，为什么DriverManager更好。视频中说的两个优点我觉得Driver也能做到啊，没搞懂为什么。
2. 由于本人已经学过了高琪老师的java300集，其中包括了JDBC的内容，因此仅以此视频作为查漏补缺。
3. 视频中涉及到的练习，进行了简化学习。
4. 学到第8集的时候发现，很多知识点都是基于作业进行的，而作业我并没有做，只是简单的跟着老师敲代码，老师怎么敲我就怎么敲。因此当老师在用Student举例的时候，我用的还是高琪老师java300集中的t_user跟着学，并且很多知识点结构较差，不知道怎么就突然学到这点了，觉得跨越的幅度很大。因为我在java300集中学过，所以还可以接受，但是看到弹幕里面说整个人都蒙了，我表示理解。
5. 在利用反射进行查询的时候，涉及到数据库的列名跟类的属性不一致的问题。
   - 高琪老师的java300集中：类是根据数据库创建，并自动生成的。
   - 该视频中：类是自己建的，数据库也是自己的，名字不一致就给数据库的的列名起别名解决
   - 我觉得该视频的方式不好，既不如上面简单，又不如上面方便。
   - 另外，该视频中在用map内容创建反射对象的时候，直接调用了以前写过的ReflectionUtils工具，我知道是什么意思和原理（根据列名和属性名对应，获取属性名对应的set方法，利用反射调用set方法将map中对应属性的值进行赋值，这样就将map的内容赋给了object对象，即clazz.newInstance()，最后得到了目标对象），但是没学过的人就会一脸懵逼。
6. 由于本视频讲解的结构很乱（不是指大纲乱，而是老师在讲的时候，东一下，西一下，一会这个文件一会儿那个文件，还常用复制粘贴，**特别是多个知识点在一个类中通过各种函数、测试函数讲解，这点我真的吐了**），因此我的笔记相对于较乱，请读者轻喷。
7. 讲的太啰嗦了，一个知识点在讲的时候翻来覆去的讲，注释写了一遍又一遍，并且最后还会回过头来小结。（细致和啰嗦的度不好把握，看个人吧，勿喷，比如PreparedStatement就是一遍又一遍的讲）
8. 老师还是讲的很细致的，比如讲ResultSetMetaData的时候，就会讲为什么要用，这个是什么，怎么用。我觉得这一点还是很不错的，比高琪老师要好，但是讲一遍就行了，我印象里是讲了至少3遍。
9. 学到12集重构DAO的时候，就觉得老师的讲课逻辑真的不行，前面写了最后重构竟然是在原来的基础上改的，这个行为真的不好；其次就是感觉想到哪儿写到哪儿，指哪儿改哪儿，查询多条记录写完了才想起来查询一条记录可以直接简化，好像没有备课的感觉。

## 1. 通过Driver接口获取数据库连接

- 数据持久化

- 数据库存取技术分类

  - JDBC直接访问数据库
  - JDO技术
  - 第三方O/R工具，如Hibernate，ibatis等

- JDBC是java访问数据库的基石

- JDBC（Java Database Connectivity）是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口。

   ![img](https://img-blog.csdnimg.cn/20191210182445192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
   
- JDBC接口（API）包括两个层次：

   - 面向应用的API：java api，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。
   - 面向数据库的API：java driver api，供开发商开发数据库驱动程序用。

- JDBC试验，Driver是一个接口：数据库厂商必须提供实现的接口，能从其中获取数据库连接。

- 可以通过Driver的实现类对象获取数据库连接

   - 加入mysql驱动
      - 解压mysql-connector-java.zip
      - 在挡墙项目下新建lib目录
      - 吧.jar文件复制到lib目录下
      - 右键buildpath，add to buildpath加入到类路径下
   - JDBC的URL的标准由三部分组成，各部分间用冒号分隔。
      - jdbc:<子协议>:<子名称>
      - 协议：JDBC URL中的协议总是jdbc
      - 子协议：子协议用于标识一个数据库驱动程序
      - 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。
   - 遇到的问题：
      - 进不去，各种报错：可能是密码错误了。[参考](https://blog.csdn.net/QQ17680473835/article/details/81841180)
      - time zone错误：[参考](https://blog.csdn.net/qq_19332219/article/details/102847809)

   ```java
   package com.litian.jdbc;
   import java.sql.Connection;
   import java.sql.Driver;
   import java.sql.SQLException;
   import java.util.Properties;
   
   
   /**
    * @author: Li Tian
    * @contact: litian_cup@163.com
    * @software: IntelliJ IDEA
    * @file: JDBCTest.java
    * @time: 2019/12/15 18:56
    * @desc: JDBC试验，Driver是一个接口：数据库厂商必须提供实现的接口，能从其中获取数据库连接。
    */
   
   public class JDBCTest {
       public static void main(String[] args) throws SQLException {
           // 1. 创建一个Driver实现类的对象
           Driver driver = new com.mysql.jdbc.Driver();
           // 2. 准备连接数据库的基本信息：url，user，password
           String url = "jdbc:mysql://localhost:3306/girls";
           Properties info = new Properties();
           info.put("user", "root");
           info.put("password", "tian19951103");
   
           // 3. 调用Driver接口的connect(url, info)获取数据库连接
           Connection connection = driver.connect(url, info);
           System.out.println(connection);
       }
   }
   ```

- 编写一个通用的方法，在不修改源程序的情况下，可以获取任何数据库的连接

- 解决方案：把数据库驱动Driver 实现类的全类名、url、user、password放入一个配置文件中，通过修改配置文件的方式实现和具体的数据库解耦。

   - jdbc.properties

      ```properties
      driver=com.mysql.jdbc.Driver
      jdbcUrl=jdbc:mysql://localhost:3306/girls
      user=root
      password=tian19951103
      ```

   - JDBCTest

      ```java
      package com.litian.jdbc;
      
      import java.io.InputStream;
      import java.sql.Connection;
      import java.sql.Driver;
      import java.sql.SQLException;
      import java.util.Properties;
      
      
      /**
       * @author: Li Tian
       * @contact: litian_cup@163.com
       * @software: IntelliJ IDEA
       * @file: JDBCTest.java
       * @time: 2019/12/15 18:56
       * @desc: JDBC试验，Driver是一个接口：数据库厂商必须提供实现的接口，能从其中获取数据库连接。
       */
      
      public class JDBCTest {
      
          public void test1() throws SQLException {
              // 1. 创建一个Driver实现类的对象
              Driver driver = new com.mysql.jdbc.Driver();
              // 2. 准备连接数据库的基本信息：url，user，password
              String url = "jdbc:mysql://localhost:3306/girls";
              Properties info = new Properties();
              info.put("user", "root");
              info.put("password", "tian19951103");
      
              // 3. 调用Driver接口的connect(url, info)获取数据库连接
              Connection connection = driver.connect(url, info);
              System.out.println(connection);
          }
      
          // 编写一个通用的方法，在不修改源程序的情况下，可以获取任何数据库的连接
          public Connection getConnection() throws Exception {
              String driverClass = null;
              String jdbcUrl = null;
              String user = null;
              String password = null;
      
              // 读取类路径下的jdbc.propertites 文件
              InputStream in = getClass().getClassLoader().getResourceAsStream("jdbc.properties");
              Properties properties = new Properties();
              properties.load(in);
              driverClass = properties.getProperty("driver");
              jdbcUrl = properties.getProperty("jdbcUrl");
              user = properties.getProperty("user");
              password = properties.getProperty("password");
      
              Driver driver = (Driver) Class.forName(driverClass).newInstance();
      
              Properties info = new Properties();
              info.put("user", user);
              info.put("password", password);
              Connection connection = driver.connect(jdbcUrl, info);
      
              return connection;
          }
      
          public void testGetConnection() throws Exception {
              System.out.println(getConnection());
          }
      
          public static void main(String[] args) throws Exception {
              new JDBCTest().testGetConnection();
          }
      }
      ```

## 2. 通过DriverManager获取数据库连接

- 修改一下配置文件

  ```properties
  driver=com.mysql.cj.jdbc.Driver
  jdbcUrl=jdbc:mysql://localhost:3306/testjdbc?serverTimezone=GMT%2B8
  user=root
  password=123456
  ```

- 代码（我觉得废话有点多，同一个知识点翻来覆去的讲，并且有的疑点还没解决）

- 比如说：利用Driver和DriverManager都能用不同的数据库，为什么DriverManager更好

  ```java
  package com.litian.jdbc;
  
  import java.io.InputStream;
  import java.sql.Connection;
  import java.sql.Driver;
  import java.sql.DriverManager;
  import java.sql.SQLException;
  import java.util.Properties;
  
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: JDBCTest.java
   * @time: 2019/12/15 18:56
   * @desc: JDBC试验，Driver是一个接口：数据库厂商必须提供实现的接口，能从其中获取数据库连接。
   */
  
  public class JDBCTest {
  
      public Connection getConnection2() throws Exception {
          // 1. 准备连接数据库的4个字符串。
          // 1.1 创建Properties对象
          Properties properties = new Properties();
          // 1.2 获取jdbc.properties对应的输入流
          InputStream in = this.getClass().getClassLoader().getResourceAsStream("jdbc.properties");
          // 1.3 加载1.2对应的输入流
          properties.load(in);
          // 1.4 具体决定user，password等4个字符串。
          String user = properties.getProperty("user");
          String password = properties.getProperty("password");
          String jdbcUrl = properties.getProperty("jdbcUrl");
          String driver = properties.getProperty("driver");
          // 2. 加载数据库驱动程序
          Class.forName(driver);
          // 3. 通过DriverManager的getConnection()方法获取数据库连接。
          return DriverManager.getConnection(jdbcUrl, user, password);
      }
  
      /**
       * DriverManager是驱动的管理类
       * 1. 可以通过重载的getConnection()方法获取数据库连接。较为方便
       * 2. 可以同时管理多个驱动程序：若注册了多个数据库连接，则调动getConnection()方法时
       *    传入的参数不同，则返回不同的数据库连接
       */
      public void testDriverManager() throws Exception {
          // 1. 准备连接数据库的4个字符串
  
          // 驱动的全类名
          String driverClass = null;
          String jdbcUrl = null;
          String user = null;
          String password = null;
  
          // 读取类路径下的jdbc.propertites 文件
          InputStream in = getClass().getClassLoader().getResourceAsStream("jdbc.properties");
          Properties properties = new Properties();
          properties.load(in);
          driverClass = properties.getProperty("driver");
          jdbcUrl = properties.getProperty("jdbcUrl");
          user = properties.getProperty("user");
          password = properties.getProperty("password");
  
          // 2. 加载数据库驱动程序（对应的Driver实现类中有注册驱动的静态代码块程序）
          // 下面的注册程序已经写好了，不需要自己写
          // DriverManager.registerDriver((Driver) Class.forName(driverClass).newInstance());
          Class.forName(driverClass);
  
          // 3. 通过DriverManager的getConnection()方法获取数据库连接
          Connection connection = DriverManager.getConnection(jdbcUrl, user, password);
          System.out.println(connection);
  
      }
  
      public void test1() throws SQLException {
          // 1. 创建一个Driver实现类的对象
          Driver driver = new com.mysql.jdbc.Driver();
          // 2. 准备连接数据库的基本信息：url，user，password
          String url = "jdbc:mysql://localhost:3306/girls";
          Properties info = new Properties();
          info.put("user", "root");
          info.put("password", "tian19951103");
  
          // 3. 调用Driver接口的connect(url, info)获取数据库连接
          Connection connection = driver.connect(url, info);
          System.out.println(connection);
      }
  
      // 编写一个通用的方法，在不修改源程序的情况下，可以获取任何数据库的连接
      public Connection getConnection() throws Exception {
          String driverClass = null;
          String jdbcUrl = null;
          String user = null;
          String password = null;
  
          // 读取类路径下的jdbc.propertites 文件
          InputStream in = getClass().getClassLoader().getResourceAsStream("jdbc.properties");
          Properties properties = new Properties();
          properties.load(in);
          driverClass = properties.getProperty("driver");
          jdbcUrl = properties.getProperty("jdbcUrl");
          user = properties.getProperty("user");
          password = properties.getProperty("password");
  
          Driver driver = (Driver) Class.forName(driverClass).newInstance();
  
          Properties info = new Properties();
          info.put("user", user);
          info.put("password", password);
          Connection connection = driver.connect(jdbcUrl, info);
  
          return connection;
      }
  
      public void testGetConnection() throws Exception {
          System.out.println(getConnection());
      }
  
      public static void main(String[] args) throws Exception {
          // new JDBCTest().testGetConnection();
          // new JDBCTest().testDriverManager();
          Connection conn = new JDBCTest().getConnection2();
          System.out.println(conn);
      }
  }
  ```

## 3. 通过Statement执行更新操作

- Statement测试

  ```java
  /**
   * 通过JDBC向指定的数据表中插入一条记录
   * 1. Statement：用于执行sql语句的对象
   * 1.1 通过Connection的createStatement()方法来获取
   * 1.2 通过executeUpdate(sql)可以执行SQL语句
   * 1.3 传入的sql可以是insert, update或delete，但不能是select
   * 2. Connection、Statement都是应用程序和数据库服务器的连接资源。使用后一定要关闭。
   * 2.1 需要再finally中关闭
   * 3. 关闭顺序：先获取的后关，后获取的先关
   */
  public void testStatement() {
      Connection conn = null;
      Statement statement = null;
      try {
          // 1. 获取数据库连接
          conn = getConnection2();
          // 2. 准备插入的SQL语句
          String sql = "insert into t_user (username, pwd) values('测试', 3352)";
          String sql2 = "update t_user set username='傻瓜' where id = 20017";
          // 3. 执行插入
          // 3.1 获取操作sql语句的Statement对象
          statement = conn.createStatement();
          // 3.2 调用Statement对象的executeUpdate(sql)执行SQL语句
          statement.executeUpdate(sql);
      } catch (Exception e) {
          e.printStackTrace();
      } finally {
          try {
              if (statement != null) {
                  // 4. 关闭Statement对象
                  statement.close();
              }
          } catch (SQLException e) {
              e.printStackTrace();
          }
          try {
              if (statement != null) {
                  // 5. 关闭Connection对象
                  conn.close();
              }
          } catch (SQLException e) {
              e.printStackTrace();
          }
      }
  }
  ```

- insert/update/delete封装

  ```java
  /**
   * 通用的更新的方法：insert/update/delete
   * 版本1
   */
  public void update(String sql){
      Connection conn = null;
      Statement statement = null;
  
      try {
          conn = getConnection2();
          statement = conn.createStatement();
          statement.executeUpdate(sql);
      }catch (Exception e){
          e.printStackTrace();
      }finally {
          try {
              if (statement != null) {
                  statement.close();
              }
          } catch (SQLException e) {
              e.printStackTrace();
          }
          try {
              if (statement != null) {
                  conn.close();
              }
          } catch (SQLException e) {
              e.printStackTrace();
          }
      }
  }
  ```

- 创建JDBC的工具类，封装方法

  - 工具类

    ```java
    package com.litian.jdbc;
    
    import java.io.InputStream;
    import java.sql.*;
    import java.util.Properties;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: JDBCUtils.java
     * @time: 2020/3/21 15:23
     * @desc: |操作JDBC的工具类，其中封装了一些工具方法
     * Version1
     */
    
    public class JDBCTools {
    
        /**
         * 关闭Statement和Connection的方法
         */
        public static void release(Statement statement, Connection conn) {
            try {
                if (statement != null) {
                    statement.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
            try {
                if (statement != null) {
                    conn.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    
        public static void release(ResultSet rs, Statement statement, Connection conn) {
            try {
                if (rs != null) {
                    rs.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
            try {
                if (statement != null) {
                    statement.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
            try {
                if (statement != null) {
                    conn.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    
        /**
         * 1. 获取连接的方法
         * 通过读取配置文件从数据库服务器获取一个连接。
         *
         * @return
         */
        public static Connection getConnection() throws Exception {
            // 1. 准备连接数据库的4个字符串。
            // 1.1 创建Properties对象
            Properties properties = new Properties();
            // 1.2 获取jdbc.properties对应的输入流
            InputStream in = JDBCTools.class.getClassLoader().getResourceAsStream("jdbc.properties");
            // 1.3 加载1.2对应的输入流
            properties.load(in);
            // 1.4 具体决定user，password等4个字符串。
            String user = properties.getProperty("user");
            String password = properties.getProperty("password");
            String jdbcUrl = properties.getProperty("jdbcUrl");
            String driver = properties.getProperty("driver");
            // 2. 加载数据库驱动程序
            Class.forName(driver);
            // 3. 通过DriverManager的getConnection()方法获取数据库连接。
            return DriverManager.getConnection(jdbcUrl, user, password);
        }
    
    }
    ```

  - 修改后的insert/update/delete封装

    ```java
    public void update(String sql) {
        Connection conn = null;
        Statement statement = null;
    
        try {
            conn = getConnection2();
            statement = conn.createStatement();
            statement.executeUpdate(sql);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            JDBCTools.release(statement, conn);
        }
    }
    ```

## 4. 通过ResultSet执行查询操作

```java
/**
 * ResultSet：结果集。封装了使用JDBC进行查询的结果。
 * 1. 调用Statement对象的executeQuery(sql)方法
 * 2. ResultSet返回的实际上就是一张数据表。有一个指针指向数据表的第一行的前面。
 * 可以调用next()方法检测下一行是否有效。若有效，该方法返回true，且指针下移。
 * 相当于Iterator对象的hasNext()和next()方法的结合体
 * 3. 当指针对应到一行时，可以通过嗲用getXXX(index)或getXXX(columnName)获取
 * 每一列的值。如：getInt(1)，getString("name")
 * 4. 关闭ResultSet
 */
public void testResultSet(){
    // 获取各项记录，并打印
    Connection conn = null;
    Statement statement = null;
    ResultSet rs = null;
    try {
        // 1. 获取Connection
        conn = JDBCTools.getConnection();
        // 2. 获取Statement
        statement = conn.createStatement();
        // 3. 准备SQL
        String sql = "select id, username, pwd, regTime, lastLoginTime from t_user";
        // 4. 执行查询，得到ResultSet
        rs = statement.executeQuery(sql);
        // 5. 处理ResultSet
        while(rs.next()){
            int id = rs.getInt(1);
            String username = rs.getString(2);
            String pwd = rs.getString(3);
            Date regTime = rs.getDate(4);
            Timestamp lastLoginTime = rs.getTimestamp(5);
            System.out.println(id + "-->" + username + "-->" + pwd + "-->" + regTime + "-->" + lastLoginTime);
        }
        // 6. 关闭数据库资源
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        JDBCTools.release(rs, statement, conn);
    }
}
```

- 以面向对象的思想编写JDBC程序
  - 将数据表中的属性封装为一个类，增删改变为从类到数据库，查变为从数据库到类。

## 5. PreparedStatement

- 是Statement的子接口，可以传入带占位符的sql语句，并且提供了补充占位符变量的方法。

- 使用Statement需要进行拼写SQL语句，很辛苦，很容易出错。

- 引号的问题处理很复杂，不利于维护。

- 可以有效的禁止sql注入。(通过用户输入非法的sql命令)

- 代码的可读性和可维护性，最大可能的提高性能（批量插入）

- 代码测试

  ```java
  public void testPreparedStatement() {
      Connection connection = null;
      PreparedStatement ps = null;
  
      try {
          connection = JDBCTools.getConnection();
          String sql = "insert into t_user (id, username, pwd, regTime, lastLoginTime) values(?,?,?,?,?)";
          ps = connection.prepareStatement(sql);
          ps.setInt(1, 2);
          ps.setString(2, "狗贼");
          ps.setString(3, "123456");
          ps.setDate(4, new Date(System.currentTimeMillis()));
          ps.setTimestamp(5, new Timestamp(System.currentTimeMillis()));
          ps.executeUpdate();
      } catch (Exception e) {
          e.printStackTrace();
      } finally {
          JDBCTools.release(ps, connection);
      }
  }
  ```


## 6. 利用反射及JDBC元数据编写通用的查询

1. 先利用SQL进行查询，得到结果集
2. 利用反射创建实体类的对象：创建Student对象
3. 获取结果集的列的别名：idCard、studentName
4. 再获取结果集的每一列的值，结合3得到一个Map键值对。键：列的别名；值：列的值。
5. 再利用反射为2对应的属性赋值，属性即为Map的键，值即为Map的值。

- ResultSetMetaData

  - 是什么：是描述ResultSet的元数据对象。即从中可以获取到结果集中有多少列，列名是什么...
  - 如何用：
    - 得到ResultSetMetaData对象：调用ResultSet的getMetaData()方法
    - 常用好用的方法：
      - int getColumnCount()：SQL语句中包含了哪些列
      - String getColumnLabel(int column)：获取指定的列的别名，从1开始。

- ResultSetMetaData测试

  ```java
  public void testResultSetMetaData() {
      Connection conn = null;
      PreparedStatement ps = null;
      ResultSet rs = null;
      try {
          String sql = "select id, username, pwd, regTime, lastLoginTime from t_user where id = ?";
          conn = JDBCTools.getConnection();
          ps = conn.prepareStatement(sql);
          ps.setInt(1, 1);
          rs = ps.executeQuery();
  
          // 1. 得到ResultSetMetaData对象
          ResultSetMetaData rsmd = rs.getMetaData();
          // 2. 打印每一列的列名
          for (int i = 0; i < rsmd.getColumnCount(); i++) {
              String columnLabel = rsmd.getColumnLabel(i + 1);
              System.out.println(columnLabel);
          }
  
      } catch (Exception e) {
          e.printStackTrace();
      } finally {
          JDBCTools.release(rs, ps, conn);
      }
  }
  ```

- 取出列的别名和值

  ```java
  public void testResultSetMetaData() {
      Connection conn = null;
      PreparedStatement ps = null;
      ResultSet rs = null;
      try {
          String sql = "select id, username, pwd, regTime, lastLoginTime from t_user where id = ?";
          conn = JDBCTools.getConnection();
          ps = conn.prepareStatement(sql);
          ps.setInt(1, 1);
          rs = ps.executeQuery();
          Map<String, Object> values = new HashMap<>();
  
          // 1. 得到ResultSetMetaData对象
          ResultSetMetaData rsmd = rs.getMetaData();
  
          while(rs.next()){
              // 2. 打印每一列的列名
              for (int i = 0; i < rsmd.getColumnCount(); i++) {
                  String columnLabel = rsmd.getColumnLabel(i + 1);
                  Object columnValue = rs.getObject(columnLabel);
                  values.put(columnLabel, columnValue);
              }
          }
          System.out.println(values);
          Class clazz = User.class;
          Object object = clazz.newInstance();
          for (Map.Entry<String, Object> entry: values.entrySet()){
              String fieldName = entry.getKey();
              Object fieldValue = entry.getValue();
              System.out.println(fieldName + ": " + fieldValue);
          }
  
      } catch (Exception e) {
          e.printStackTrace();
      } finally {
          JDBCTools.release(rs, ps, conn);
      }
  }
  ```

- 通用的查询方法代码

  ```java
  public <T> T get(Class<T> clazz, String sql, Object... args) {
      T entity = null;
  
      Connection conn = null;
      PreparedStatement ps = null;
      ResultSet rs = null;
      try {
          conn = JDBCTools.getConnection();
          ps = conn.prepareStatement(sql);
          for (int i = 0; i < args.length; i++) {
              ps.setObject(i + 1, args[i]);
          }
          rs = ps.executeQuery();
          Map<String, Object> values = new HashMap<>();
          ResultSetMetaData rsmd = rs.getMetaData();
  
          if (rs.next()) {
              // 利用反射创建对象
              entity = clazz.newInstance();
              // 通过解析sql语句来判断到底选择了哪些列，以及需要为entity对象的哪些属性赋值
              for (int i = 0; i < rsmd.getColumnCount(); i++) {
                  String columnLabel = rsmd.getColumnLabel(i + 1);
                  Object columnValue = rs.getObject(columnLabel);
                  values.put(columnLabel, columnValue);
              }
          }
          for (Map.Entry<String, Object> entry : values.entrySet()) {
              String fieldName = entry.getKey();
              Object fieldValue = entry.getValue();
              System.out.println(fieldName + ": " + fieldValue);
          }
  
          // 这里要加入ReflectionUtils方法，将map的内容写入entity中，并返回entity
  
          // 6. 关闭数据库资源
      } catch (Exception e) {
          e.printStackTrace();
      } finally {
          JDBCTools.release(rs, ps, conn);
      }
      return entity;
  }
  ```

## 7. DAO设计模式

- Data Access Object，数据访问对象

- what：访问数据信息的类。包含了对数据的CRUD（create、read、update、delete，增删改查）操作，而不包含任何业务相关的信息。

- why：实现功能的模块化。更有利于代码的维护和升级。DAO可以被子类集成或直接使用。

- how：使用JDBC编写DAO可能会包含的方法：

  - void update()

    ```java
    // insert, update, delete 操作都可以包含在其中
    void update(String sql, Object ... args)
    ```

  - 查询

    ```java
    // 查询一条记录，返回对应的对象
    <T> T get(Class<T> clazz, String sql, Object ... args)
    // 查询多条记录，返回对应的对象的集合
    <T> List<T> getForList(Class<T> clazz, String sql, Object ... args)
    // 返回某条记录的某一个字段的值或一个统计的值（一共有多少记录等。）
    <E> E getForValue(String sql, Object ... args)
    ```

- 代码实现

  - DAO

    ```java
    package com.litian.jdbc;
    
    import java.sql.Connection;
    import java.sql.PreparedStatement;
    import java.sql.ResultSet;
    import java.sql.ResultSetMetaData;
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: DAO.java
     * @time: 2020/3/26 18:37
     * @desc: |
     */
    
    public class DAO {
        // insert, update, delete 操作都可以包含在其中
        void update(String sql, Object... args) {
            Connection conn = null;
            PreparedStatement ps = null;
    
            try {
                conn = JDBCTools.getConnection();
                ps = conn.prepareStatement(sql);
    
                for (int i = 0; i < args.length; i++) {
                    ps.setObject(i + 1, args[i]);
                }
                ps.executeUpdate();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                JDBCTools.release(null, ps, conn);
            }
    
        }
    
        // 查询一条记录，返回对应的对象
        <T> T get(Class<T> clazz, String sql, Object... args) {
            T entity = null;
            Connection conn = null;
            PreparedStatement ps = null;
            ResultSet rs = null;
            try {
                // 1. 获取Connection
                conn = JDBCTools.getConnection();
                // 2. 获取PreparedStatement
                ps = conn.prepareStatement(sql);
                // 3. 填充占位符
                for (int i = 0; i < args.length; i++) {
                    ps.setObject(i + 1, args[i]);
                }
                // 4. 进行查询，得到ResultSet
                rs = ps.executeQuery();
                // 5. 若ResultSet中有记录，准备一个Map<String, Object>: 键：存放列的别名；值：存放列的值
                if (rs.next()) {
                    Map<String, Object> values = new HashMap<>();
                    // 6. 得到ResultSetMetaData对象
                    ResultSetMetaData rsmd = rs.getMetaData();
                    // 7. 处理ResultSet，把指针向下移动一个单位
                    // 8. 由ResultSetMetaData对象得到结果集中有多少列
                    int columnCount = rsmd.getColumnCount();
                    // 9. 由ResultSetMetaData得到每一列的别名，由ResultSet得到具体每一列的值
                    for (int i = 0; i < columnCount; i++) {
                        String columnLabel = rsmd.getColumnLabel(i + 1);
                        Object columnValue = rs.getObject(columnLabel);
    
                        // 10. 填充Map对象
                        values.put(columnLabel, columnValue);
                    }
                    // 11. 用反射创建Class对象的对象
                    entity = clazz.newInstance();
                    // 12. 遍历Map对象，用反射填充对象的属性值：属性名为Map中的Key，属性值为Map中的Value
                    for (Map.Entry<String, Object> entry : values.entrySet()) {
                        String propertyName = entry.getKey();
                        Object value = entry.getValue();
                        ReflectionUtils.setFieldValue(entity, propertyName, value);
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                JDBCTools.release(rs, ps, conn);
            }
            return entity;
        }
    
        // 查询多条记录，返回对应的对象的集合
        <T> List<T> getForList(Class<T> clazz, String sql, Object... args) {
            return null;
        }
    
        // 返回某条记录的某一个字段的值或一个统计的值（一共有多少记录等。）
        <E> E getForValue(String sql, Object... args) {
            return null;
        }
    }
    ```

  - DAO测试

    ```java
    package com.litian.jdbc;
    
    import java.sql.Date;
    import java.sql.Timestamp;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: DAOTest.java
     * @time: 2020/3/26 18:59
     * @desc: |
     */
    
    public class DAOTest {
        public static void main(String[] args) {
            DAO dao = new DAO();
            // 测试update
            // String sql = "insert into t_user(id, username, pwd, regTime, lastLoginTime) values(?,?,?,?,?)";
            // dao.update(sql, 4, "李英俊", "123456", new Date(System.currentTimeMillis()), new Timestamp(System.currentTimeMillis()));
    
            // 测试get
            String sql = "select id, username, pwd, regTime, lastLoginTime from t_user where id=?";
            User u = dao.get(User.class, sql, 4);
            System.out.println(u);
        }
    }
    ```

  - 这里在网上找了一份ReflectionUtils

    ```java
    package com.litian.jdbc;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ReflectionUtils.java
     * @time: 2020/3/26 18:57
     * @desc: |JDBC 查询得到属性字段 反射机制返回到 JavaBean中相同类属性名的对象中
     */
    
    import java.lang.reflect.*;
    
    
    public class ReflectionUtils {
    
        /**
         * 使 filed 变为可访问
         *
         * @param field
         */
        public static void makeAccessible(Field field) {
            if (!Modifier.isPublic(field.getModifiers())) {
                field.setAccessible(true);
            }
        }
    
        /**
         * 直接设置对象的属性，忽略 private/protected 修饰符, 也不经过 setter
         *
         * @param object
         * @param fieldName 属性名称
         * @param value
         */
        public static void setFieldValue(Object object, String fieldName, Object value) {
    
            Field field = getDeclaredField(object, fieldName);
            if (field == null)
                throw new IllegalArgumentException("Could not find field [" + fieldName + "] on target [" + object + "]");
    
            // 让 private 元素变得可以访问,field.setAccessible();
            makeAccessible(field);
    
            try {
                field.set(object, value);
            } catch (IllegalArgumentException | IllegalAccessException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    
        /**
         * 循环向上转型, 获取对象的 DeclaredField
         *
         * @param object
         * @param filedName
         * @return
         */
        public static Field getDeclaredField(Object object, String filedName) {
            // 一步步的循环得到 获取声明对象的祖宗类
            for (Class<?> superClass = object.getClass(); superClass != Object.class; superClass = superClass.getSuperclass()) {
                try {
                    return superClass.getDeclaredField(filedName);
                } catch (NoSuchFieldException | SecurityException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            return null;
        }
    
        /**
         * 直接读取对象的属性值, 忽略 private/protected 修饰符, 也不经过 getter
         *
         * @param object
         * @param fieldName
         * @return
         */
        public static Object getFieldValue(Object object, String fieldName) {
            Field field = getDeclaredField(object, fieldName);
    
            if (field == null)
                throw new IllegalArgumentException("Could not find field [" + fieldName + "] on target [" + object + "]");
    
            makeAccessible(field);
            Object result = null;
    
            try {
                result = field.get(object);
            } catch (IllegalArgumentException | IllegalAccessException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            return result;
        }
    
        /**
         * 循环向上转型, 获取对象的 DeclaredMethod
         *
         * @param object
         * @param methodName
         * @param parameterTypes: 指定特定成员方法有重载可能性，必须指定特定的类型变量
         * @return
         */
        public static Method getDeclaredMethod(Object object, String methodName, Class<?>[] parameterTypes) {
            for (Class<?> superClass = object.getClass(); superClass != Object.class; superClass = superClass.getSuperclass()) {
                try {
                    //superClass.getMethod(methodName, parameterTypes);
                    return superClass.getDeclaredMethod(methodName, parameterTypes);
                } catch (NoSuchMethodException e) {
                    //Method 不在当前类定义, 继续向上转型
                }
                //..
            }
    
            return null;
        }
    
        /**
         * 直接调用对象方法, 而忽略修饰符(private, protected)
         *
         * @param object
         * @param methodName
         * @param parameterTypes
         * @param parameters
         * @return
         * @throws InvocationTargetException
         * @throws IllegalArgumentException
         */
        public static Object invokeMethod(Object object, String methodName, Class<?>[] parameterTypes,
                                          Object[] parameters) throws InvocationTargetException {
            Method method = getDeclaredMethod(object, methodName, parameterTypes);
    
            if (method == null)
                throw new IllegalArgumentException("Could not find method [" + methodName + "] on target [" + object + "]");
            method.setAccessible(true);
    
            // 使用 method.invoke()方法进行运行
            try {
                method.invoke(object, parameters);
            } catch (IllegalAccessException | IllegalArgumentException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            return method;
        }
    
        /**
         * 通过反射, 获得定义 Class 时声明的父类的泛型参数的类型
         * 如: public EmployeeDao extends BaseDao<Employee, String>
         *
         * @param clazz
         * @param index
         * @return
         */
        public static Class getSuperClassGenricType(Class clazz, int index) {
            Type genType = clazz.getGenericSuperclass();
    
            // 判定s是否是ParameterType相对应的
            if (!(genType instanceof ParameterizedType))
                return Object.class;
    
            // 强制转换 获取超类泛型参数实际类型，返回genType 是类的接口，基本类型或者void
            Type[] params = ((ParameterizedType) genType).getActualTypeArguments();
    
            if (index >= params.length || index < 0)
                return Object.class;
    
            if (!(params[index] instanceof Class))
                return Object.class;
            return (Class) params[index];
        }
    }
    ```

- JAVA类属性

  - 在JAVAEE中，JAVA类的属性通过getter，setter来定义：get（set）方法：去除get（或set）后，首字母小写即为该类的属性。
  
  - 而之前的属性，即成员变量称之为字段。
  
  - 操作java类的属性有一个工具包：beanutils（需要结合logging来用）
  
    - BeanUtils.setProperty()
    - BeanUtils.getProperty()
  
  - 一般情况下，字段名和属性名都一致
  
  - 通过该工具包可以将之前的ReflectionUtil替换为：`BeanUtils.setProperty(entity, propertyName, value);`
  
  - BeanUtils测试代码
  
    ```java
    package com.litian.jdbc;
    
    import org.apache.commons.beanutils.BeanUtils;
    
    import java.lang.reflect.InvocationTargetException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: BeanUtilsTest.java
     * @time: 2020/3/27 15:37
     * @desc: |测试工具包beanutils
     */
    
    public class BeanUtilsTest {
        public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
            // 测试赋值操作
            Object obj = new User();
            System.out.println(obj);
    
            BeanUtils.setProperty(obj, "username", "二哈");
            System.out.println(obj);
    
            // 测试获取操作
            Object val = BeanUtils.getProperty(obj, "username");
            System.out.println(val);
    
        }
    }
    ```
  
- DAO的补充和重构

  - DAO重构后的代码

    ```java
    package com.litian.jdbc;
    
    import org.apache.commons.beanutils.BeanUtils;
    
    import java.sql.*;
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: DAO.java
     * @time: 2020/3/26 18:37
     * @desc: |
     */
    
    public class DAO {
        // insert, update, delete 操作都可以包含在其中
        void update(String sql, Object... args) {
            Connection conn = null;
            PreparedStatement ps = null;
    
            try {
                conn = JDBCTools.getConnection();
                ps = conn.prepareStatement(sql);
    
                for (int i = 0; i < args.length; i++) {
                    ps.setObject(i + 1, args[i]);
                }
                ps.executeUpdate();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                JDBCTools.release(null, ps, conn);
            }
    
        }
    
        // 查询一条记录，返回对应的对象
        <T> T get(Class<T> clazz, String sql, Object... args) {
            List<T> result = getForList(clazz, sql, args);
            if (result.size() > 0) {
                return result.get(0);
            }
            return null;
    
            /* 根据下面的方法进行了改写
            T entity = null;
            Connection conn = null;
            PreparedStatement ps = null;
            ResultSet rs = null;
            try {
                // 1. 获取Connection
                conn = JDBCTools.getConnection();
                // 2. 获取PreparedStatement
                ps = conn.prepareStatement(sql);
                // 3. 填充占位符
                for (int i = 0; i < args.length; i++) {
                    ps.setObject(i + 1, args[i]);
                }
                // 4. 进行查询，得到ResultSet
                rs = ps.executeQuery();
    
                // 5. 若ResultSet中有记录，准备一个Map<String, Object>: 键：存放列的别名；值：存放列的值
                if (rs.next()) {
                    Map<String, Object> values = new HashMap<>();
                    // 6. 得到ResultSetMetaData对象
                    ResultSetMetaData rsmd = rs.getMetaData();
                    // 7. 处理ResultSet，把指针向下移动一个单位
                    // 8. 由ResultSetMetaData对象得到结果集中有多少列
                    int columnCount = rsmd.getColumnCount();
                    // 9. 由ResultSetMetaData得到每一列的别名，由ResultSet得到具体每一列的值
                    for (int i = 0; i < columnCount; i++) {
                        String columnLabel = rsmd.getColumnLabel(i + 1);
                        Object columnValue = rs.getObject(columnLabel);
    
                        // 10. 填充Map对象
                        values.put(columnLabel, columnValue);
                    }
                    // 11. 用反射创建Class对象的对象
                    entity = clazz.newInstance();
                    // 12. 遍历Map对象，用反射填充对象的属性值：属性名为Map中的Key，属性值为Map中的Value
                    for (Map.Entry<String, Object> entry : values.entrySet()) {
                        String propertyName = entry.getKey();
                        Object value = entry.getValue();
                        BeanUtils.setProperty(entity, propertyName, value);
                    }
                }
    
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                JDBCTools.release(rs, ps, conn);
            }
            return entity;
    
             */
        }
    
        // 查询多条记录，返回对应的对象的集合
        <T> List<T> getForList(Class<T> clazz, String sql, Object... args) {
            List<T> list = new ArrayList<>();
    
            Connection conn = null;
            PreparedStatement ps = null;
            ResultSet rs = null;
    
            try {
                // 1. 得到结果集
                conn = JDBCTools.getConnection();
                ps = conn.prepareStatement(sql);
                for (int i = 0; i < args.length; i++) {
                    ps.setObject(i + 1, args[i]);
                }
                rs = ps.executeQuery();
    
                // 2. 处理结果集，得到一个Map对应的List，其中一个Map对象就是一条记录，Map的Key为rs中列的别名，Value为列的值
                List<Map<String, Object>> values = handleResultSetToMapList(rs);
                // 3. 把Map的List转为clazz对应的List，其中Map的key即clazz对应的对象的propertyName，value即为clazz对应对象的propertyValue
                list = transferMapListToBeanList(clazz, values);
    
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                JDBCTools.release(rs, ps, conn);
            }
            return list;
        }
    
        public <T> List<T> transferMapListToBeanList(Class<T> clazz, List<Map<String, Object>> values) throws Exception {
            // 12. 判断List是否为空集合，若不为空，则遍历List，得到一个个Map对象，再把一个Map对象转为一个Class参数对应的Object对象。
            List<T> result = new ArrayList<T>();
            T bean = null;
            if (values.size() > 0) {
                for (Map<String, Object> m : values) {
                    bean = clazz.newInstance();
                    for (Map.Entry<String, Object> entry : m.entrySet()) {
                        String propertyName = entry.getKey();
                        Object value = entry.getValue();
    
                        BeanUtils.setProperty(bean, propertyName, value);
                    }
                    result.add(bean);
                }
            }
            return result;
        }
    
        /**
         * 处理结果集，得到Map的一个List，其中一个Map对象对应一条记录
         *
         * @param rs
         * @return
         * @throws SQLException
         */
        private List<Map<String, Object>> handleResultSetToMapList(ResultSet rs) throws SQLException {
            // 5. 若ResultSet中有记录，准备一个List<Map<String, Object>>
            // 键：存放列的别名；值：存放列的值，其中一个Map对象对应着一条记录
            List<Map<String, Object>> values = new ArrayList<>();
            List<String> columnLabels = getColumnLabels(rs);
            // 7. 处理ResultSet，使用while循环
            Map<String, Object> maps = null;
            while (rs.next()) {
                maps = new HashMap<>();
                for (String columnLabel : columnLabels) {
                    Object value = rs.getObject(columnLabel);
    
                    maps.put(columnLabel, value);
                }
                // 11. 把一条记录的填充好的Map对象放入5准备的List中
                values.add(maps);
            }
            return values;
        }
    
        /**
         * 获取结果集ColumnLabel对应的结果集
         */
        private List<String> getColumnLabels(ResultSet rs) throws SQLException {
            List<String> labels = new ArrayList<>();
            ResultSetMetaData rsmd = rs.getMetaData();
            for (int i = 0; i < rsmd.getColumnCount(); i++) {
                String columnLabel = rsmd.getColumnLabel(i + 1);
                labels.add(columnLabel);
            }
            return labels;
        }
    
        // 返回某条记录的某一个字段的值或一个统计的值（一共有多少记录等。）
        <E> E getForValue(String sql, Object... args) {
            Connection conn = null;
            PreparedStatement ps = null;
            ResultSet rs = null;
    
            try {
                // 1. 得到结果集
                conn = JDBCTools.getConnection();
                ps = conn.prepareStatement(sql);
                for (int i = 0; i < args.length; i++) {
                    ps.setObject(i + 1, args[i]);
                }
                rs = ps.executeQuery();
    
                // 2. 取得结果
                if (rs.next()){
                    return (E) rs.getObject(1);
                }
    
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                JDBCTools.release(rs, ps, conn);
            }
            return null;
        }
    }
    ```

  - 测试

    ```java
    package com.litian.jdbc;
    
    import java.sql.Date;
    import java.sql.Timestamp;
    import java.util.List;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: DAOTest.java
     * @time: 2020/3/26 18:59
     * @desc: |
     */
    
    public class DAOTest {
        public static void main(String[] args) {
            DAO dao = new DAO();
            // 测试update
            // String sql = "insert into t_user(id, username, pwd, regTime, lastLoginTime) values(?,?,?,?,?)";
            // dao.update(sql, 4, "李英俊", "123456", new Date(System.currentTimeMillis()), new Timestamp(System.currentTimeMillis()));
    
            // 测试get
            // String sql = "select id, username, pwd, regTime, lastLoginTime from t_user where id=?";
            // User u = dao.get(User.class, sql, 4);
            // System.out.println(u);
    
            // 测试getForList
            // String sql2 = "select id, username, pwd, regTime, lastLoginTime from t_user where id<?";
            // List<User> us = dao.getForList(User.class, sql2, 10);
            // System.out.println(us);
    
            // 测试getForValue
            String sql3 = "select username from t_user where id = ?";
            String cc = dao.getForValue(sql3, 1);
            System.out.println(cc);
        }
    }
    ```

## 8. JDBC的元数据

- 可以从Connection对象中获得**有关数据库管理系统的各种信息**

- 获取这些信息的方法都是在DatabaseMetaData类中。

- DatabaseMetaData：描述数据库的元数据对象

- ResultSetMetaData：描述结果集的元数据对象

  ```java
  package com.litian.jdbc;
  
  import java.sql.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: MetaDataTest.java
   * @time: 2020/3/29 15:12
   * @desc: |
   */
  
  public class MetaDataTest {
  
      public static void main(String[] args){
          testDatabaseMetaData();
          testResultSetMetaData();
      }
  
      /**
       * ResultSetMetaData：描述结果集的元数据对象
       * 可以得到结果集中的基本信息：结果集中有哪些列，列名、列的别名等。
       * 结合反射可以写出通用的查询方法
       */
      public static void testResultSetMetaData(){
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
  
          try {
              conn = JDBCTools.getConnection();
              String sql = "select id, username 姓名, pwd from t_user";
              ps = conn.prepareStatement(sql);
              rs = ps.executeQuery();
  
              // 1. 得到ResultSetMetaData对象
              ResultSetMetaData rsmd = rs.getMetaData();
  
              // 2. 得到列的个数
              int columnCount = rsmd.getColumnCount();
              System.out.println(columnCount);
  
              for (int i = 0; i < columnCount; i++) {
                  // 3. 得到列名
                  String columnName = rsmd.getColumnName(i + 1);
                  // 4. 得到列的别名
                  String columnLabel = rsmd.getColumnLabel(i + 1);
                  System.out.println(columnName + "-->" + columnLabel);
              }
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
              JDBCTools.release(rs, ps, conn);
          }
      }
  
      /**
       * DatabaseMetaData是描述数据库的元数据对象
       * 可以由Connection得到
       */
      public static void testDatabaseMetaData(){
          Connection conn = null;
          ResultSet rs = null;
  
          try {
              conn = JDBCTools.getConnection();
              DatabaseMetaData data = conn.getMetaData();
  
              // 可以得到数据库本身的一些基本信息
              // 1. 得到数据库的版本号
              int version = data.getDatabaseMajorVersion();
              System.out.println(version);
  
              // 2. 得到连接数据库的用户名
              String user = data.getUserName();
              System.out.println(user);
  
              // 3. 得到MySQL中有哪些数据库
              rs = data.getCatalogs();
              while (rs.next()) {
                  System.out.println(rs.getString(1));
              }
  
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
              JDBCTools.release(rs, null, conn);
          }
      }
  }
  ```

## 9. JDBC获取插入记录的主键值

- 取得数据库自动生成的主键值

  ```java
  package com.litian.jdbc;
  
  import javax.swing.plaf.nimbus.State;
  import java.sql.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: JDBCTest3.java
   * @time: 2020/3/29 15:27
   * @desc: |取得数据库自动生成的主键值
   */
  
  public class JDBCTest3 {
      public static void main(String[] args){
          Connection conn = null;
          PreparedStatement ps = null;
  
          try {
              conn = JDBCTools.getConnection();
              String sql = "insert into t_user(username, pwd) values(?,?)";
              // ps = conn.prepareStatement(sql);
  
              // 使用重载的ps方法来生成ps对象
              ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
              ps.setString(1, "pika");
              ps.setString(2, "123456");
              ps.executeUpdate();
  
              // 通过getGeneratedKeys方法获取包含了新生成的主键的ResultSet对象
              // 在ResultSet中只有一列GENERATED_KEYS，用于存放新生成的主键值
              ResultSet rs = ps.getGeneratedKeys();
              if(rs.next()){
                  System.out.println(rs.getInt(1));
              }
  
              ResultSetMetaData rsmd = rs.getMetaData();
              for (int i = 0; i < rsmd.getColumnCount(); i++) {
                  System.out.println(rsmd.getColumnName(i + 1));
              }
  
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
              JDBCTools.release(null, ps, conn);
          }
      }
  }
  ```

## 10. 处理Blob

- LOB，即Large Objects（大对象），是用来存储大量的二进制和文本数据的一种数据类型

- LOB分为两种内省：内部LOB和外部LOB

  - 内部LOB将数据以字节流的形式存储在数据库的内部。因而内部LOB的许多操作都可以参与事务，也可以像处理普通数据一样对其进行备份和恢复操作。
  - Oracle支持三种类型的内部LOB：
    - BLOB：二进制数据
    - CLOB：单字节字符数据
    - NCLOB：多字节字符数据
  - CLOB和NCLOB类型适用于存储超长的文本数据，BLOB字段适用于存储大量的二进制数据，如图像、视频、音频、文件等。

- MySQL四种BLOB类型（除了在存储的最大信息量上不同之外，他们是等同的）

  - TinyBlob：最大255字节
  - Blob：最大65K
  - MediumBlob：最大16M
  - LongBlob：最大4G

- 如果存储的文件过大，数据库的性能会下降。

- 插入Blob数据

  ```java
  package com.litian.jdbc;
  
  import java.io.FileInputStream;
  import java.io.InputStream;
  import java.sql.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: InsertBlob.java
   * @time: 2020/3/31 14:40
   * @desc: |插入Blob类型的数据必须使用PreparedStatement，因为BLOB类型的数据是无法使用字符串拼写的
   *          调用setBlob方法插入BLOB
   */
  
  public class InsertBlob {
      public static void main(String[] args){
          Connection conn = null;
          PreparedStatement ps = null;
  
          try {
              conn = JDBCTools.getConnection();
              String sql = "insert into t_user(username, pwd, pic) values(?,?,?)";
              ps = conn.prepareStatement(sql);
              ps.setString(1, "picture");
              ps.setString(2, "123456");
              InputStream is = new FileInputStream("C:\\Users\\Administrator\\Desktop\\参考投稿进程.jpg");
              ps.setBlob(3, is);
  
              ps.executeUpdate();
  
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
              JDBCTools.release(null, ps, conn);
          }
      }
  }
  ```

- 读取Blob数据

  ```java
  package com.litian.jdbc;
  
  import java.io.FileOutputStream;
  import java.io.InputStream;
  import java.io.OutputStream;
  import java.sql.Blob;
  import java.sql.Connection;
  import java.sql.PreparedStatement;
  import java.sql.ResultSet;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: ReadBlob.java
   * @time: 2020/3/31 14:47
   * @desc: |读取Blob数据
   *      1. 使用getBlob方法读取到Blob对象
   *      2. 调用Blob的getBinaryStream()方法得到输入流。再使用IO操作即可。
   */
  
  public class ReadBlob {
      public static void main(String[] args) {
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
  
          try {
              conn = JDBCTools.getConnection();
              String sql = "select id, username 姓名, pwd, pic from t_user where id=21028";
              ps = conn.prepareStatement(sql);
              rs = ps.executeQuery();
  
              if (rs.next()) {
                  int id = rs.getInt(1);
                  String name = rs.getString(2);
                  String pwd = rs.getString(3);
                  System.out.println(id + "->" + name + "->" + pwd);
                  Blob pic = rs.getBlob(4);
                  InputStream in = pic.getBinaryStream();
                  OutputStream out = new FileOutputStream("info.jpg");
                  byte[] buffer = new byte[1024];
                  int len = 0;
                  while((len=in.read(buffer)) != -1){
                      out.write(buffer, 0, len);
                  }
                  out.close();
                  in.close();
              }
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
              JDBCTools.release(rs, ps, conn);
          }
      }
  }
  ```

## 11. 处理事务

- 所谓事务是指：**一组逻辑操作单元，使数据从一种状态变换到另一种状态**。

- 事务的ACID属性

  - **原子性，Atomicity**：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
  - **一致性，Consistency**：事务必须使数据库从一个一致性状态变换到另一个一致性状态。
  - **隔离性，Isolation**：一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
  - **持久性，Durability**：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。

- 为了让多个SQL语句作为一个事务执行：

  - 调用Connection对象的setAutoCommit(false);以取消自动提交事务
  - 在所有SQL语句都执行后，调用commit();方法提交事务
  - 在出现异常时，调用rollback()方法回滚事务
  - 若此时Connection没有被关闭，则需要恢复其自动提交状态

- 关于事务：

  - 如果多个操作，每个操作使用的是自己的单独的连接，则无法保证事务。
  - 具体步骤：
    - 事务操作开始前，开始事务：取消Connection默认的提交行为；
    - 如果事务的操作都成功，则提交事务；
    - 回滚事务：若出现异常，则在catch块中回滚事务。

- 代码：

  - 新增DAO一个方法，这个方法把Connection提出来作为传参

    ```java
        // 外部来处理Connection
        void update(Connection conn, String sql, Object... args) {
            PreparedStatement ps = null;
    
            try {
                ps = conn.prepareStatement(sql);
    
                for (int i = 0; i < args.length; i++) {
                    ps.setObject(i + 1, args[i]);
                }
                ps.executeUpdate();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                JDBCTools.release(null, ps, null);
            }
        }
    ```

  - 测试事务

    ```java
    package com.litian.jdbc;
    
    import java.sql.Connection;
    import java.sql.SQLException;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: TransactionTest.java
     * @time: 2020/4/1 14:06
     * @desc: |
     */
    
    public class TransactionTest {
        public static void main(String[] args) {
            DAO dao = new DAO();
    
            Connection conn = null;
    
            try {
                conn = JDBCTools.getConnection();
    
                // 开始事务：取消默认提交
                conn.setAutoCommit(false);
                String sql = "update t_user2 set money = money - 500 where id = 21023";
                dao.update(conn, sql);
    
                // 插入错误
                int i = 10 / 0;
                System.out.println(i);
    
                sql = "update t_user2 set money = money + 500 where id = 21024";
                dao.update(conn, sql);
    
                // 提交事务
                conn.commit();
            } catch (Exception e) {
                e.printStackTrace();
    
                try {
                    conn.rollback();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            } finally {
                JDBCTools.release(null, null, conn);
            }
        }
    }
    ```

## 12. 事务的隔离级别

- 脏读：读取了更新还未提交的数据，但进行了回滚，所以读取的内容是临时的且无效的。
- 不可重复读：某个事务多次读取一个字段，值却不同，这是因为中间别的事务更新的该字段。
- 幻读：某个事务从一个表中读取了信息，然后另一个事务更新了该表，使得之前事务再读的时候，表的行数改变了。
- 数据库提供了4种事务隔离级别：
  - READ UNCOMMITED：读未提交数据，3种问题都会出现
  - READ COMMITED：读已提交数据，避免脏读
  - REPEATABLE READ：可重复度，避免脏读和不可重复读
  - SERIALIZABLE：串行化，避免3种问题
- Oracle支持2种事务隔离级别：READ COMMITED（默认）和SERIALIZABLE
- Mysql支持4种事务隔离级别：默认REPEATABLE READ
- 在JDBC程序中可以通过Connection的setTransactionIsolation来设置事务的隔离级别

------

我的CSDN：https://blog.csdn.net/qq_21579045

我的博客园：https://www.cnblogs.com/lyjun/

我的Github：https://github.com/TinyHandsome

纸上得来终觉浅，绝知此事要躬行~

欢迎大家过来OB~

by 李英俊小朋友
### 2. 工厂模式（3种）

- 实现了创建者和调用者的分离
- 详细分类：
  - **简单工厂模式**：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）
  - **简单方法模式**：用来生产同一等级结构中的固定产品。（支持增加任意产品）
  - **抽象工厂模式**：用来生产不同产品族的全部产品。（对于增加的新产品，无能为力，支持增加产品族）
- 面向对象设计基本原则：
  - OCP（开闭原则，Open-Closed Principle）：一个软件的实体应当对扩展开放，对修改关闭
  - DIP（依赖倒转原则，Dependence Inversion Principle）：要针对接口编程，不要针对实现编程
  - LoD（迪米特法则，Law of Demeter）：只与你直接的朋友通信，而避免和陌生人通信
- 核心本质：
  - 实例化对象，用工厂方法代替new操作
  - 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。

#### 2.1 简单工厂模式

- 要点：

  - 简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法，通过接受的参数的不同来返回不同的对象实例。
  - 对于增加新产品无能为力！不修改代码的话，是无法扩展的。

- 代码：

  - Car接口

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Car.java
     * @time: 2020/2/5 15:59
     * @desc:
     */
    
    public interface Car {
        void run();
    }
    ```

  - 奥迪车

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Audi.java
     * @time: 2020/2/5 16:00
     * @desc:
     */
    
    public class Audi implements Car {
        @Override
        public void run() {
            System.out.println("奥迪在跑！");
        }
    }
    ```

  - 比亚迪车

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Byd.java
     * @time: 2020/2/5 16:01
     * @desc:
     */
    
    public class Byd implements Car {
        @Override
        public void run() {
            System.out.println("比亚迪在跑！");
        }
    }
    ```

  - 测试在没有工厂模式的情况下

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client01.java
     * @time: 2020/2/5 16:02
     * @desc: 测试在没有工厂模式的情况下
     */
    
    public class Client01 { // 调用者
        public static void main(String[] args){
            Car c1 = new Audi();
            Car c2 = new Byd();
            c1.run();
            c2.run();
        }
    }
    ```

  - 简单工厂类1

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: CarFactory.java
     * @time: 2020/2/5 16:04
     * @desc:
     */
    
    public class CarFactory {
        public static Car createCar(String type){
            if("奥迪".equals(type)){
                return new Audi();
            }else if("比亚迪".equals(type)){
                return new Byd();
            }else{
                // 简单工厂还是有点小问题的，这里如果要加新的车辆的话，就需要改代码，违反了开闭原则OCP
                return null;
            }
        }
    }
    ```

  - 简单工厂2

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: CarFactory.java
     * @time: 2020/2/5 16:04
     * @desc: 简单工厂类2
     */
    
    public class CarFactory2 {
        public static Car createAudi() {
            return new Audi();
        }
    
        public static Car createByd() {
            return new Byd();
        }
    }
    ```

  - 测试在简单工厂模式的情况下

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client01.java
     * @time: 2020/2/5 16:02
     * @desc: 测试在简单工厂模式的情况下
     */
    
    public class Client02 { // 调用者
        public static void main(String[] args){
            Car c1 = CarFactory.createCar("奥迪");
            Car c2 = CarFactory.createCar("比亚迪");
            c1.run();
            c2.run();
        }
    }
    ```

- UML类图

  ![img](https://img-blog.csdnimg.cn/20200205162526807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

#### 2.2 工厂方法模式

- 为了避免简单工厂模式的缺点，不完全满足OCP。

- 工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。

- 代码：

  - 新增了车的工厂interface

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: CarFactory.java
     * @time: 2020/2/5 19:42
     * @desc:
     */
    
    public interface CarFactory {
        Car createCar();
    }
    ```

  - 实现了车工厂的audi工厂

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: AudiFactory.java
     * @time: 2020/2/5 19:42
     * @desc:
     */
    
    public class AudiFactory implements CarFactory {
        @Override
        public Car createCar() {
            return new Audi();
        }
    }
    ```

  - 实现了车工厂的byd工厂

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: BydFactory.java
     * @time: 2020/2/5 19:43
     * @desc:
     */
    
    public class BydFactory extends Byd implements CarFactory {
        @Override
        public Car createCar() {
            return new Byd();
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/5 19:44
     * @desc:
     */
    
    public class Client {
        public static void main(String[] args){
            Car c1 = new AudiFactory().createCar();
            Car c2 = new BydFactory().createCar();
            Car c3 = new BenzFactory().createCar();
    
            c1.run();
            c2.run();
            c3.run();
        }
    }
    ```

  - 如果需要新增车的类型的话，不需要修改原来的代码，只需要增加类就行，即满足了OCP

  - 新增benz类

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Benz.java
     * @time: 2020/2/5 19:45
     * @desc:
     */
    
    public class Benz extends BenzFactory implements Car {
        @Override
        public void run() {
            System.out.println("奔驰在跑！");
        }
    }
    ```

  - 新增benz工厂

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Benz.java
     * @time: 2020/2/5 19:45
     * @desc:
     */
    
    public class Benz extends BenzFactory implements Car {
        @Override
        public void run() {
            System.out.println("奔驰在跑！");
        }
    }
    ```

- 简单工厂模式和工厂方法模式PK：

  ![img](https://img-blog.csdnimg.cn/20200205201001445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 根据设计理论建议：工厂方法模式。但实际上，我们一般都用**简单工厂模式**。

#### 2.3 抽象工厂模式

- 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）

- 抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。

- 代码：

  - 发动机

    ```java
    package com.sxt.factory.abstractfactory;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Engine.java
     * @time: 2020/2/6 12:40
     * @desc:
     */
    
    public interface Engine {
        void run();
        void start();
    }
    
    class LuxuryEngine implements Engine{
    
        @Override
        public void run() {
            System.out.println("转得快！");
        }
    
        @Override
        public void start() {
            System.out.println("启动快！可以自动启停！");
        }
    }
    class LowerEngine implements Engine{
    
        @Override
        public void run() {
            System.out.println("转得慢！");
        }
    
        @Override
        public void start() {
            System.out.println("启动慢！可以自动启停！");
        }
    }
    ```

  - 座位

    ```java
    package com.sxt.factory.abstractfactory;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Seat.java
     * @time: 2020/2/6 12:42
     * @desc:
     */
    
    public interface Seat {
        void massage();
    }
    
    class LuxurySeat implements Seat{
    
        @Override
        public void massage() {
            System.out.println("可以按摩！");
        }
    }
    class LowerSeat implements Seat{
    
        @Override
        public void massage() {
            System.out.println("不可以按摩！");
        }
    }
    ```

  - 轮胎

    ```java
    package com.sxt.factory.abstractfactory;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Tyre.java
     * @time: 2020/2/6 12:43
     * @desc:
     */
    
    public interface Tyre {
        void revolve();
    }
    
    class LuxuryTyre implements Tyre{
    
        @Override
        public void revolve() {
            System.out.println("磨损慢！");
        }
    }
    class LowerTyre implements Tyre{
    
        @Override
        public void revolve() {
            System.out.println("磨损快！");
        }
    }
    
    ```

  - 车工厂

    ```java
    package com.sxt.factory.abstractfactory;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: CarFactory.java
     * @time: 2020/2/6 12:44
     * @desc:
     */
    
    public interface CarFactory {
        Engine createEngine();
        Seat createSeat();;
        Tyre createTyre();
    }
    ```

  - 高端车工厂

    ```java
    package com.sxt.factory.abstractfactory;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LuxuryCarFactory.java
     * @time: 2020/2/6 12:45
     * @desc:
     */
    
    public class LuxuryCarFactory implements CarFactory {
    
        @Override
        public Engine createEngine() {
            return new LuxuryEngine();
        }
    
        @Override
        public Seat createSeat() {
            return new LuxurySeat();
        }
    
        @Override
        public Tyre createTyre() {
            return new LuxuryTyre();
        }
    }
    ```

  - 低端车工厂

    ```java
    package com.sxt.factory.abstractfactory;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LowerCarFactory.java
     * @time: 2020/2/6 12:45
     * @desc:
     */
    
    public class LowerCarFactory implements CarFactory {
    
        @Override
        public Engine createEngine() {
            return new LowerEngine();
        }
    
        @Override
        public Seat createSeat() {
            return new LowerSeat();
        }
    
        @Override
        public Tyre createTyre() {
            return new LowerTyre();
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.factory.abstractfactory;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/6 12:47
     * @desc:
     */
    
    public class Client {
        public static void main(String[] args){
            CarFactory factory = new LuxuryCarFactory();
            Engine e = factory.createEngine();
            e.run();
            e.start();
        }
    }
    ```

- 工厂模式要点

  - 简单工厂模式（静态工厂模式）：虽然某种程度不符合实际原则，但实际使用最多
  - 工厂方法模式：不修改已有类的前提下，通过增加新的工厂实现扩展。
  - 抽象工厂模式：不可以增加产品，但可以增加产品族。

- 应用场景

  - JDK中Calendar的getInstance方法
  - JDBC中Connection对象的获取
  - Hibernate中SessionFactory创建Session
  - spring中IOC容器创建管理bean对象
  - XML解析时的DocumentBuilderFactory创建解析器对象
  - 反射中Class对象的newInstance

### 3. 建造者模式

- 场景：

  - 我们要建造一个复杂的产品。比如神舟飞船、Iphone。这个复杂的产品的创建，有这样的一个问题要处理：装配这些子组件是不是有个步骤问题？
  - 实际开发中，我们所需要的对象构建时，也非常复杂，有很多步骤需要处理时。

- 建造者模式的本质

  - 分离了对象子组件的单独构造（由Builder来负责）和装配（由Director负责）。从而可以构造出复杂的对象。这个模式适用于：**某个对象的构造过程复杂的情况下使用。**
  - 由于实现了构造和装配的解耦。不同的构造器，相同的装配，也可以做出不同的对象；相同的装备构造器，不同的装配顺序也可以做出不同的对象。也就是实现了构造算法、装配算法的解耦，实现了更好的复用。

- 代码：

  - 宇宙飞船

    ```java
    package com.sxt.builder;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: AirShip.java
     * @time: 2020/2/6 13:48
     * @desc: 宇宙飞船
     */
    
    public class AirShip {
        // 轨道舱
        private OrbitalModule orbitalModule;
        // 发动机
        private Engine engine;
        // 逃逸仓
        private EscapeTower escapeTower;
    
        public void launch(){
            System.out.println("发动机【" + engine.getName() + "】" + "轨道舱【" + orbitalModule.getName() + "】" + "逃离塔【" + escapeTower.getName() + "】" + "-->发射！");
        }
    
        public OrbitalModule getOrbitalModule() {
            return orbitalModule;
        }
    
        public void setOrbitalModule(OrbitalModule orbitalModule) {
            this.orbitalModule = orbitalModule;
        }
    
        public Engine getEngine() {
            return engine;
        }
    
        public void setEngine(Engine engine) {
            this.engine = engine;
        }
    
        public EscapeTower getEscapeTower() {
            return escapeTower;
        }
    
        public void setEscapeTower(EscapeTower escapeTower) {
            this.escapeTower = escapeTower;
        }
    }
    
    class OrbitalModule {
        private String name;
    
        public OrbitalModule(String name) {
            this.name = name;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    }
    
    class Engine {
        private String name;
    
        public Engine(String name) {
            this.name = name;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    }
    
    class EscapeTower{
        private String name;
    
        public EscapeTower(String name) {
            this.name = name;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    }
    ```

  - 构建者接口

    ```java
    package com.sxt.builder;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: AirShipBuilder.java
     * @time: 2020/2/6 13:53
     * @desc:
     */
    
    public interface AirShipBuilder {
        Engine buildEngine();
        OrbitalModule builderOrbitalModule();
        EscapeTower buildEscapeTower();
    }
    ```

  - 装配者接口

    ```java
    package com.sxt.builder;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: AirShipDirector.java
     * @time: 2020/2/6 13:54
     * @desc: 组装飞船对象
     */
    
    public interface AirShipDirector {
        // 组装飞船对象
        AirShip directAirShip();
    }
    ```

  - 构建者

    ```java
    package com.sxt.builder;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: MyAirShipBuilder.java
     * @time: 2020/2/6 13:55
     * @desc:
     */
    
    public class MyAirShipBuilder implements AirShipBuilder{
    
        @Override
        public Engine buildEngine() {
            System.out.println("构建发动机！");
            return new Engine("我的发动机");
        }
    
        @Override
        public OrbitalModule builderOrbitalModule() {
            System.out.println("构建轨道舱！");
            return new OrbitalModule("我的轨道舱");
        }
    
        @Override
        public EscapeTower buildEscapeTower() {
            System.out.println("构建逃逸塔！");
            return new EscapeTower("我的逃逸塔");
        }
    }
    ```

  - 装配者

    ```java
    package com.sxt.builder;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: MyAirShipDirector.java
     * @time: 2020/2/6 13:59
     * @desc:
     */
    
    public class MyAirShipDirector implements AirShipDirector{
    
        private AirShipBuilder builder;
    
        public MyAirShipDirector(AirShipBuilder builder) {
            this.builder = builder;
        }
    
        @Override
        public AirShip directAirShip() {
            // 从构建者获取组件
            Engine e = builder.buildEngine();
            OrbitalModule o = builder.builderOrbitalModule();
            EscapeTower es = builder.buildEscapeTower();
    
            // 进行组装
            AirShip ship = new AirShip();
            ship.setEngine(e);
            ship.setOrbitalModule(o);
            ship.setEscapeTower(es);
    
            return ship;
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.builder;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/6 14:02
     * @desc:
     */
    
    public class Client {
        public static void main(String[] args) {
            AirShipDirector director = new MyAirShipDirector(new MyAirShipBuilder());
    
            AirShip ship = director.directAirShip();
    
            ship.launch();
        }
    }
    ```

  - UML类图

    ![img](https://img-blog.csdnimg.cn/20200206141722278.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 开发中应用场景：

  - StringBuilder类的append方法
  - SQL中的PreparedStatement
  - JDOM中，DomBuilder、SAXBuilder

### 4. 原型模式

- 又叫克隆模式、拷贝模式，prototype
- 根据拷贝方式不同分为
- 场景：
  - 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
  - 就是java中的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点。
  - 优势有：效率高（直接克隆，避免了重新执行构造过程步骤）。
  - 克隆类似于new，但是不同于new。new创建新的对象属性采用的是默认值。克隆出的对象的属性值完全和原型对象相同。并且克隆出的新对象改变不会影响原型对象。然后，再修改克隆对象的值。
- 实现：
  - Cloneable接口和clone方法
  - Prototype模式中实现起来最困难的地方就是内存复制操作，所幸在java中提供了clone()方法替我们做了绝大部分事情。
- 注意用词：克隆和拷贝一回事。

#### 4.1 浅克隆

- 代码：

  - 羊

    ```java
    package com.sxt.prototype;
    
    import java.util.Date;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Sheep1.java
     * @time: 2020/2/6 15:53
     * @desc: 测试浅复制
     */
    
    public class Sheep1 implements Cloneable{
        private String sname;
        private Date birthday;
    
        public String getSname() {
            return sname;
        }
    
        public void setSname(String sname) {
            this.sname = sname;
        }
    
        public Date getBirthday() {
            return birthday;
        }
    
        public void setBirthday(Date birthday) {
            this.birthday = birthday;
        }
    
        public Sheep1(String sname, Date birthday) {
            this.sname = sname;
            this.birthday = birthday;
        }
    
        public Sheep1() {
        }
    
        @Override
        protected Object clone() throws CloneNotSupportedException {
            // 直接调用object对象的clone()方法
            Object obj = super.clone();
            return obj;
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.prototype;
    
    import java.util.Date;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client2.java
     * @time: 2020/2/6 15:57
     * @desc: 测试原型模式(浅复制)
     */
    
    public class Client1 {
        public static void main(String[] args) throws CloneNotSupportedException {
            Date d = new Date(3333333333L);
            Sheep1 s1 = new Sheep1("少理", d);
            System.out.println(s1);
            System.out.println(s1.getSname());
            System.out.println(s1.getBirthday());
    
            // 两个是不同的对象，但是值是一样的！
            Sheep1 s2 = (Sheep1) s1.clone();
    
            // 修改s1生日
            d.setTime(22222222222L);
            System.out.println("--------------------------");
            System.out.println(s1.getBirthday());
    
            System.out.println(s2);
            System.out.println(s2.getSname());
            System.out.println(s2.getBirthday());
    
            // 修改s2的值
            System.out.println("--------------------------");
            s2.setSname("多里");
            System.out.println(s2);
            System.out.println(s2.getSname());
            System.out.println(s2.getBirthday());
        }
    }
    ```

#### 4.2 深克隆

- 代码

  - 羊

    ```java
    package com.sxt.prototype;
    
    import java.util.Date;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Sheep2.java
     * @time: 2020/2/6 15:53
     * @desc: 测试深复制
     */
    
    public class Sheep2 implements Cloneable{
        private String sname;
        private Date birthday;
    
        public String getSname() {
            return sname;
        }
    
        public void setSname(String sname) {
            this.sname = sname;
        }
    
        public Date getBirthday() {
            return birthday;
        }
    
        public void setBirthday(Date birthday) {
            this.birthday = birthday;
        }
    
        public Sheep2(String sname, Date birthday) {
            this.sname = sname;
            this.birthday = birthday;
        }
    
        public Sheep2() {
        }
    
        @Override
        protected Object clone() throws CloneNotSupportedException {
            // 直接调用object对象的clone()方法
            Object obj = super.clone();
    
            // 添加如下代码实现深复制
            Sheep2 s = (Sheep2) obj;
            // 把属性也进行克隆
            s.birthday = (Date) this.birthday.clone();
    
            return obj;
        }
    }
    ```

  - 客户端同上

- 区别

  - 浅克隆和深克隆的区别

    ![img](https://img-blog.csdnimg.cn/20200206174059713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - 运行结果区别：浅克隆只是复制了生日变量对应的地址，这样即使值改变了，地址相同，则获得的生日的值也相同；深克隆将生日变量复制了一份，两个地址不同，因此原型的值变了，与复制的值无关，因此生日的值依然是之前复制的值。

- 利用序列化和反序列化的技术实现深克隆！

  ```java
  package com.sxt.prototype;
  
  import java.io.ByteArrayInputStream;
  import java.io.ByteArrayOutputStream;
  import java.io.ObjectInputStream;
  import java.io.ObjectOutputStream;
  import java.util.Date;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Client.java
   * @time: 2020/2/6 15:57
   * @desc: 测试原型模式(深复制)，使用序列化和反序列化的方式实现深复制
   */
  
  public class Client3 {
      public static void main(String[] args) throws Exception {
          Date d = new Date(3333333333L);
          Sheep1 s1 = new Sheep1("少理", d);
          System.out.println(s1);
          System.out.println(s1.getSname());
          System.out.println(s1.getBirthday());
  
          // 两个是不同的对象，但是值是一样的！
          // Sheep1 s2 = (Sheep1) s1.clone();
          // 这里用序列化和反序列化实现深复制，所以用的是Sheep1，即浅复制的类
          ByteArrayOutputStream bos = new ByteArrayOutputStream();
          ObjectOutputStream oos = new ObjectOutputStream(bos);
          oos.writeObject(s1);
          byte[] bytes = bos.toByteArray();
  
          ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
          ObjectInputStream ois = new ObjectInputStream(bis);
          Sheep1 s2 = (Sheep1) ois.readObject();
  
          // 修改s1生日
          d.setTime(22222222222L);
          System.out.println("--------------------------");
          System.out.println(s1.getBirthday());
  
          System.out.println(s2);
          System.out.println(s2.getSname());
          System.out.println(s2.getBirthday());
      }
  }
  ```

- 短时间大量创建对象时，原型模式和普通new方式效率测试：**如果需要短时间创建大量对象，并且new的过程比较耗时。则可以考虑使用原型模式！**

- 开发中的应用场景

  - 原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。
  - spring中bean的创建实际就是两种：单例模式和原型模式。（当然原型模式需要和工厂模式搭配起来，即原来是new一个对象，改为clone一个对象）

### 创建型模式总结

- 创建型模式：都是来帮助我们**创建对象**的！

  ![img](https://img-blog.csdnimg.cn/20200206194435516.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 5. 适配器模式

- 结构型模式：

  - 核心作用：是从程序的结构上实现送耦合，从而可以扩大整体的类结构，用来解决更大的问题
  - 分类：适配器模式、代理模式、桥接模式、装饰模式、组合模式、外观模式、享元模式

- 什么是适配器模式（adapter）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。

- 模式中的角色：

  - 目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。
  - 需要适配的类（Adaptee）：需要适配的类或适配者类。
  - 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。

- 代码：

  - 被适配的类（没有usb插口的键盘）

    ```java
    package com.sxt.adapter;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Adaptee.java
     * @time: 2020/2/7 11:01
     * @desc: 被适配的类，相当于PS/2键盘
     */
    
    public class Adaptee {
        public void request(){
            System.out.println("可以完成客户请求的需要的功能！");
        }
    }
    ```

  - 客户端（只有usb接口的笔记本电脑）

    ```java
    package com.sxt.adapter;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/7 11:02
     * @desc: 客户类，相当于笔记本，只有USB接口
     */
    
    public class Client {
        public void test1(Target t){
            t.handleReq();
        }
    
        public static void main(String[] args){
            Client c = new Client();
            Adaptee a = new Adaptee();
    
            // 方式1：类适配器方式
            Target t1 = new Adapter();
            // 方式2：对象适配器方式
            Target t2 = new Adapter2(a);
    
            c.test1(t2);
        }
    }
    ```

  - 接口：usb插口

    ```java
    package com.sxt.adapter;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Target.java
     * @time: 2020/2/7 11:02
     * @desc: 相当于USB插口
     */
    
    public interface Target {
        void handleReq();
    }
    ```

#### 5.1 类适配器方式

```java
package com.sxt.adapter;

/**
 * @author: Li Tian
 * @contact: litian_cup@163.com
 * @software: IntelliJ IDEA
 * @file: Adapter.java
 * @time: 2020/2/7 11:03
 * @desc: 【类适配器方式】适配器，相当于把键盘转换成usb接口的转接器
 */

public class Adapter extends Adaptee implements Target{
    // 我的理解：把适配器变成键盘（子类），并实现USB接口-->打字

    @Override
    public void handleReq() {
        super.request();
    }
}
```

#### 5.2 对象适配器方式

```java
package com.sxt.adapter;

/**
 * @author: Li Tian
 * @contact: litian_cup@163.com
 * @software: IntelliJ IDEA
 * @file: Adapter2.java
 * @time: 2020/2/7 11:07
 * @desc: 【对象组合的方式，对象适配器方式】适配器
 */

public class Adapter2 implements Target{
    // 我的理解：把原来不兼容的键盘接口变成Target（即USB接口）

    private Adaptee adaptee;

    @Override
    public void handleReq() {
        adaptee.request();
    }

    public Adapter2(Adaptee adaptee) {
        this.adaptee = adaptee;
    }
}
```

- 工作中的场景：

  - 经常用来做旧系统改造和升级
  - 如果我们的系统开发之后再也不需要维护，那么很多模式都是没必要的，但是不幸的是，事实却是维护一个系统的代价往往是开发一个系统的数倍。

- 我们学习中见过的场景

  - java.io.InputStreamReader(InputStream)
  - java.io.OutputStreamWriter(OutputStream)

- 以对象适配器为例，绘制UML类图

  ![img](https://img-blog.csdnimg.cn/20200207112750273.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 6. 代理模式

- Proxy Pattern
- 核心作用
  - 通过代理，控制对对象的访问
  - 可以详细控制访问某个（某类）对象的方法，在调用这个方法前做前置处理，调用这个方法后做后置处理。（即AOP的微观实现）；从而实现将统一流程代码放到代理类中处理。
  - AOP（Aspect Oriented Programming）：面向切面编程的核心实现机制。
    - 它是可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。它是一种新的方法论，它是对传统OOP编程的一种补充。
    - 常用术语：
      - 切面：Aspect，其实就是共有功能的实现。
      - 通知：Advice，是切面的具体实现。
      - 连接点：Jointpoint，就是程序在运行过程中能够插入切面的地点。
      - 切入点：Pointcut，用于定义通知应该切入到哪些连接点上。
      - 目标对象：Target，就是那些即将切入切面的对象，也就是那些被通知的对象。
      - 代理对象：Proxy，将通知应用到目标对象之后被动态创建的对象。
      - 织入：Weaving，将切面应用到目标对象从而创建一个新的代理对象的过程。
    - 开源的AOP框架：AspectJ
- 核心角色
  - 抽象角色：
    - 定义代理角色和真是角色的公共对外方法
  - 真实角色：
    - 实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。
    - 关注真正的业务逻辑！
  - 代理角色：
    - 实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。
    - 将统一的流程控制放到代理角色中处理。
  - 应用场景：
    - 安全代理：屏蔽对真实角色的直接访问。
    - 远程代理：通过代理类处理远程方法调用（RMI）。
    - 延迟代理：先加载轻量级的代理对象，真正需要再加载真实对象。（比如你要开发一个大文档查看系统，大文档中有大的图片，有可能一个图片有100MB，在打开文件时不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开。）
  - 分类：
    - 静态代理（静态定义代理类）
    - 动态代理（动态生成代理类）
      - JDK自带的动态代理
      - javassist字节码操作库实现
      - CGLIB
      - ASM（底层使用指令，可维护性较差）

#### 6.1 静态代理

- 代码：

  - 明星接口

    ```java
    package com.sxt.proxy.staticproxy;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Star.java
     * @time: 2020/2/7 13:51
     * @desc:
     */
    
    public interface Star {
        // 面谈
        void confer();
        // 签合同
        void signContract();
        // 订票
        void bookTicket();
        // 唱歌
        void sing();
        // 收钱
        void collectMoney();
    }
    ```

  - 真实明星

    ```java
    package com.sxt.proxy.staticproxy;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: RealStar.java
     * @time: 2020/2/7 13:53
     * @desc:
     */
    
    public class RealStar implements Star {
    
        private String name = "真实明星";
        @Override
        public void confer() {
            System.out.println(name + "面谈！");
        }
    
        @Override
        public void signContract() {
            System.out.println(name + "签合同");
        }
    
        @Override
        public void bookTicket() {
            System.out.println(name + "订票");
        }
    
        @Override
        public void sing() {
            System.out.println(name + "唱歌");
        }
    
        @Override
        public void collectMoney() {
            System.out.println(name + "收钱");
        }
    }
    ```

  - 代理经纪人

    ```java
    package com.sxt.proxy.staticproxy;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ProxyStar.java
     * @time: 2020/2/7 13:55
     * @desc:
     */
    
    public class ProxyStar implements Star {
        private String name = "经纪人";
        private Star star;
    
        public ProxyStar(Star star) {
            this.star = star;
        }
    
        @Override
        public void confer() {
            System.out.println(name + "面谈！");
        }
    
        @Override
        public void signContract() {
            System.out.println(name + "签合同");
        }
    
        @Override
        public void bookTicket() {
            System.out.println(name + "订票");
        }
    
        @Override
        public void sing() {
            star.sing();
        }
    
        @Override
        public void collectMoney() {
            System.out.println(name + "收钱");
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.proxy.staticproxy;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/7 13:57
     * @desc:
     */
    
    public class Client {
        public static void main(String[] args){
            Star real = new RealStar();
            Star proxy = new ProxyStar(real);
            proxy.confer();
            proxy.signContract();
            proxy.bookTicket();
            proxy.sing();
            proxy.collectMoney();
        }
    }
    ```

#### 6.2 动态代理

- 动态生成代理类

- 动态代理相比于静态代理的优点：抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样我们可以更加灵活和统一的处理众多的方法。

- JDK自带的动态代理

  - java.lang.reflect.Proxy
    - 作用：动态生成代理类和对象
  - java.lang.reflect.InvocationHandler（处理器接口）
    - 可以通过invoke方法实现对真实角色的代理访问。
    - 每次通过Proxy生成代理类对象时都要指出对应的处理器对象。

- 代码：

  - 明星接口和真实明星接口同上

  - 动态代理类

    ```java
    package com.sxt.proxy.dynamicproxy;
    
    import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: StarHandler.java
     * @time: 2020/2/7 16:19
     * @desc:
     */
    
    public class StarHandler implements InvocationHandler {
    
        Star realStar;
    
        public StarHandler(Star realStar) {
            this.realStar = realStar;
        }
    
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            Object obj = null;
            System.out.println("真正的方法执行前！");
            System.out.println("面谈，签合同等。。。");
            if (method.getName().equals("sing")) {
                obj = method.invoke(realStar, args);
            }
            System.out.println("真正的方法执行后！");
            System.out.println("收钱！");
    
            return obj;
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.proxy.dynamicproxy;
    
    import java.lang.reflect.Proxy;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/7 16:22
     * @desc:
     */
    
    public class Client {
        public static void main(String[] args){
            Star realStar = new RealStar();
            StarHandler handler = new StarHandler(realStar);
    
            Star proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Star.class}, handler);
    
            proxy.sing();
        }
    }
    ```

### 7. 桥接模式

- bridge pattern

- 场景：商场系统中常见的商品分类，以电脑为类，如何良好的处理商品分类销售的问题？

- 我们可以用**多继承结构**实现下图关系

  ```mermaid
  graph TB
  	A[电脑] --> B[台式机]
  	A --> C[笔记本]
  	A --> D[平板电脑]
  	
  	B --> B1[联想台式机]
  	B --> B2[戴尔台式机]
  	B --> B3[神舟台式机]
  	
  	C --> C1[联想笔记本]
  	C --> C2[戴尔笔记本]
  	C --> C3[神舟笔记本]
  
  	D --> D1[联想平板]
  	D --> D2[戴尔平板]
  	D --> D3[神舟平板]
  ```

- 问题：

  - 扩展性问题（类个数膨胀问题）：
    - 如果要增加一个新的电脑类型智能手机，则要增加各个品牌下面的类。
    - 如果要增加一个新的品牌，也要增加各种电脑类型的类。
  - 违反单一职责原则：一个类：联想笔记本，有两个引起这个类变化的原因。

- 桥接模式核心要点：处理多层集成结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。

  ![img](https://img-blog.csdnimg.cn/20200209145501919.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 桥接模式总结：

  - 桥接模式可以取代多层继承的方案。多层继承违背了单一职责原则，复用性较差，类的个数也非常多。桥接模式可以极大地减少子类的个数，从而降低管理和维护的成本。
  - 桥接模式极大的提高了系统可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有的系统，符合开闭原则。
  - 桥接模式可以完成java不能多重继承的功能。

- 桥接模式实际开发中应用场景

  - JDBC驱动查程序
  - AWT中的Peer架构
  - 银行日志管理：
    - 格式分类：操作日志、交易日志、异常日志
    - 距离分类：本地记录日志、异地记录日志
  - 人力资源系统中的奖金计算模块：
    - 奖金分类：个人奖金、团体奖金、激励奖金
    - 部分分类：人事部门、销售部门、研发部门
  - OA系统中的消息处理：
    - 业务类型：普通消息、加急消息、特急消息
    - 发送消息方式：系统内消息、手机短信、邮件

- 不用桥接模式的话

  ```java
  package com.sxt.bridge;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Computer.java
   * @time: 2020/2/9 14:44
   * @desc:
   */
  
  public interface Computer {
      void sale();
  }
  
  class Desktop implements Computer{
  
      @Override
      public void sale() {
          System.out.println("销售台式机！");
      }
  }
  
  class Laptop implements Computer{
  
      @Override
      public void sale() {
          System.out.println("销售笔记本！");
      }
  }
  
  class Pad implements Computer{
  
      @Override
      public void sale() {
          System.out.println("销售平板电脑！");
      }
  }
  
  class LenovoDesktop extends Desktop{
      @Override
      public void sale() {
          System.out.println("销售联想台式机！");;
      }
  }
  
  class LenovoLaptop extends Laptop{
      @Override
      public void sale() {
          System.out.println("销售联想笔记本！");;
      }
  }
  
  class LenovoPad extends Pad{
      @Override
      public void sale() {
          System.out.println("销售联想平板电脑！");;
      }
  }
  
  class ShenzhouDesktop extends Desktop{
      @Override
      public void sale() {
          System.out.println("销售神舟台式机！");;
      }
  }
  
  class ShenzhouLaptop extends Laptop{
      @Override
      public void sale() {
          System.out.println("销售神舟笔记本！");;
      }
  }
  
  class ShenzhouPad extends Pad{
      @Override
      public void sale() {
          System.out.println("销售神舟平板电脑！");;
      }
  }
  
  class DellDesktop extends Desktop{
      @Override
      public void sale() {
          System.out.println("销售戴尔台式机！");;
      }
  }
  
  class DellLaptop extends Laptop{
      @Override
      public void sale() {
          System.out.println("销售戴尔笔记本！");;
      }
  }
  
  class DellPad extends Pad{
      @Override
      public void sale() {
          System.out.println("销售戴尔平板电脑！");;
      }
  }
  ```

- 使用桥接模式

  - 品牌

    ```java
    package com.sxt.bridge;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Brand.java
     * @time: 2020/2/9 14:56
     * @desc: 品牌
     */
    
    public interface Brand {
        void sale();
    }
    
    class Lenovo implements Brand{
    
        @Override
        public void sale() {
            System.out.println("销售联想电脑！");
        }
    }
    
    class Dell implements Brand{
    
        @Override
        public void sale() {
            System.out.println("销售戴尔电脑！");
        }
    }
    ```

  - 电脑类型的维度

    ```java
    package com.sxt.bridge;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ComputerBridge.java
     * @time: 2020/2/9 14:58
     * @desc: 电脑类型的维度
     */
    
    public class ComputerBridge {
        protected Brand brand;
    
        public ComputerBridge(Brand brand) {
            this.brand = brand;
        }
    
        public void sale(){
            brand.sale();
        }
    }
    
    class Desktop2 extends ComputerBridge{
    
        public Desktop2(Brand brand) {
            super(brand);
        }
    
        @Override
        public void sale() {
            super.sale();
            System.out.println("销售台式机！");
        }
    }
    
    class Laptop2 extends ComputerBridge{
    
        public Laptop2(Brand brand) {
            super(brand);
        }
    
        @Override
        public void sale() {
            super.sale();
            System.out.println("销售笔记本电脑！");
        }
    }
    ```

  - 客户顿

    ```java
    package com.sxt.bridge;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/9 15:01
     * @desc:
     */
    
    public class Client {
        public static void main(String[] args){
            // 销售联想的笔记本电脑
            ComputerBridge c = new Laptop2(new Lenovo());
            c.sale();
            // 销售戴尔的台式机
            ComputerBridge c2 = new Desktop2(new Dell());
            c2.sale();
        }
    }
    ```

### 8. 组合模式

- composite patern

- 使用组合模式的场景：把部分和整体的关系用树形结构来表示，从而使得客户端可以使用**统一的方式处理部分对象和整体对象**。

- 组合模式核心：

  - 抽象（Component）构建角色：定义了叶子和容器构建的共同点
  - 叶子（Leaf）构建角色：无子节点
  - 容器（Composite）构建角色：有容器特征，可以包含子节点

- 抽象组件构成代码

  ```java
  package com.sxt.composite;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Component.java
   * @time: 2020/2/9 16:39
   * @desc: 抽象组件
   */
  
  public interface Component {
      void operation();
  }
  
  // 叶子组件
  interface Leaf extends Component {
  
  }
  // 容器组件
  interface Composite extends Component{
      void add(Component c);
      void remove(Component c);
      Component getChild(int index);
  }
  ```

- 组合模式工作流程分析：

  - 组合模式为处理树形结构提供了完美的解决方法，描述了如何将容器和叶子进行递归组合，使得用户在使用时可以一致性的对待容器和叶子。
  - 当容器对象的指定方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员，并调用执行。其中，使用了递归调用的机制对整个结构进行处理。

- 使用组合模式，模拟杀毒软件架构设计

  - 抽象构建

    ```java
    package com.sxt.composite;
    
    import java.util.ArrayList;
    import java.util.List;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: AbstarctFile.java
     * @time: 2020/2/9 16:46
     * @desc: 抽象构建
     */
    
    public interface AbstarctFile {
        void killVirus();
    }
    
    class ImageFile implements AbstarctFile{
        private String name;
    
        public ImageFile(String name) {
            this.name = name;
        }
    
        @Override
        public void killVirus() {
            System.out.println("---图像文件：" + name + "，进行查杀！");
        }
    }
    
    class TextFile implements AbstarctFile{
        private String name;
    
        public TextFile(String name) {
            this.name = name;
        }
    
        @Override
        public void killVirus() {
            System.out.println("---文本文件：" + name + "，进行查杀！");
        }
    }
    
    class VideoFile implements AbstarctFile{
        private String name;
    
        public VideoFile(String name) {
            this.name = name;
        }
    
        @Override
        public void killVirus() {
            System.out.println("---视频文件：" + name + "，进行查杀！");
        }
    }
    
    class Folder implements AbstarctFile{
        private String name;
        // 定义容器，用来存放本容器构建下的子节点
        private List<AbstarctFile> list = new ArrayList<>();
    
        public Folder(String name) {
            this.name = name;
        }
    
        public void add(AbstarctFile file){
            list.add(file);
        }
    
        public void remove(AbstarctFile file){
            list.remove(file);
        }
    
        public AbstarctFile getChild(int index){
            return list.get(index);
        }
    
        @Override
        public void killVirus() {
            System.out.println("---文件夹：" + name + "，进行查杀！");
            for (AbstarctFile file: list){
                file.killVirus();
            }
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.composite;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/9 16:54
     * @desc:
     */
    
    public class Client {
        public static void main(String[] args){
            AbstarctFile f2, f3, f5, f6;
            Folder f1 = new Folder("我的收藏");
            f2 = new ImageFile("我的头像.jpg");
            f3 = new TextFile("Hello.txt");
            f1.add(f2);
            f1.add(f3);
    
            Folder f4 = new Folder("电影");
            f5 = new VideoFile("神雕侠侣.avi");
            f6 = new VideoFile("笑傲江湖.avi");
    
            f4.add(f5);
            f4.add(f6);
            f1.add(f4);
    
            f1.killVirus();
        }
    }
    ```

- 开发中的应用场景

  - 操作系统的资源管理器
  - GUI中的容器层次图
  - XML文件解析
  - OA系统中，组织结构的处理
  - Junit单元测试框架：底层设计就是典型的组合模式，TestCase（叶子）、TestSuite（容器）、Test接口（抽象）

### 9. 装饰器模式

- decorator pattern

- 职责：
  - 动态的为一个对象增加新的功能。
  - 装饰器模式是一种用于代替继承的技术，**无须通过继承增加子类就能扩展对象的新功能。**使用对象的关联关系代替继承关系，更加灵活，**同时避免类型体系的快速膨胀。**
  
- 实现细节：
  
  - Component抽象构件角色：真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰对象交互。
  - ConcreteComponent具体构件角色（真实对象）：io流中的FileInputStream、FileOutoutStream
  - Decorator装饰角色：持有一个抽象构件的应用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调动前后增加新的功能。
  - ConcreteDecorator具体装饰角色：负责给构件对象增加新的责任。
  
- 代码

  - 抽象组件

    ```java
    package com.sxt.decorator;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ICar.java
     * @time: 2020/2/9 18:07
     * @desc: 抽象组件
     */
    
    public interface ICar {
        void move();
    }
    
    // 真实对象
    class Car implements ICar{
    
        @Override
        public void move() {
            System.out.println("陆地上跑");
        }
    }
    
    //装饰角色
    class SuperCar implements ICar{
        private ICar car;
    
        public SuperCar(ICar car) {
            this.car = car;
        }
    
        @Override
        public void move() {
            car.move();
        }
    }
    
    // 具体装饰对象
    class FlyCar extends SuperCar{
    
        public FlyCar(ICar car) {
            super(car);
        }
    
        public void fly(){
            System.out.println("天上飞！");
        }
    
        @Override
        public void move() {
            super.move();
            fly();
        }
    }
    
    class WaterCar extends SuperCar{
    
        public WaterCar(ICar car) {
            super(car);
        }
    
        public void swim(){
            System.out.println("水上游！");
        }
    
        @Override
        public void move() {
            super.move();
            swim();
        }
    }
    
    class AICar extends SuperCar{
    
        public AICar(ICar car) {
            super(car);
        }
    
        public void autoMove(){
            System.out.println("无人驾驶！");
        }
    
        @Override
        public void move() {
            super.move();
            autoMove();
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.decorator;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/9 18:13
     * @desc:
     */
    
    public class Client {
        public static void main(String[] args){
            Car car = new Car();
            car.move();
    
            System.out.println("增加新的功能，飞行！");
            FlyCar flyCar = new FlyCar(car);
            flyCar.move();
    
            System.out.println("增加新的功能，游泳！");
            WaterCar waterCar = new WaterCar(car);
            waterCar.move();
    
            System.out.println("增加新的功能，飞行和游泳！");
            WaterCar car2 = new WaterCar(new FlyCar(car));
            car2.move();
        }
    }
    ```

- UML类图

  ![img](https://img-blog.csdnimg.cn/20200209182145627.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 开发中使用的场景

  - IO中输入流和输出流的设计
  - Swing包中图形界面构件功能
  - Servlet API中提供了一个request对象的Decorator设计模式的默认实现类HTTPServletRequestWrapper， HTTPServletRequestWrapper类，增强了request对象的功能
  - Struts2中，request，response，session对象的处理

- IO流实现细节

  - Component抽象构件角色：io流中的InputStream、OutputStream、Reader、Writer
  - ConcreteComponent具体构件角色：io流中的FileInputStream、FileOutputStream
  - Decorator装饰角色：持有一个抽象构件的引用：io流中的FilterInputStream、FilterOutputStream
  - ConcreteDecorator具体装饰角色：负责给构件对象增加新的责任。io流中的BufferedOutputStream、BufferedInputStream等。

- 总结：

  - 装饰模式（Decorator）也叫包装器模式（Wrapper）
  - 装饰模式降低系统的耦合度，可以动态的增加或删减对象的职责，并使得需要装饰的具体构件类和具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类。

- 优点：

  - 扩展对象功能，比继承灵活，不会导致类的个数急剧增加
  - 可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更加强大的对象
  - 具体构件类和具体装饰类可以独立变化，用户可以根据需要自己增加新的具体构件子类和具体装饰子类

- 缺点：

  - 产生很多小对象。大量小对象占据内存，一定程度上影响性能。
  - 装饰模式容易出错，调试排查比较麻烦。

- **装饰模式和桥接模式的区别**：

  两个模式都是为了解决过多子类对象的问题。但是他们的诱因不一样。

  - 桥接模式是对象自身现有机制沿多个维度变化，是既有部分**不稳定**。
  - 装饰模式是为了增加新的功能。
  
- 我的理解是：

  - 桥接模式把**A维度**（品牌）接口当做**类**（电脑）的**属性**，然后**B维度**（电脑的类别）**继承类**，这样A维度通过实现不同的品牌来扩展，B维度通过生成不同的类别的子类来扩展。
  - 装饰器模式的主角是**类**（汽车），为了给这个类增加新的功能，新建了一个装饰器类，装饰器类的属性就是主角类。**新功能装饰器**相当于实现了新功能的主角类，并继承**装饰器类**，因此实现了给主角类添加新功能的目的。
  - 没有装饰者和被装饰者的主次区别，桥接和被桥接者是平等的，**不用继承自同一个父类**。（即桥接可以互换）
  - 桥接模式不用使用同一个接口；装饰模式用同一个接口装饰，接口在父类中定义。
  - 都可以处理类扩散的情况。

### 10. 外观模式
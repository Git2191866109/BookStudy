### 21. 观察者模式

- Observer Pattern

- 场景

  - 广播机制
  - 聊天室
  - 新闻订阅
  - CS游戏

- 上面这些场景，我们都可以使用观察者模式处理。我们可以把多个订阅者、客户称之为观察者；需要同步给多个订阅者的数据封装到对象中，称之为目标。

- 核心：

  - 观察者模式主要用于1：N的通知。当一个对象（目标对象Subject或Objservable，消息发布）的状态发生变化时，他需要及时告知一系列对象（观察者对象，Observer，消息订阅），令他们做出响应。
  - 通知观察者的方式
    - 推：每次都会把通知以广播方式发送给所有观察者，所有观察者只能被动接受。
    - 拉：观察者只要知道有情况即可。至于什么时候获取内容，获取什么内容，都可以自主决定。

- UML类图

  ![img](https://img-blog.csdnimg.cn/20200301135853806.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 代码：

  - 消息发布对象

    ```java
    package com.sxt.observer;
    
    import java.util.ArrayList;
    import java.util.List;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Subject.java
     * @time: 2020/3/1 13:36
     * @desc: |
     */
    
    public class Subject {
        protected List<Observer> list = new ArrayList<>();
    
        public void registerObserver(Observer obs) {
            list.add(obs);
        }
    
        public void removeObserver(Observer obs) {
            list.remove(obs);
        }
    
        // 通知所有的观察者更新状态
        public void notifyAllObservers() {
            for (Observer obs : list) {
                obs.update(this);
            }
        }
    }
    ```

  - 消息发布对象的具体实现

    ```java
    package com.sxt.observer;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ConcreteSubject.java
     * @time: 2020/3/1 13:41
     * @desc: |
     */
    
    public class ConcreteSubject extends Subject {
        private int state;
    
        public int getState() {
            return state;
        }
    
        public void setState(int state) {
            this.state = state;
            // 主题对象/目标对象的值发生了变化，请通知所有的观察者
            this.notifyAllObservers();
        }
    }
    ```

  - 观察者接口

    ```java
    package com.sxt.observer;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Observer.java
     * @time: 2020/3/1 13:36
     * @desc: |
     */
    
    public interface Observer {
        void update(Subject subject);
    }
    ```

  - 观察者

    ```java
    package com.sxt.observer;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ObserverA.java
     * @time: 2020/3/1 13:43
     * @desc: |
     */
    
    public class ObserverA implements Observer {
        // myState需要跟目标对象的值保持一致
        private int myState;
    
        public int getMyState() {
            return myState;
        }
    
        public void setMyState(int myState) {
            this.myState = myState;
        }
    
        @Override
        public void update(Subject subject) {
            myState = ((ConcreteSubject)subject).getState();
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.observer;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/3/1 13:45
     * @desc: |
     */
    
    public class Client {
        public static void main(String[] args){
            // 创建目标对象
            ConcreteSubject subject = new ConcreteSubject();
            // 创建多个观察者
            ObserverA obs1 = new ObserverA();
            ObserverA obs3 = new ObserverA();
            ObserverA obs2 = new ObserverA();
    
            // 让这三个观察者添加到subject对象的观察者队伍中
            subject.registerObserver(obs1);
            subject.registerObserver(obs2);
            subject.registerObserver(obs3);
    
            // 改变subject的状态
            subject.setState(3000);
            // 查看观察者的状态
            System.out.println(obs1.getMyState());
            System.out.println(obs2.getMyState());
            System.out.println(obs3.getMyState());
        }
    }
    ```

- JAVASE中提供了java.util.Observable和java.util.Observer来实现观察者模式

  - 目标对象

    ```java
    package com.sxt.observer2;
    
    import java.util.Observable;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ConcreteSubject.java
     * @time: 2020/3/1 14:05
     * @desc: |
     */
    
    public class ConcreteSubject extends Observable {
        private int state;
    
        public int getState() {
            return state;
        }
    
        public void setState(int state) {
            this.state = state;
        }
    
        public void set(int s){
            // 目标对象的状态发生了改变
            state = s;
            // 表示目标对象已经发生了更改
            setChanged();
            // 通知所有的观察者
            notifyObservers(state);
        }
    }
    ```

  - 观察者对象

    ```java
    package com.sxt.observer2;
    
    import java.util.Observable;
    import java.util.Observer;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ObserverA.java
     * @time: 2020/3/1 14:07
     * @desc: |
     */
    
    public class ObserverA implements Observer {
        private int myState;
    
        public int getMyState() {
            return myState;
        }
    
        public void setMyState(int myState) {
            this.myState = myState;
        }
    
        @Override
        public void update(Observable o, Object arg) {
            myState = ((ConcreteSubject)o).getState();
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.observer2;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/3/1 14:09
     * @desc: |
     */
    
    public class Client {
        public static void main(String[] args){
            // 创建目标对象Observable
            ConcreteSubject subject = new ConcreteSubject();
    
            // 创建观察者
            ObserverA obs1 = new ObserverA();
            ObserverA obs2 = new ObserverA();
            ObserverA obs3 = new ObserverA();
    
            // 将上面三个观察者对象加到目标对象subject的观察者容器中
            subject.addObserver(obs1);
            subject.addObserver(obs2);
            subject.addObserver(obs3);
    
            // 改变subject对象的状态
            subject.set(300);
    
            // 看看观察者的状态发生变化了没
            System.out.println(obs1.getMyState());
            System.out.println(obs2.getMyState());
            System.out.println(obs3.getMyState());
        }
    }
    ```

- 开发中常见的场景

  - 聊天室程序的，服务器转发给所有客户端
  - 网络游戏（多人联机对战）场景中，服务器将客户端的状态进行分发
  - 邮件订阅
  - Servlet中，监听器的实现
  - Android中，广播机制
  - JDK的AWT中事件处理模型，基于观察者模式的委派事件模型（Delegation Event Model）
    - 事件源 --> 目标对象
    - 事件监听器 --> 观察者
  - 京东商城中，群发某商品打折信息

### 22. 备忘录模式

- memento pattern

- 场景：

  - 录入大批人员资料。正在录入当前人资料时，发现上一个人录错了，此时需要恢复上一个人的资料，再进行修改。
  - Word文档编辑时，忽然电脑死机或断电，再打开时，可以看到word提示你恢复到以前的文档。
  - 管理系统中，公文撤回功能。公文发送出去后，想撤回来。

- 核心：就是保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态。

- 结构

  - 源发器类Originator
  - 备忘录类Memento
  - 负责人类CareTaker

- 代码：

  - 源发器类

    ```java
    package com.sxt.memento;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Emp.java
     * @time: 2020/3/1 14:38
     * @desc: |源发器类
     */
    
    public class Emp {
        private String name;
        private int age;
        private double salary;
    
        // 进行备忘操作，并返回备忘录对象
        public EmpMemento memento() {
            return new EmpMemento(this);
        }
    
        // 进行数据恢复，恢复成制定备忘录对象的值
        public void recovery(EmpMemento mmt){
            this.name = mmt.getName();
            this.age = mmt.getAge();
            this.salary = mmt.getSalary();
        }
    
        public Emp(String name, int age, double salary) {
            this.name = name;
            this.age = age;
            this.salary = salary;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public int getAge() {
            return age;
        }
    
        public void setAge(int age) {
            this.age = age;
        }
    
        public double getSalary() {
            return salary;
        }
    
        public void setSalary(double salary) {
            this.salary = salary;
        }
    }
    ```

  - 备忘录类

    ```java
    package com.sxt.memento;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: EmpMemento.java
     * @time: 2020/3/1 14:54
     * @desc: |备忘录类
     */
    
    public class EmpMemento {
        private String name;
        private int age;
        private double salary;
    
        public EmpMemento(Emp e){
            this.name = e.getName();
            this.age = e.getAge();
            this.salary = e.getSalary();
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public int getAge() {
            return age;
        }
    
        public void setAge(int age) {
            this.age = age;
        }
    
        public double getSalary() {
            return salary;
        }
    
        public void setSalary(double salary) {
            this.salary = salary;
        }
    }
    ```

  - 负责人类：管理备忘录对象

    - 负责保存好的备忘录对象
    - 可以通过增加容器，设置多个**备忘点**

    ```java
    package com.sxt.memento;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: CareTaker.java
     * @time: 2020/3/1 14:58
     * @desc: |负责人类：管理备忘录对象
     */
    
    public class CareTaker {
        private EmpMemento memento;
    
        public EmpMemento getMemento() {
            return memento;
        }
    
        public void setMemento(EmpMemento memento) {
            this.memento = memento;
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.memento;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/3/1 14:58
     * @desc: |
     */
    
    public class Client {
        public static void main(String[] args) {
            CareTaker taker = new CareTaker();
            Emp emp = new Emp("李英俊", 18, 900);
            System.out.println("第一次创建对象：" + emp.getName() + emp.getAge() + emp.getSalary());
    
            // 进行一次备份
            taker.setMemento(emp.memento());
    
            emp.setAge(38);
            emp.setName("哈哈");
            emp.setSalary(10);
            System.out.println("第二次创建对象：" + emp.getName() + emp.getAge() + emp.getSalary());
    
            // 恢复到备忘录对象保存的状态
            emp.recovery(taker.getMemento());
            System.out.println("第三次创建对象：" + emp.getName() + emp.getAge() + emp.getSalary());
        }
    }
    ```

- UML类图

  ![img](https://img-blog.csdnimg.cn/20200301150434799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 备忘点较多时

  - 将备忘录压栈
  - 将多个备忘录对象，序列化和持久化

- 开发中常见的应用场景：

  - 棋类游戏中的悔棋操作
  - 普通软件中的，撤销操作
  - 数据库管理软件中的，事务管理中的回滚操作
  - PS中的历史记录

## 第4章 正则表达式

- 文本的复杂处理
- regular expression
- 开发中使用正则表达式的流程：
  - 分析所有匹配的数据，写出测试用的典型数据
  - 在工具软件中进行匹配测试
  - 在程序中调用通过测试的正则表达式
- regexbuddy工具

### 1. 正则表达式语法

- 普通字符：匹配与之相同的一个字符

- 简单的转义字符：

  ![img](https://img-blog.csdnimg.cn/20200302164121481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 标准字符集合

  - 能够与“多种字符”匹配的表达式
  - 注意区分带小写，大写是相反的意思（比如\d是匹配一个数字，\D就是匹配非数字）
  - 小数点不能匹配换行符\n
  - [\s\S]用来匹配任意字符，包括换行符

  ![img](https://img-blog.csdnimg.cn/20200302164341954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 自定义字符集合

  - []方括号匹配方式，能够匹配方括号中任意一个字符

  ![img](https://img-blog.csdnimg.cn/20200302171739602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
  
  - 正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了^，-之外
  - 标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合将包含该集合。比如：`[\d.\-+]`将匹配：数字、小数点、+、-
  
- 量词 | Quantifier

  - 修饰匹配次数的特殊符号

    ![img](https://img-blog.csdnimg.cn/20200302172135883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

    `\d\d{6} != {\d\d}{6}`

  - 匹配次数中的贪婪模式（匹配字符越多越好，默认！）

  - 匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个“?”号）例：`\d{2,3}?`

- 字符边界（零宽）

  - 本组标记匹配的不是字符而是位置，符合某 种条件的位置

  - \b匹配这样一个位置：前面的字符和后面的字符不全是\w

    ![img](https://img-blog.csdnimg.cn/2020030217462748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - `gaoqi\b`测试：

    ![img](https://img-blog.csdnimg.cn/20200302175434396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - `\bgaoqi\b`测试：

    ![img](https://img-blog.csdnimg.cn/20200302175347409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- IGNORECASE：忽略大小写模式

  - 匹配时忽略大小写
  - 默认情况下，正则表达式是要区分大小写的

- SINGLELINE：单行模式

  - 整个文本看作一个字符串，只有一个开头，一个结尾。
  - 使小数点“.”可以匹配包含换行符（\n）在内的任意字符。

- MULTILINE：多行模式

  - 每行都是一个字符串，都有开头和结尾
  - **在制定了MULTILINE之后**，如果需要仅匹配字符串开始和结束位置，可以使用**\A和\Z**
  
- 选择符和分组

  ![img](https://img-blog.csdnimg.cn/20200303132643924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 反向引用(\nnm)

  - 每一对()会分配一个编号，使用()的捕获根据左括号的顺序从1开始自动编号。
  - 通过反向应用，可以对分组已捕获的字符串进行应用。

- 预搜索（零宽断言）

  - 只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度

  - 这个位置应该符合某个条件。判断当前位置的前后字符，是否符合指定的条件，但不匹配前后的字符。是对位置的匹配。

  - 正则表达式匹配过程中，如果子表达式匹配到的是字符的内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是**零宽度**的。占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的。

    ![img](https://img-blog.csdnimg.cn/20200303133858867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 2. 正则表达式的练习

- 练习1

  ![img](https://img-blog.csdnimg.cn/20200303134726764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 解答1：`(0\d{2,3}-\d{7,8})|(1[35789]\d{9})`

- 练习2

  ![img](https://img-blog.csdnimg.cn/20200303135138293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 解答2：`[\w\-]+@[a-z0-9A-Z]+(\.[A-Za-z]{2,4}){1,2}`

### 3. 常用正则表达式列表

![img](https://img-blog.csdnimg.cn/20200303135611213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 4. JAVA程序中使用正则表达式

- 开发环境

  - 开发环境和文本编译器中使用正则
  - 数据库中也可以使用正则

- JAVA相关类位于java.util.regex包下面

- 类Pattern：

  - 正则表达式的编译表现形式
  - 建立正则表达式，并启用相应模式
  - `Pattern p = Pattern.compile(r, int);`

- 类Matcher：

  - 通过解释Pattern对character sequence执行匹配操作的引擎
  - 匹配str字符串
  - `Matcher m = p.matcher(str);`

- 测试

  - 匹配整个正则表达式

    ```java
    package com.sxt.regex;
    
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Demo01.java
     * @time: 2020/3/3 14:10
     * @desc: |
     */
    
    public class Demo01 {
        public static void main(String[] args){
            // 在这个字符串：asdfsadf2323，是否符合制定的正则表达式：\w+
            Pattern p = Pattern.compile("\\w+");
            // 创建Matcher对象
            Matcher m = p.matcher("asdfsadf@@2323");
            // 尝试将整个字符序列与该模式匹配
            // boolean yo = m.matches();
            // 该方法扫描输入的序列，查找与该模式匹配的下一个子序列
            while(m.find()){
                // group()和group(0)都是匹配整个表达式的子字符串
                System.out.println(m.group());
                System.out.println(m.group(0));
            }
        }
    }
    ```

  - 测试正则表达式分组的处理

    ```java
    package com.sxt.regex;
    
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @desc: | 测试正则表达式分组的处理
     */
    
    public class Demo02 {
        public static void main(String[] args) {
            // 在这个字符串：asdfsadf2323，是否符合制定的正则表达式：\w+
            Pattern p = Pattern.compile("([a-z]+)([0-9]+)");
            // 创建Matcher对象
            Matcher m = p.matcher("asdfsa12**asd233**dsd11");
            // 尝试将整个字符序列与该模式匹配
            while (m.find()) {
                // group()和group(0)都是匹配整个表达式的子字符串
                System.out.println("start---");
                System.out.println("满足整个表达式的子字符串：");
                System.out.println(m.group());
                System.out.println("满足第1个括号中表达式的字符串：");
                System.out.println(m.group(1));
                System.out.println("满足第2个括号中表达式的字符串：");
                System.out.println(m.group(2));
            }
        }
    }
    ```

  - 测试正则表达对象替换操作

    ```java
    package com.sxt.regex;
    
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @desc: | 测试正则表达对象替换操作
     */
    
    public class Demo03 {
        public static void main(String[] args) {
            // 在这个字符串：asdfsadf2323，是否符合制定的正则表达式：\w+
            Pattern p = Pattern.compile("[0-9]");
            // 创建Matcher对象
            Matcher m = p.matcher("asdfsa12**asd233**dsd11");
    
            // 替换
            String newStr = m.replaceAll("#");
            System.out.println(newStr);
        }
    }
    ```

  - 测试正则表达对象分割字符串的操作

    ```java
    package com.sxt.regex;
    
    import java.util.Arrays;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @desc: | 测试正则表达对象分割字符串的操作
     */
    
    public class Demo04 {
        public static void main(String[] args) {
            String str = "asdfsa12asd233dsd11";
    
            // 切割
            String[] arrs = str.split("\\d+");
            System.out.println(Arrays.toString(arrs));
        }
    }
    ```

### 5. 手写网络爬虫
### 2. 工厂模式（3种）

- 实现了创建者和调用者的分离
- 详细分类：
  - **简单工厂模式**：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）
  - **简单方法模式**：用来生产同一等级结构中的固定产品。（支持增加任意产品）
  - **抽象工厂模式**：用来生产不同产品族的全部产品。（对于增加的新产品，无能为力，支持增加产品族）
- 面向对象设计基本原则：
  - OCP（开闭原则，Open-Closed Principle）：一个软件的实体应当对扩展开放，对修改关闭
  - DIP（依赖倒转原则，Dependence Inversion Principle）：要针对接口编程，不要针对实现编程
  - LoD（迪米特法则，Law of Demeter）：只与你直接的朋友通信，而避免和陌生人通信
- 核心本质：
  - 实例化对象，用工厂方法代替new操作
  - 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。

#### 2.1 简单工厂模式

- 要点：

  - 简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法，通过接受的参数的不同来返回不同的对象实例。
  - 对于增加新产品无能为力！不修改代码的话，是无法扩展的。

- 代码：

  - Car接口

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Car.java
     * @time: 2020/2/5 15:59
     * @desc:
     */
    
    public interface Car {
        void run();
    }
    ```

  - 奥迪车

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Audi.java
     * @time: 2020/2/5 16:00
     * @desc:
     */
    
    public class Audi implements Car {
        @Override
        public void run() {
            System.out.println("奥迪在跑！");
        }
    }
    ```

  - 比亚迪车

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Byd.java
     * @time: 2020/2/5 16:01
     * @desc:
     */
    
    public class Byd implements Car {
        @Override
        public void run() {
            System.out.println("比亚迪在跑！");
        }
    }
    ```

  - 测试在没有工厂模式的情况下

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client01.java
     * @time: 2020/2/5 16:02
     * @desc: 测试在没有工厂模式的情况下
     */
    
    public class Client01 { // 调用者
        public static void main(String[] args){
            Car c1 = new Audi();
            Car c2 = new Byd();
            c1.run();
            c2.run();
        }
    }
    ```

  - 简单工厂类1

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: CarFactory.java
     * @time: 2020/2/5 16:04
     * @desc:
     */
    
    public class CarFactory {
        public static Car createCar(String type){
            if("奥迪".equals(type)){
                return new Audi();
            }else if("比亚迪".equals(type)){
                return new Byd();
            }else{
                // 简单工厂还是有点小问题的，这里如果要加新的车辆的话，就需要改代码，违反了开闭原则OCP
                return null;
            }
        }
    }
    ```

  - 简单工厂2

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: CarFactory.java
     * @time: 2020/2/5 16:04
     * @desc: 简单工厂类2
     */
    
    public class CarFactory2 {
        public static Car createAudi() {
            return new Audi();
        }
    
        public static Car createByd() {
            return new Byd();
        }
    }
    ```

  - 测试在简单工厂模式的情况下

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client01.java
     * @time: 2020/2/5 16:02
     * @desc: 测试在简单工厂模式的情况下
     */
    
    public class Client02 { // 调用者
        public static void main(String[] args){
            Car c1 = CarFactory.createCar("奥迪");
            Car c2 = CarFactory.createCar("比亚迪");
            c1.run();
            c2.run();
        }
    }
    ```

- UML类图

  ![img](https://img-blog.csdnimg.cn/20200205162526807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

#### 2.2 工厂方法模式

- 为了避免简单工厂模式的缺点，不完全满足OCP。

- 工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。

- 代码：

  - 新增了车的工厂interface

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: CarFactory.java
     * @time: 2020/2/5 19:42
     * @desc:
     */
    
    public interface CarFactory {
        Car createCar();
    }
    ```

  - 实现了车工厂的audi工厂

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: AudiFactory.java
     * @time: 2020/2/5 19:42
     * @desc:
     */
    
    public class AudiFactory implements CarFactory {
        @Override
        public Car createCar() {
            return new Audi();
        }
    }
    ```

  - 实现了车工厂的byd工厂

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: BydFactory.java
     * @time: 2020/2/5 19:43
     * @desc:
     */
    
    public class BydFactory extends Byd implements CarFactory {
        @Override
        public Car createCar() {
            return new Byd();
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/5 19:44
     * @desc:
     */
    
    public class Client {
        public static void main(String[] args){
            Car c1 = new AudiFactory().createCar();
            Car c2 = new BydFactory().createCar();
            Car c3 = new BenzFactory().createCar();
    
            c1.run();
            c2.run();
            c3.run();
        }
    }
    ```

  - 如果需要新增车的类型的话，不需要修改原来的代码，只需要增加类就行，即满足了OCP

  - 新增benz类

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Benz.java
     * @time: 2020/2/5 19:45
     * @desc:
     */
    
    public class Benz extends BenzFactory implements Car {
        @Override
        public void run() {
            System.out.println("奔驰在跑！");
        }
    }
    ```

  - 新增benz工厂

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Benz.java
     * @time: 2020/2/5 19:45
     * @desc:
     */
    
    public class Benz extends BenzFactory implements Car {
        @Override
        public void run() {
            System.out.println("奔驰在跑！");
        }
    }
    ```

- 简单工厂模式和工厂方法模式PK：

  ![img](https://img-blog.csdnimg.cn/20200205201001445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 根据设计理论建议：工厂方法模式。但实际上，我们一般都用**简单工厂模式**。

#### 2.3 抽象工厂模式

- 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）

- 抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。

- 代码：

  - 发动机

    ```java
    package com.sxt.factory.abstractfactory;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Engine.java
     * @time: 2020/2/6 12:40
     * @desc:
     */
    
    public interface Engine {
        void run();
        void start();
    }
    
    class LuxuryEngine implements Engine{
    
        @Override
        public void run() {
            System.out.println("转得快！");
        }
    
        @Override
        public void start() {
            System.out.println("启动快！可以自动启停！");
        }
    }
    class LowerEngine implements Engine{
    
        @Override
        public void run() {
            System.out.println("转得慢！");
        }
    
        @Override
        public void start() {
            System.out.println("启动慢！可以自动启停！");
        }
    }
    ```

  - 座位

    ```java
    package com.sxt.factory.abstractfactory;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Seat.java
     * @time: 2020/2/6 12:42
     * @desc:
     */
    
    public interface Seat {
        void massage();
    }
    
    class LuxurySeat implements Seat{
    
        @Override
        public void massage() {
            System.out.println("可以按摩！");
        }
    }
    class LowerSeat implements Seat{
    
        @Override
        public void massage() {
            System.out.println("不可以按摩！");
        }
    }
    ```

  - 轮胎

    ```java
    package com.sxt.factory.abstractfactory;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Tyre.java
     * @time: 2020/2/6 12:43
     * @desc:
     */
    
    public interface Tyre {
        void revolve();
    }
    
    class LuxuryTyre implements Tyre{
    
        @Override
        public void revolve() {
            System.out.println("磨损慢！");
        }
    }
    class LowerTyre implements Tyre{
    
        @Override
        public void revolve() {
            System.out.println("磨损快！");
        }
    }
    
    ```

  - 车工厂

    ```java
    package com.sxt.factory.abstractfactory;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: CarFactory.java
     * @time: 2020/2/6 12:44
     * @desc:
     */
    
    public interface CarFactory {
        Engine createEngine();
        Seat createSeat();;
        Tyre createTyre();
    }
    ```

  - 高端车工厂

    ```java
    package com.sxt.factory.abstractfactory;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LuxuryCarFactory.java
     * @time: 2020/2/6 12:45
     * @desc:
     */
    
    public class LuxuryCarFactory implements CarFactory {
    
        @Override
        public Engine createEngine() {
            return new LuxuryEngine();
        }
    
        @Override
        public Seat createSeat() {
            return new LuxurySeat();
        }
    
        @Override
        public Tyre createTyre() {
            return new LuxuryTyre();
        }
    }
    ```

  - 低端车工厂

    ```java
    package com.sxt.factory.abstractfactory;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: LowerCarFactory.java
     * @time: 2020/2/6 12:45
     * @desc:
     */
    
    public class LowerCarFactory implements CarFactory {
    
        @Override
        public Engine createEngine() {
            return new LowerEngine();
        }
    
        @Override
        public Seat createSeat() {
            return new LowerSeat();
        }
    
        @Override
        public Tyre createTyre() {
            return new LowerTyre();
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.factory.abstractfactory;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/6 12:47
     * @desc:
     */
    
    public class Client {
        public static void main(String[] args){
            CarFactory factory = new LuxuryCarFactory();
            Engine e = factory.createEngine();
            e.run();
            e.start();
        }
    }
    ```

- 工厂模式要点
  - 简单工厂模式（静态工厂模式）：虽然某种程度不符合实际原则，但实际使用最多
  - 工厂方法模式：不修改已有类的前提下，通过增加新的工厂实现扩展。
  - 抽象工厂模式：不可以增加产品，但可以增加产品族。
- 应用场景
  - JDK中Calendar的getInstance方法
  - JDBC中Connection对象的获取
  - Hibernate中SessionFactory创建Session
  - spring中IOC容器创建管理bean对象
  - XML解析时的DocumentBuilderFactory创建解析器对象
  - 反射中Class对象的newInstance

### 3. 建造者模式

- 场景：

  - 我们要建造一个复杂的产品。比如神舟飞船、Iphone。这个复杂的产品的创建，有这样的一个问题要处理：装配这些子组件是不是有个步骤问题？
  - 实际开发中，我们所需要的对象构建时，也非常复杂，有很多步骤需要处理时。

- 建造者模式的本质

  - 分离了对象子组件的单独构造（由Builder来负责）和装配（由Director负责）。从而可以构造出复杂的对象。这个模式适用于：**某个对象的构造过程复杂的情况下使用。**
  - 由于实现了构造和装配的解耦。不同的构造器，相同的装配，也可以做出不同的对象；相同的装备构造器，不同的装配顺序也可以做出不同的对象。也就是实现了构造算法、装配算法的解耦，实现了更好的复用。

- 代码：

  - 宇宙飞船

    ```java
    package com.sxt.builder;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: AirShip.java
     * @time: 2020/2/6 13:48
     * @desc: 宇宙飞船
     */
    
    public class AirShip {
        // 轨道舱
        private OrbitalModule orbitalModule;
        // 发动机
        private Engine engine;
        // 逃逸仓
        private EscapeTower escapeTower;
    
        public void launch(){
            System.out.println("发动机【" + engine.getName() + "】" + "轨道舱【" + orbitalModule.getName() + "】" + "逃离塔【" + escapeTower.getName() + "】" + "-->发射！");
        }
    
        public OrbitalModule getOrbitalModule() {
            return orbitalModule;
        }
    
        public void setOrbitalModule(OrbitalModule orbitalModule) {
            this.orbitalModule = orbitalModule;
        }
    
        public Engine getEngine() {
            return engine;
        }
    
        public void setEngine(Engine engine) {
            this.engine = engine;
        }
    
        public EscapeTower getEscapeTower() {
            return escapeTower;
        }
    
        public void setEscapeTower(EscapeTower escapeTower) {
            this.escapeTower = escapeTower;
        }
    }
    
    class OrbitalModule {
        private String name;
    
        public OrbitalModule(String name) {
            this.name = name;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    }
    
    class Engine {
        private String name;
    
        public Engine(String name) {
            this.name = name;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    }
    
    class EscapeTower{
        private String name;
    
        public EscapeTower(String name) {
            this.name = name;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    }
    ```

  - 构建者接口

    ```java
    package com.sxt.builder;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: AirShipBuilder.java
     * @time: 2020/2/6 13:53
     * @desc:
     */
    
    public interface AirShipBuilder {
        Engine buildEngine();
        OrbitalModule builderOrbitalModule();
        EscapeTower buildEscapeTower();
    }
    ```

  - 装配者接口

    ```java
    package com.sxt.builder;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: AirShipDirector.java
     * @time: 2020/2/6 13:54
     * @desc: 组装飞船对象
     */
    
    public interface AirShipDirector {
        // 组装飞船对象
        AirShip directAirShip();
    }
    ```

  - 构建者

    ```java
    package com.sxt.builder;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: MyAirShipBuilder.java
     * @time: 2020/2/6 13:55
     * @desc:
     */
    
    public class MyAirShipBuilder implements AirShipBuilder{
    
        @Override
        public Engine buildEngine() {
            System.out.println("构建发动机！");
            return new Engine("我的发动机");
        }
    
        @Override
        public OrbitalModule builderOrbitalModule() {
            System.out.println("构建轨道舱！");
            return new OrbitalModule("我的轨道舱");
        }
    
        @Override
        public EscapeTower buildEscapeTower() {
            System.out.println("构建逃逸塔！");
            return new EscapeTower("我的逃逸塔");
        }
    }
    ```

  - 装配者

    ```java
    package com.sxt.builder;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: MyAirShipDirector.java
     * @time: 2020/2/6 13:59
     * @desc:
     */
    
    public class MyAirShipDirector implements AirShipDirector{
    
        private AirShipBuilder builder;
    
        public MyAirShipDirector(AirShipBuilder builder) {
            this.builder = builder;
        }
    
        @Override
        public AirShip directAirShip() {
            // 从构建者获取组件
            Engine e = builder.buildEngine();
            OrbitalModule o = builder.builderOrbitalModule();
            EscapeTower es = builder.buildEscapeTower();
    
            // 进行组装
            AirShip ship = new AirShip();
            ship.setEngine(e);
            ship.setOrbitalModule(o);
            ship.setEscapeTower(es);
    
            return ship;
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.builder;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/6 14:02
     * @desc:
     */
    
    public class Client {
        public static void main(String[] args) {
            AirShipDirector director = new MyAirShipDirector(new MyAirShipBuilder());
    
            AirShip ship = director.directAirShip();
    
            ship.launch();
        }
    }
    ```

  - UML类图

    ![img](https://img-blog.csdnimg.cn/20200206141722278.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 开发中应用场景：

  - StringBuilder类的append方法
  - SQL中的PreparedStatement
  - JDOM中，DomBuilder、SAXBuilder

### 4. 原型模式

- 又叫克隆模式、拷贝模式，prototype
- 根据拷贝方式不同分为
- 场景：
  - 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
  - 就是java中的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点。
  - 优势有：效率高（直接克隆，避免了重新执行构造过程步骤）。
  - 克隆类似于new，但是不同于new。new创建新的对象属性采用的是默认值。克隆出的对象的属性值完全和原型对象相同。并且克隆出的新对象改变不会影响原型对象。然后，再修改克隆对象的值。
- 实现：
  - Cloneable接口和clone方法
  - Prototype模式中实现起来最困难的地方就是内存复制操作，所幸在java中提供了clone()方法替我们做了绝大部分事情。
- 注意用词：克隆和拷贝一回事。

#### 4.1 浅克隆

- 代码：

  - 羊

    ```java
    package com.sxt.prototype;
    
    import java.util.Date;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Sheep1.java
     * @time: 2020/2/6 15:53
     * @desc: 测试浅复制
     */
    
    public class Sheep1 implements Cloneable{
        private String sname;
        private Date birthday;
    
        public String getSname() {
            return sname;
        }
    
        public void setSname(String sname) {
            this.sname = sname;
        }
    
        public Date getBirthday() {
            return birthday;
        }
    
        public void setBirthday(Date birthday) {
            this.birthday = birthday;
        }
    
        public Sheep1(String sname, Date birthday) {
            this.sname = sname;
            this.birthday = birthday;
        }
    
        public Sheep1() {
        }
    
        @Override
        protected Object clone() throws CloneNotSupportedException {
            // 直接调用object对象的clone()方法
            Object obj = super.clone();
            return obj;
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.prototype;
    
    import java.util.Date;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client2.java
     * @time: 2020/2/6 15:57
     * @desc: 测试原型模式(浅复制)
     */
    
    public class Client1 {
        public static void main(String[] args) throws CloneNotSupportedException {
            Date d = new Date(3333333333L);
            Sheep1 s1 = new Sheep1("少理", d);
            System.out.println(s1);
            System.out.println(s1.getSname());
            System.out.println(s1.getBirthday());
    
            // 两个是不同的对象，但是值是一样的！
            Sheep1 s2 = (Sheep1) s1.clone();
    
            // 修改s1生日
            d.setTime(22222222222L);
            System.out.println("--------------------------");
            System.out.println(s1.getBirthday());
    
            System.out.println(s2);
            System.out.println(s2.getSname());
            System.out.println(s2.getBirthday());
    
            // 修改s2的值
            System.out.println("--------------------------");
            s2.setSname("多里");
            System.out.println(s2);
            System.out.println(s2.getSname());
            System.out.println(s2.getBirthday());
        }
    }
    ```

#### 4.2 深克隆

- 代码

  - 羊

    ```java
    package com.sxt.prototype;
    
    import java.util.Date;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Sheep2.java
     * @time: 2020/2/6 15:53
     * @desc: 测试深复制
     */
    
    public class Sheep2 implements Cloneable{
        private String sname;
        private Date birthday;
    
        public String getSname() {
            return sname;
        }
    
        public void setSname(String sname) {
            this.sname = sname;
        }
    
        public Date getBirthday() {
            return birthday;
        }
    
        public void setBirthday(Date birthday) {
            this.birthday = birthday;
        }
    
        public Sheep2(String sname, Date birthday) {
            this.sname = sname;
            this.birthday = birthday;
        }
    
        public Sheep2() {
        }
    
        @Override
        protected Object clone() throws CloneNotSupportedException {
            // 直接调用object对象的clone()方法
            Object obj = super.clone();
    
            // 添加如下代码实现深复制
            Sheep2 s = (Sheep2) obj;
            // 把属性也进行克隆
            s.birthday = (Date) this.birthday.clone();
    
            return obj;
        }
    }
    ```

  - 客户端同上

- 区别

  - 浅克隆和深克隆的区别

    ![img](https://img-blog.csdnimg.cn/20200206174059713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - 运行结果区别：浅克隆只是复制了生日变量对应的地址，这样即使值改变了，地址相同，则获得的生日的值也相同；深克隆将生日变量复制了一份，两个地址不同，因此原型的值变了，与复制的值无关，因此生日的值依然是之前复制的值。

- 利用序列化和反序列化的技术实现深克隆！

  ```java
  package com.sxt.prototype;
  
  import java.io.ByteArrayInputStream;
  import java.io.ByteArrayOutputStream;
  import java.io.ObjectInputStream;
  import java.io.ObjectOutputStream;
  import java.util.Date;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Client.java
   * @time: 2020/2/6 15:57
   * @desc: 测试原型模式(深复制)，使用序列化和反序列化的方式实现深复制
   */
  
  public class Client3 {
      public static void main(String[] args) throws Exception {
          Date d = new Date(3333333333L);
          Sheep1 s1 = new Sheep1("少理", d);
          System.out.println(s1);
          System.out.println(s1.getSname());
          System.out.println(s1.getBirthday());
  
          // 两个是不同的对象，但是值是一样的！
          // Sheep1 s2 = (Sheep1) s1.clone();
          // 这里用序列化和反序列化实现深复制，所以用的是Sheep1，即浅复制的类
          ByteArrayOutputStream bos = new ByteArrayOutputStream();
          ObjectOutputStream oos = new ObjectOutputStream(bos);
          oos.writeObject(s1);
          byte[] bytes = bos.toByteArray();
  
          ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
          ObjectInputStream ois = new ObjectInputStream(bis);
          Sheep1 s2 = (Sheep1) ois.readObject();
  
          // 修改s1生日
          d.setTime(22222222222L);
          System.out.println("--------------------------");
          System.out.println(s1.getBirthday());
  
          System.out.println(s2);
          System.out.println(s2.getSname());
          System.out.println(s2.getBirthday());
      }
  }
  ```

- 短时间大量创建对象时，原型模式和普通new方式效率测试：**如果需要短时间创建大量对象，并且new的过程比较耗时。则可以考虑使用原型模式！**

- 开发中的应用场景

  - 原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。
  - spring中bean的创建实际就是两种：单例模式和原型模式。（当然原型模式需要和工厂模式搭配起来，即原来是new一个对象，改为clone一个对象）

### 创建型模式总结

- 创建型模式：都是来帮助我们**创建对象**的！

  ![img](https://img-blog.csdnimg.cn/20200206194435516.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 5. 适配器模式

- 结构型模式：
  - 核心作用：是从程序的结构上实现送耦合，从而可以扩大整体的类结构，用来解决更大的问题
  - 分类：适配器模式、代理模式、桥接模式、装饰模式、组合模式、外观模式、享元模式
  
- 什么是适配器模式（adapter）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。

- 模式中的角色：

  - 目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。
  - 需要适配的类（Adaptee）：需要适配的类或适配者类。
  - 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。

- 代码：

  - 被适配的类（没有usb插口的键盘）

    ```java
    package com.sxt.adapter;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Adaptee.java
     * @time: 2020/2/7 11:01
     * @desc: 被适配的类，相当于PS/2键盘
     */
    
    public class Adaptee {
        public void request(){
            System.out.println("可以完成客户请求的需要的功能！");
        }
    }
    ```

  - 客户端（只有usb接口的笔记本电脑）

    ```java
    package com.sxt.adapter;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/7 11:02
     * @desc: 客户类，相当于笔记本，只有USB接口
     */
    
    public class Client {
        public void test1(Target t){
            t.handleReq();
        }
    
        public static void main(String[] args){
            Client c = new Client();
            Adaptee a = new Adaptee();
    
            // 方式1：类适配器方式
            Target t1 = new Adapter();
            // 方式2：对象适配器方式
            Target t2 = new Adapter2(a);
    
            c.test1(t2);
        }
    }
    ```

  - 接口：usb插口

    ```java
    package com.sxt.adapter;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Target.java
     * @time: 2020/2/7 11:02
     * @desc: 相当于USB插口
     */
    
    public interface Target {
        void handleReq();
    }
    ```

#### 5.1 类适配器方式

```java
package com.sxt.adapter;

/**
 * @author: Li Tian
 * @contact: litian_cup@163.com
 * @software: IntelliJ IDEA
 * @file: Adapter.java
 * @time: 2020/2/7 11:03
 * @desc: 【类适配器方式】适配器，相当于把键盘转换成usb接口的转接器
 */

public class Adapter extends Adaptee implements Target{
    // 我的理解：把适配器变成键盘（子类），并实现USB接口-->打字

    @Override
    public void handleReq() {
        super.request();
    }
}
```

#### 5.2 对象适配器方式

```java
package com.sxt.adapter;

/**
 * @author: Li Tian
 * @contact: litian_cup@163.com
 * @software: IntelliJ IDEA
 * @file: Adapter2.java
 * @time: 2020/2/7 11:07
 * @desc: 【对象组合的方式，对象适配器方式】适配器
 */

public class Adapter2 implements Target{
    // 我的理解：把原来不兼容的键盘接口变成Target（即USB接口）

    private Adaptee adaptee;

    @Override
    public void handleReq() {
        adaptee.request();
    }

    public Adapter2(Adaptee adaptee) {
        this.adaptee = adaptee;
    }
}
```

- 工作中的场景：

  - 经常用来做旧系统改造和升级
  - 如果我们的系统开发之后再也不需要维护，那么很多模式都是没必要的，但是不幸的是，事实却是维护一个系统的代价往往是开发一个系统的数倍。

- 我们学习中见过的场景

  - java.io.InputStreamReader(InputStream)
  - java.io.OutputStreamWriter(OutputStream)

- 以对象适配器为例，绘制UML类图

  ![img](https://img-blog.csdnimg.cn/20200207112750273.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 6. 代理模式

- Proxy Pattern
- 核心作用
  - 通过代理，控制对对象的访问
  - 可以详细控制访问某个（某类）对象的方法，在调用这个方法前做前置处理，调用这个方法后做后置处理。（即AOP的微观实现）；从而实现将统一流程代码放到代理类中处理。
  - AOP（Aspect Oriented Programming）：面向切面编程的核心实现机制。
    - 它是可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。它是一种新的方法论，它是对传统OOP编程的一种补充。
    - 常用术语：
      - 切面：Aspect，其实就是共有功能的实现。
      - 通知：Advice，是切面的具体实现。
      - 连接点：Jointpoint，就是程序在运行过程中能够插入切面的地点。
      - 切入点：Pointcut，用于定义通知应该切入到哪些连接点上。
      - 目标对象：Target，就是那些即将切入切面的对象，也就是那些被通知的对象。
      - 代理对象：Proxy，将通知应用到目标对象之后被动态创建的对象。
      - 织入：Weaving，将切面应用到目标对象从而创建一个新的代理对象的过程。
    - 开源的AOP框架：AspectJ
- 核心角色
  - 抽象角色：
    - 定义代理角色和真是角色的公共对外方法
  - 真实角色：
    - 实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。
    - 关注真正的业务逻辑！
  - 代理角色：
    - 实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。
    - 将统一的流程控制放到代理角色中处理。
  - 应用场景：
    - 安全代理：屏蔽对真实角色的直接访问。
    - 远程代理：通过代理类处理远程方法调用（RMI）。
    - 延迟代理：先加载轻量级的代理对象，真正需要再加载真实对象。（比如你要开发一个大文档查看系统，大文档中有大的图片，有可能一个图片有100MB，在打开文件时不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开。）
  - 分类：
    - 静态代理（静态定义代理类）
    - 动态代理（动态生成代理类）
      - JDK自带的动态代理
      - javassist字节码操作库实现
      - CGLIB
      - ASM（底层使用指令，可维护性较差）

#### 6.1 静态代理

- 代码：

  - 明星接口

    ```java
    package com.sxt.proxy.staticproxy;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Star.java
     * @time: 2020/2/7 13:51
     * @desc:
     */
    
    public interface Star {
        // 面谈
        void confer();
        // 签合同
        void signContract();
        // 订票
        void bookTicket();
        // 唱歌
        void sing();
        // 收钱
        void collectMoney();
    }
    ```

  - 真实明星

    ```java
    package com.sxt.proxy.staticproxy;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: RealStar.java
     * @time: 2020/2/7 13:53
     * @desc:
     */
    
    public class RealStar implements Star {
    
        private String name = "真实明星";
        @Override
        public void confer() {
            System.out.println(name + "面谈！");
        }
    
        @Override
        public void signContract() {
            System.out.println(name + "签合同");
        }
    
        @Override
        public void bookTicket() {
            System.out.println(name + "订票");
        }
    
        @Override
        public void sing() {
            System.out.println(name + "唱歌");
        }
    
        @Override
        public void collectMoney() {
            System.out.println(name + "收钱");
        }
    }
    ```

  - 代理经纪人

    ```java
    package com.sxt.proxy.staticproxy;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ProxyStar.java
     * @time: 2020/2/7 13:55
     * @desc:
     */
    
    public class ProxyStar implements Star {
        private String name = "经纪人";
        private Star star;
    
        public ProxyStar(Star star) {
            this.star = star;
        }
    
        @Override
        public void confer() {
            System.out.println(name + "面谈！");
        }
    
        @Override
        public void signContract() {
            System.out.println(name + "签合同");
        }
    
        @Override
        public void bookTicket() {
            System.out.println(name + "订票");
        }
    
        @Override
        public void sing() {
            star.sing();
        }
    
        @Override
        public void collectMoney() {
            System.out.println(name + "收钱");
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.proxy.staticproxy;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/7 13:57
     * @desc:
     */
    
    public class Client {
        public static void main(String[] args){
            Star real = new RealStar();
            Star proxy = new ProxyStar(real);
            proxy.confer();
            proxy.signContract();
            proxy.bookTicket();
            proxy.sing();
            proxy.collectMoney();
        }
    }
    ```

#### 6.2 动态代理

- 动态生成代理类

- 动态代理相比于静态代理的优点：抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样我们可以更加灵活和统一的处理众多的方法。

- JDK自带的动态代理

  - java.lang.reflect.Proxy
    - 作用：动态生成代理类和对象
  - java.lang.reflect.InvocationHandler（处理器接口）
    - 可以通过invoke方法实现对真实角色的代理访问。
    - 每次通过Proxy生成代理类对象时都要指出对应的处理器对象。

- 代码：

  - 明星接口和真实明星接口同上

  - 动态代理类

    ```java
    package com.sxt.proxy.dynamicproxy;
    
    import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: StarHandler.java
     * @time: 2020/2/7 16:19
     * @desc:
     */
    
    public class StarHandler implements InvocationHandler {
    
        Star realStar;
    
        public StarHandler(Star realStar) {
            this.realStar = realStar;
        }
    
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            Object obj = null;
            System.out.println("真正的方法执行前！");
            System.out.println("面谈，签合同等。。。");
            if (method.getName().equals("sing")) {
                obj = method.invoke(realStar, args);
            }
            System.out.println("真正的方法执行后！");
            System.out.println("收钱！");
    
            return obj;
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.proxy.dynamicproxy;
    
    import java.lang.reflect.Proxy;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/7 16:22
     * @desc:
     */
    
    public class Client {
        public static void main(String[] args){
            Star realStar = new RealStar();
            StarHandler handler = new StarHandler(realStar);
    
            Star proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Star.class}, handler);
    
            proxy.sing();
        }
    }
    ```

### 7. 桥接模式


### 21. 观察者模式

- Observer Pattern

- 场景

  - 广播机制
  - 聊天室
  - 新闻订阅
  - CS游戏

- 上面这些场景，我们都可以使用观察者模式处理。我们可以把多个订阅者、客户称之为观察者；需要同步给多个订阅者的数据封装到对象中，称之为目标。

- 核心：

  - 观察者模式主要用于1：N的通知。当一个对象（目标对象Subject或Objservable，消息发布）的状态发生变化时，他需要及时告知一系列对象（观察者对象，Observer，消息订阅），令他们做出响应。
  - 通知观察者的方式
    - 推：每次都会把通知以广播方式发送给所有观察者，所有观察者只能被动接受。
    - 拉：观察者只要知道有情况即可。至于什么时候获取内容，获取什么内容，都可以自主决定。

- UML类图

  ![img](https://img-blog.csdnimg.cn/20200301135853806.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 代码：

  - 消息发布对象

    ```java
    package com.sxt.observer;
    
    import java.util.ArrayList;
    import java.util.List;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Subject.java
     * @time: 2020/3/1 13:36
     * @desc: |
     */
    
    public class Subject {
        protected List<Observer> list = new ArrayList<>();
    
        public void registerObserver(Observer obs) {
            list.add(obs);
        }
    
        public void removeObserver(Observer obs) {
            list.remove(obs);
        }
    
        // 通知所有的观察者更新状态
        public void notifyAllObservers() {
            for (Observer obs : list) {
                obs.update(this);
            }
        }
    }
    ```

  - 消息发布对象的具体实现

    ```java
    package com.sxt.observer;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ConcreteSubject.java
     * @time: 2020/3/1 13:41
     * @desc: |
     */
    
    public class ConcreteSubject extends Subject {
        private int state;
    
        public int getState() {
            return state;
        }
    
        public void setState(int state) {
            this.state = state;
            // 主题对象/目标对象的值发生了变化，请通知所有的观察者
            this.notifyAllObservers();
        }
    }
    ```

  - 观察者接口

    ```java
    package com.sxt.observer;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Observer.java
     * @time: 2020/3/1 13:36
     * @desc: |
     */
    
    public interface Observer {
        void update(Subject subject);
    }
    ```

  - 观察者

    ```java
    package com.sxt.observer;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ObserverA.java
     * @time: 2020/3/1 13:43
     * @desc: |
     */
    
    public class ObserverA implements Observer {
        // myState需要跟目标对象的值保持一致
        private int myState;
    
        public int getMyState() {
            return myState;
        }
    
        public void setMyState(int myState) {
            this.myState = myState;
        }
    
        @Override
        public void update(Subject subject) {
            myState = ((ConcreteSubject)subject).getState();
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.observer;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/3/1 13:45
     * @desc: |
     */
    
    public class Client {
        public static void main(String[] args){
            // 创建目标对象
            ConcreteSubject subject = new ConcreteSubject();
            // 创建多个观察者
            ObserverA obs1 = new ObserverA();
            ObserverA obs3 = new ObserverA();
            ObserverA obs2 = new ObserverA();
    
            // 让这三个观察者添加到subject对象的观察者队伍中
            subject.registerObserver(obs1);
            subject.registerObserver(obs2);
            subject.registerObserver(obs3);
    
            // 改变subject的状态
            subject.setState(3000);
            // 查看观察者的状态
            System.out.println(obs1.getMyState());
            System.out.println(obs2.getMyState());
            System.out.println(obs3.getMyState());
        }
    }
    ```

- JAVASE中提供了java.util.Observable和java.util.Observer来实现观察者模式

  - 目标对象

    ```java
    package com.sxt.observer2;
    
    import java.util.Observable;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ConcreteSubject.java
     * @time: 2020/3/1 14:05
     * @desc: |
     */
    
    public class ConcreteSubject extends Observable {
        private int state;
    
        public int getState() {
            return state;
        }
    
        public void setState(int state) {
            this.state = state;
        }
    
        public void set(int s){
            // 目标对象的状态发生了改变
            state = s;
            // 表示目标对象已经发生了更改
            setChanged();
            // 通知所有的观察者
            notifyObservers(state);
        }
    }
    ```

  - 观察者对象

    ```java
    package com.sxt.observer2;
    
    import java.util.Observable;
    import java.util.Observer;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: ObserverA.java
     * @time: 2020/3/1 14:07
     * @desc: |
     */
    
    public class ObserverA implements Observer {
        private int myState;
    
        public int getMyState() {
            return myState;
        }
    
        public void setMyState(int myState) {
            this.myState = myState;
        }
    
        @Override
        public void update(Observable o, Object arg) {
            myState = ((ConcreteSubject)o).getState();
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.observer2;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/3/1 14:09
     * @desc: |
     */
    
    public class Client {
        public static void main(String[] args){
            // 创建目标对象Observable
            ConcreteSubject subject = new ConcreteSubject();
    
            // 创建观察者
            ObserverA obs1 = new ObserverA();
            ObserverA obs2 = new ObserverA();
            ObserverA obs3 = new ObserverA();
    
            // 将上面三个观察者对象加到目标对象subject的观察者容器中
            subject.addObserver(obs1);
            subject.addObserver(obs2);
            subject.addObserver(obs3);
    
            // 改变subject对象的状态
            subject.set(300);
    
            // 看看观察者的状态发生变化了没
            System.out.println(obs1.getMyState());
            System.out.println(obs2.getMyState());
            System.out.println(obs3.getMyState());
        }
    }
    ```

- 开发中常见的场景

  - 聊天室程序的，服务器转发给所有客户端
  - 网络游戏（多人联机对战）场景中，服务器将客户端的状态进行分发
  - 邮件订阅
  - Servlet中，监听器的实现
  - Android中，广播机制
  - JDK的AWT中事件处理模型，基于观察者模式的委派事件模型（Delegation Event Model）
    - 事件源 --> 目标对象
    - 事件监听器 --> 观察者
  - 京东商城中，群发某商品打折信息

### 22. 备忘录模式

- memento pattern

- 场景：

  - 录入大批人员资料。正在录入当前人资料时，发现上一个人录错了，此时需要恢复上一个人的资料，再进行修改。
  - Word文档编辑时，忽然电脑死机或断电，再打开时，可以看到word提示你恢复到以前的文档。
  - 管理系统中，公文撤回功能。公文发送出去后，想撤回来。

- 核心：就是保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态。

- 结构

  - 源发器类Originator
  - 备忘录类Memento
  - 负责人类CareTaker

- 代码：

  - 源发器类

    ```java
    package com.sxt.memento;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Emp.java
     * @time: 2020/3/1 14:38
     * @desc: |源发器类
     */
    
    public class Emp {
        private String name;
        private int age;
        private double salary;
    
        // 进行备忘操作，并返回备忘录对象
        public EmpMemento memento() {
            return new EmpMemento(this);
        }
    
        // 进行数据恢复，恢复成制定备忘录对象的值
        public void recovery(EmpMemento mmt){
            this.name = mmt.getName();
            this.age = mmt.getAge();
            this.salary = mmt.getSalary();
        }
    
        public Emp(String name, int age, double salary) {
            this.name = name;
            this.age = age;
            this.salary = salary;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public int getAge() {
            return age;
        }
    
        public void setAge(int age) {
            this.age = age;
        }
    
        public double getSalary() {
            return salary;
        }
    
        public void setSalary(double salary) {
            this.salary = salary;
        }
    }
    ```

  - 备忘录类

    ```java
    package com.sxt.memento;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: EmpMemento.java
     * @time: 2020/3/1 14:54
     * @desc: |备忘录类
     */
    
    public class EmpMemento {
        private String name;
        private int age;
        private double salary;
    
        public EmpMemento(Emp e){
            this.name = e.getName();
            this.age = e.getAge();
            this.salary = e.getSalary();
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public int getAge() {
            return age;
        }
    
        public void setAge(int age) {
            this.age = age;
        }
    
        public double getSalary() {
            return salary;
        }
    
        public void setSalary(double salary) {
            this.salary = salary;
        }
    }
    ```

  - 负责人类：管理备忘录对象

    - 负责保存好的备忘录对象
    - 可以通过增加容器，设置多个**备忘点**

    ```java
    package com.sxt.memento;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: CareTaker.java
     * @time: 2020/3/1 14:58
     * @desc: |负责人类：管理备忘录对象
     */
    
    public class CareTaker {
        private EmpMemento memento;
    
        public EmpMemento getMemento() {
            return memento;
        }
    
        public void setMemento(EmpMemento memento) {
            this.memento = memento;
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.memento;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/3/1 14:58
     * @desc: |
     */
    
    public class Client {
        public static void main(String[] args) {
            CareTaker taker = new CareTaker();
            Emp emp = new Emp("李英俊", 18, 900);
            System.out.println("第一次创建对象：" + emp.getName() + emp.getAge() + emp.getSalary());
    
            // 进行一次备份
            taker.setMemento(emp.memento());
    
            emp.setAge(38);
            emp.setName("哈哈");
            emp.setSalary(10);
            System.out.println("第二次创建对象：" + emp.getName() + emp.getAge() + emp.getSalary());
    
            // 恢复到备忘录对象保存的状态
            emp.recovery(taker.getMemento());
            System.out.println("第三次创建对象：" + emp.getName() + emp.getAge() + emp.getSalary());
        }
    }
    ```

- UML类图

  ![img](https://img-blog.csdnimg.cn/20200301150434799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 备忘点较多时

  - 将备忘录压栈
  - 将多个备忘录对象，序列化和持久化

- 开发中常见的应用场景：

  - 棋类游戏中的悔棋操作
  - 普通软件中的，撤销操作
  - 数据库管理软件中的，事务管理中的回滚操作
  - PS中的历史记录

## 第4章 正则表达式

- 文本的复杂处理
- regular expression
- 开发中使用正则表达式的流程：
  - 分析所有匹配的数据，写出测试用的典型数据
  - 在工具软件中进行匹配测试
  - 在程序中调用通过测试的正则表达式
- regexbuddy工具

### 1. 正则表达式语法

- 普通字符：匹配与之相同的一个字符

- 简单的转义字符：

  ![img](https://img-blog.csdnimg.cn/20200302164121481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 标准字符集合

  - 能够与“多种字符”匹配的表达式
  - 注意区分带小写，大写是相反的意思（比如\d是匹配一个数字，\D就是匹配非数字）
  - 小数点不能匹配换行符\n
  - [\s\S]用来匹配任意字符，包括换行符

  ![img](https://img-blog.csdnimg.cn/20200302164341954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 自定义字符集合

  - []方括号匹配方式，能够匹配方括号中任意一个字符

  ![img](https://img-blog.csdnimg.cn/20200302171739602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)
  
  - 正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了^，-之外
  - 标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合将包含该集合。比如：`[\d.\-+]`将匹配：数字、小数点、+、-
  
- 量词 | Quantifier

  - 修饰匹配次数的特殊符号

    ![img](https://img-blog.csdnimg.cn/20200302172135883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

    `\d\d{6} != {\d\d}{6}`

  - 匹配次数中的贪婪模式（匹配字符越多越好，默认！）

  - 匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个“?”号）例：`\d{2,3}?`

- 字符边界（零宽）

  - 本组标记匹配的不是字符而是位置，符合某 种条件的位置

  - \b匹配这样一个位置：前面的字符和后面的字符不全是\w

    ![img](https://img-blog.csdnimg.cn/2020030217462748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - `gaoqi\b`测试：

    ![img](https://img-blog.csdnimg.cn/20200302175434396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

  - `\bgaoqi\b`测试：

    ![img](https://img-blog.csdnimg.cn/20200302175347409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- IGNORECASE：忽略大小写模式

  - 匹配时忽略大小写
  - 默认情况下，正则表达式是要区分大小写的

- SINGLELINE：单行模式

  - 整个文本看作一个字符串，只有一个开头，一个结尾。
  - 使小数点“.”可以匹配包含换行符（\n）在内的任意字符。

- MULTILINE：多行模式

  - 每行都是一个字符串，都有开头和结尾
  - **在制定了MULTILINE之后**，如果需要仅匹配字符串开始和结束位置，可以使用**\A和\Z**
  
- 选择符和分组

  ![img](https://img-blog.csdnimg.cn/20200303132643924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 反向引用(\nnm)

  - 每一对()会分配一个编号，使用()的捕获根据左括号的顺序从1开始自动编号。
  - 通过反向应用，可以对分组已捕获的字符串进行应用。

- 预搜索（零宽断言）

  - 只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度

  - 这个位置应该符合某个条件。判断当前位置的前后字符，是否符合指定的条件，但不匹配前后的字符。是对位置的匹配。

  - 正则表达式匹配过程中，如果子表达式匹配到的是字符的内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是**零宽度**的。占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的。

    ![img](https://img-blog.csdnimg.cn/20200303133858867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 2. 正则表达式的练习

- 练习1

  ![img](https://img-blog.csdnimg.cn/20200303134726764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 解答1：`(0\d{2,3}-\d{7,8})|(1[35789]\d{9})`

- 练习2

  ![img](https://img-blog.csdnimg.cn/20200303135138293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 解答2：`[\w\-]+@[a-z0-9A-Z]+(\.[A-Za-z]{2,4}){1,2}`

### 3. 常用正则表达式列表

![img](https://img-blog.csdnimg.cn/20200303135611213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

### 4. JAVA程序中使用正则表达式

- 开发环境

  - 开发环境和文本编译器中使用正则
  - 数据库中也可以使用正则

- JAVA相关类位于java.util.regex包下面

- 类Pattern：

  - 正则表达式的编译表现形式
  - 建立正则表达式，并启用相应模式
  - `Pattern p = Pattern.compile(r, int);`

- 类Matcher：

  - 通过解释Pattern对character sequence执行匹配操作的引擎
  - 匹配str字符串
  - `Matcher m = p.matcher(str);`

- 测试

  - 匹配整个正则表达式

    ```java
    package com.sxt.regex;
    
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Demo01.java
     * @time: 2020/3/3 14:10
     * @desc: |
     */
    
    public class Demo01 {
        public static void main(String[] args){
            // 在这个字符串：asdfsadf2323，是否符合制定的正则表达式：\w+
            Pattern p = Pattern.compile("\\w+");
            // 创建Matcher对象
            Matcher m = p.matcher("asdfsadf@@2323");
            // 尝试将整个字符序列与该模式匹配
            // boolean yo = m.matches();
            // 该方法扫描输入的序列，查找与该模式匹配的下一个子序列
            while(m.find()){
                // group()和group(0)都是匹配整个表达式的子字符串
                System.out.println(m.group());
                System.out.println(m.group(0));
            }
        }
    }
    ```

  - 测试正则表达式分组的处理

    ```java
    package com.sxt.regex;
    
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @desc: | 测试正则表达式分组的处理
     */
    
    public class Demo02 {
        public static void main(String[] args) {
            // 在这个字符串：asdfsadf2323，是否符合制定的正则表达式：\w+
            Pattern p = Pattern.compile("([a-z]+)([0-9]+)");
            // 创建Matcher对象
            Matcher m = p.matcher("asdfsa12**asd233**dsd11");
            // 尝试将整个字符序列与该模式匹配
            while (m.find()) {
                // group()和group(0)都是匹配整个表达式的子字符串
                System.out.println("start---");
                System.out.println("满足整个表达式的子字符串：");
                System.out.println(m.group());
                System.out.println("满足第1个括号中表达式的字符串：");
                System.out.println(m.group(1));
                System.out.println("满足第2个括号中表达式的字符串：");
                System.out.println(m.group(2));
            }
        }
    }
    ```

  - 测试正则表达对象替换操作

    ```java
    package com.sxt.regex;
    
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @desc: | 测试正则表达对象替换操作
     */
    
    public class Demo03 {
        public static void main(String[] args) {
            // 在这个字符串：asdfsadf2323，是否符合制定的正则表达式：\w+
            Pattern p = Pattern.compile("[0-9]");
            // 创建Matcher对象
            Matcher m = p.matcher("asdfsa12**asd233**dsd11");
    
            // 替换
            String newStr = m.replaceAll("#");
            System.out.println(newStr);
        }
    }
    ```

  - 测试正则表达对象分割字符串的操作

    ```java
    package com.sxt.regex;
    
    import java.util.Arrays;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @desc: | 测试正则表达对象分割字符串的操作
     */
    
    public class Demo04 {
        public static void main(String[] args) {
            String str = "asdfsa12asd233dsd11";
    
            // 切割
            String[] arrs = str.split("\\d+");
            System.out.println(Arrays.toString(arrs));
        }
    }
    ```

### 5. 手写网络爬虫

```java
package com.sxt.regex;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author: Li Tian
 * @contact: litian_cup@163.com
 * @software: IntelliJ IDEA
 * @file: WebSpider.java
 * @time: 2020/3/4 17:29
 * @desc: |网络爬虫取数据
 */

public class WebSpider {
    public static void main(String[] args) {
        String url = "http://www.163.com";
        String destStr = getURLContent(url);

        // 取到的超链接的整个内容
        // Pattern p = Pattern.compile("<a[\\s\\S]+?</a>");
        // 取到的超链接的地址
        // Pattern p = Pattern.compile("href=\"(.+?)\"");
        // 注意：上述?是非贪婪模式
        // Matcher m = p.matcher(destStr);
        // while (m.find()) {
        //     System.out.println(m.group());
        //     System.out.println("-----");
        //     System.out.println(m.group(1));
        // }

        List<String> result = getMatherSubstrs(destStr, "href=\"(http://[\\w\\s./]+?)\"");
        for (String temp : result) {
            System.out.println(temp);
        }
    }

    public static String getURLContent(String loc) {
        /*获得url对应的网页源码内容*/
        StringBuilder sb = new StringBuilder();
        try {
            URL url = new URL(loc);
            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), Charset.forName("gbk")));
            String temp = "";
            while ((temp = reader.readLine()) != null) {
                sb.append(temp);
            }
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return sb.toString();
    }

    public static List<String> getMatherSubstrs(String destStr, String regexStr) {
        // 取到的超链接地址
        Pattern p = Pattern.compile(regexStr);
        Matcher m = p.matcher(destStr);
        List<String> result = new ArrayList<>();
        while (m.find()) {
            result.add(m.group(1));
        }
        return result;
    }
}
```

## 第5章 JDBC

### 1. Mysql引入

- 常用命令行操作

  ![img](https://img-blog.csdnimg.cn/20200304203920329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)


### 2. JDBC简述

- JDBC(Java Database Connection)为java开发者使用数据库提供了统一的编程接口，它由一组java类和接口组成。是java程序与数据库系统通信的标准api。JDBC API使得开发人员可以使用纯java的方式来连接数据库，并执行操作。

- 访问数据库流程

  ![img](https://img-blog.csdnimg.cn/20200305124050720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- Driver接口

  - Driver接口由数据库厂家提供，对于java开发者而言，只需要使用Driver接口就可以了。
  - 在编程中要连接数据库，必须先装载特定厂商的数据库驱动程序。不同的数据库有不同的装载方法。
  - 驱动：就是各个数据库厂商实现的Sun公司提出的JDBC接口。即对Connection等接口的实现类的jar文件。
  - 装载MySQL驱动
    - `Class.forName("com.mysql.jdbc.Driver");`
  - 装载Oracle驱动
    - `Class.forName("oracle.jdbc.driver.OracleDriver")`

- DriverManager接口

  - DriverManager是JDBC的管理层，作用于用户和驱动程序之间。
  - DriverManager跟踪可用的驱动程序，并在数据库和相应的驱动程序之间建立连接。

- Connection接口

  - Connection与特定数据库的连接（会话），在连接上下文中执行SQL语句并返回结果。
  - DriverManager的getConnection()方法建立在JDBC URL中定义的数据库Connection连接上。
  - 连接Mysql数据：
    - `Connection con = DriverManager.getConnection("jdbc:mysql://host:port/database", "user", "password");`
  - 连接Oracle数据库：
    - `Connection con = DriverManager.gtConnection("jdbc:oracle:thin:@host:port:database", "user", "password");`

- JDBC详细操作

  - 灵活指定SQL语句中的变量：PreparedStatement
  - 对存储过程进行调用：CallableStatement
  - 运用事务处理：Transaction
  - 批处理：Batch，对于大量的批处理，建议使用Statement，因为PreparedStatement的预编译空间有限，当数据量特别大时，会发生异常。

- 连接测试

- 报错参考连接：[解决方案](https://www.cnblogs.com/cn-chy-com/p/10145690.html)

  ```java
  package com.sxt.jdbc;
  
  import java.sql.Connection;
  import java.sql.DriverManager;
  import java.sql.SQLException;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Demo01.java
   * @time: 2020/3/5 12:48
   * @desc: | 测试跟数据库建立连接
   * 如果报错：参考连接：https://www.cnblogs.com/cn-chy-com/p/10145690.html
   */
  
  public class Demo01 {
      public static void main(String[] args) {
          try {
              // 加载驱动类
              Class.forName("com.mysql.cj.jdbc.Driver");
              long start = System.currentTimeMillis();
              // 建立连接（连接对象内部其实包含了Socket对象，是一个远程的连接。比较耗时！这是Connection对象管理的一个要点！）
              // 真正开发中，为了提高效率，都会使用连接池来管理连接对象！
              Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/testjdbc?serverTimezone=UTC", "root", "123456");
              long end = System.currentTimeMillis();
              System.out.println(conn);
              System.out.println("建立连接耗时：" + (end - start) + "ms毫秒");
  
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
          }
      }
  }
  ```

### 3. JDBC常用接口

- Statement接口

  - 用于执行静态SQL语句并返回它所生成结果的对象。
  - 三种Statement类：
    - Statement：由createStatement创建，用于发送简单的SQL语句。（不带参数的）
    - PreparedStatement：继承自Statement接口，由prepareStatement创建，用于发送含有一个或多个输入参数的sql语句。PreparedStatement对象比Statement对象的效率更高，并且可以**防止SQL注入**。我们**一般都用PreparedStatement**。
    - CallableStatement：集成自PreparedStatement。由方法prePareCall创建，用于调用存储过程。
  - 常用的Statement方法：
    - execute()：运行语句，返回是否有结果集。
    - executeQuery()：运行select语句，返回ResultSet结果集。
    - executeUpadate()：运行insert/update/delete操作，返回更新的行数。

- Statement测试执行sql语句以及sql注入问题

  ```java
  package com.sxt.jdbc;
  
  import java.sql.Connection;
  import java.sql.DriverManager;
  import java.sql.SQLException;
  import java.sql.Statement;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Demo02.java
   * @time: 2020/3/5 12:48
   * @desc: | 测试执行sql语句以及sql注入问题
   */
  
  public class Demo02 {
      public static void main(String[] args) {
          try {
              // 加载驱动类
              Class.forName("com.mysql.cj.jdbc.Driver");
              // 建立连接（连接对象内部其实包含了Socket对象，是一个远程的连接。比较耗时！这是Connection对象管理的一个要点！）
              // 真正开发中，为了提高效率，都会使用连接池来管理连接对象！
              Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/testjdbc?serverTimezone=UTC", "root", "123456");
              Statement stmt = conn.createStatement();
              String sql = "insert into t_user (username, pwd, regTime) values ('赵六', 6666, now())";
              stmt.execute(sql);
  
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
          }
      }
  }
  ```
  
- sql注入问题：若要根据id删除一行记录，很容易出现数据库危险，比如要删除id=5的记录，传入的时候为`id = 5 or 1 = 1`，最终导致数据库都被删除。

- 测试PreparedStatement的用法

  ```java
  package com.sxt.jdbc;
  
  import java.sql.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Demo01.java
   * @time: 2020/3/5 12:48
   * @desc: | 测试PreparedStatement的基本用法
   */
  
  public class Demo03 {
      public static void main(String[] args) {
          try {
              // 加载驱动类
              Class.forName("com.mysql.cj.jdbc.Driver");
              Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/testjdbc?serverTimezone=UTC", "root", "123456");
  
              // ?是占位符
              String sql = "insert into t_user (username, pwd, regTime) values (?, ?, ?)";
              PreparedStatement ps = conn.prepareStatement(sql);
              // 参数索引是从1开始计算，而不是0
              // ps.setString(1, "傻瓜");
              // ps.setString(2, "12345");
  
              // 还可以不管类型直接setObject
              // ps.setObject(1, "傻瓜2");
              // ps.setObject(2, "12344");
  
              // 设置时间：注意该时间的格式应该是java.sql.Date
              ps.setObject(1, "傻瓜3");
              ps.setObject(2, "12343");
              ps.setObject(3, new java.sql.Date(System.currentTimeMillis()));
  
              System.out.println("插入一行记录");
              // 返回是否有结果集
              // ps.execute();
              // 返回更新的行数
              int count = ps.executeUpdate();
              System.out.println(count);
  
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
          }
      }
  }
  ```

- 关闭顺序：resultset-->statement-->connection

- 测试ResultSet结果集的用法

  ```java
  package com.sxt.jdbc;
  
  import java.sql.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @desc: | 测试ResultSet结果集的用法
   * 记得要关闭打开的接口
   */
  
  public class Demo04 {
      public static void main(String[] args) {
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
          try {
              // 加载驱动类
              Class.forName("com.mysql.cj.jdbc.Driver");
              conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/testjdbc?serverTimezone=UTC", "root", "123456");
  
              // ?是占位符
              String sql = "select id, username, pwd from t_user where id>?";
              ps = conn.prepareStatement(sql);
              // 把id>2的记录都取出来
              ps.setObject(1, 2);
              rs = ps.executeQuery();
  
              while (rs.next()) {
                  // 数字代表哪一列
                  System.out.println(rs.getInt(1) + "-->" + rs.getString(2) + "-->" + rs.getString(3));
              }
  
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
          } finally {
              // 一定要将三个try catch分开写
              if (rs != null) {
                  try {
                      rs.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
              if (ps != null) {
                  try {
                      ps.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
              if (conn != null) {
                  try {
                      conn.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
          }
      }
  }
  ```

- Batch批处理，尽量使用Statement而不是PreparedStatement

  ```java
  package com.sxt.jdbc;
  
  import java.sql.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @desc: | 批处理
   */
  
  public class Demo05 {
      public static void main(String[] args) {
          Connection conn = null;
          Statement stmt = null;
          ResultSet rs = null;
          try {
              // 加载驱动类
              Class.forName("com.mysql.cj.jdbc.Driver");
              conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/testjdbc?serverTimezone=UTC", "root", "123456");
              // 设为手动提交
              conn.setAutoCommit(false);
              long start = System.currentTimeMillis();
              stmt = conn.createStatement();
              for (int i = 0; i < 20000; i++) {
                  stmt.addBatch("insert into t_user (username, pwd, regTime) values ('li'" + ", 666666, now())");
                  stmt.executeBatch();
              }
              // 提交事务
              conn.commit();
              long  end = System.currentTimeMillis();
              System.out.println("插入20000条数据，耗时（毫秒）：" + (end - start));
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
          } finally {
              // 一定要将三个try catch分开写
              if (rs != null) {
                  try {
                      rs.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
              if (stmt != null) {
                  try {
                      stmt.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
              if (conn != null) {
                  try {
                      conn.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
          }
      }
  }
  ```

### 4. 事务

- 事务的基本概念：一组要么同时执行成功，要么同时执行失败的SQL语句。是数据库操作的一个执行单元。

- 事务开始于：

  - 连接到数据库上，并执行一条DML语句（INSERT、UPDATE或DELETE）
  - 前一个事务结束后，又输入了另外一条DML语句

- 事务结束于：

  - 执行COMMIT或ROLLBACK语句
  - 执行一条DDL语句，如CREATE TABLE语句；这种情况下，会自动执行COMMIT语句
  - 执行一条DCL语句，例如GRANT语句；这种情况下，会自动执行COMMIT语句
  - 断开与数据库的连接
  - 执行了一条DML语句，该语句却失败了；在这种情况下，会为这个无效的DML语句执行ROLLBACK语句

- 事务的四大特性（ACID）

  - atomicity（原子性）：表示一个事务内的所有操作是一个整体，要么全部成功，要么全部失败
  - consistency（一致性）：表示一个事务内有一个操作失败时，所有的更改过的数据都必须回滚到修改前的状态
  - isolation（隔离性）：事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。
    - 事务隔离级别从低到高：
      - 读取未提交（Read Uncommitted）
      - 读取已提交（Read Committed）
      - 可重复读（Repeatable Read）
      - 序列化（Serializable）
  - durability（持久性）：持久性事务完成之后，它对系统的影响是永久的

- 测试事务的基本用法

  ```java
  package com.sxt.jdbc;
  
  import java.sql.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @desc: | 测试事务的基本用法
   */
  
  public class Demo06 {
      public static void main(String[] args) {
          Connection conn = null;
          PreparedStatement ps1 = null;
          PreparedStatement ps2 = null;
          try {
              // 加载驱动类
              Class.forName("com.mysql.cj.jdbc.Driver");
              conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/testjdbc?serverTimezone=UTC", "root", "123456");
  
              // JDBC默认是自动提交
              conn.setAutoCommit(false);
  
              ps1 = conn.prepareStatement("insert into t_user (username, pwd) values (?, ?)");
              ps1.setObject(1, "狗子");
              ps1.setObject(2, "111");
              ps1.execute();
              System.out.println("插入一个用户1");
              Thread.sleep(6000);
  
              ps2 = conn.prepareStatement("insert into t_user (username, pwd) values (?, ?, ?)");
              ps2.setObject(1, "狗子2");
              ps2.setObject(2, "111");
              ps2.execute();
              System.out.println("插入一个用户2");
  
              conn.commit();
  
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
              try {
                  conn.rollback();
              } catch (SQLException ex) {
                  ex.printStackTrace();
              }
          } catch (InterruptedException e) {
              e.printStackTrace();
          } finally {
              // 一定要将三个try catch分开写
              if (ps1 != null) {
                  try {
                      ps1.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
              if (ps2 != null) {
                  try {
                      ps2.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
              if (conn != null) {
                  try {
                      conn.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
          }
      }
  }
  ```

### 5. 时间处理

- 时间类型

  - java.util.Date
    - 子类：java.sql.Date：表示年月日
    - 子类：java.sql.Time：表示时分秒
    - 子类：java.sql.Timestamp：表示年月日时分秒
  - 日期比较处理
    - 插入随机日期
    - 取出指定日期范围的记录

- Date、Timestamp比较和插入随机日期

  ```java
  package com.sxt.jdbc;
  
  import java.sql.Connection;
  import java.sql.DriverManager;
  import java.sql.PreparedStatement;
  import java.sql.SQLException;
  import java.util.Random;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @desc: | 测试时间处理（java.sql.Date, java.sql.Time, java.sql.Timestamp）
   */
  
  public class Demo07 {
      public static void main(String[] args) {
          Connection conn = null;
          PreparedStatement ps1 = null;
          try {
              // 加载驱动类
              Class.forName("com.mysql.cj.jdbc.Driver");
              conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/testjdbc?serverTimezone=UTC", "root", "123456");
  
              for (int i = 0; i < 1000; i++) {
                  ps1 = conn.prepareStatement("insert into t_user (username, pwd, regTime, lastLoginTime) values (?, ?, ?, ?)");
                  ps1.setObject(1, "狗子" + i);
                  ps1.setObject(2, "111");
  
                  // 定义随机数
                  int rand = 10000000 + new Random().nextInt(1000000000);
  
                  java.sql.Date date = new java.sql.Date(System.currentTimeMillis() - rand);
                  ps1.setDate(3, date);
  
                  // 如果需要插入制定日期，可以使用Calendar或DateFormat
                  java.sql.Timestamp stamp = new java.sql.Timestamp(System.currentTimeMillis());
                  ps1.setTimestamp(4, stamp);
  
                  ps1.execute();
              }
  
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
              try {
                  conn.rollback();
              } catch (SQLException ex) {
                  ex.printStackTrace();
              }
          } finally {
              // 一定要将三个try catch分开写
              if (ps1 != null) {
                  try {
                      ps1.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
              if (conn != null) {
                  try {
                      conn.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
          }
      }
  }
  ```

- 取出指定日期范围的记录

  ```java
  package com.sxt.jdbc;
  
  import java.sql.*;
  import java.text.DateFormat;
  import java.text.ParseException;
  import java.text.SimpleDateFormat;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @desc: | 测试时间处理，取出指定时间段的数据
   */
  
  public class Demo08 {
      public static void main(String[] args) {
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
          try {
              // 加载驱动类
              Class.forName("com.mysql.cj.jdbc.Driver");
              conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/testjdbc?serverTimezone=UTC", "root", "123456");
  
              // 选择满足regTime条件的记录，Timestamp格式同理，把java.sql.Date改成java.sql.Timestamp即可getDate改成getTimestamp
              ps = conn.prepareStatement("select * from t_user where regTime>? and regTime<?");
              java.sql.Date start = new java.sql.Date(str2Date("2020-3-1 10:23:45"));
              java.sql.Date end = new java.sql.Date(str2Date("2020-3-3 10:23:45"));
              ps.setObject(1, start);
              ps.setObject(2, end);
              rs = ps.executeQuery();
              while(rs.next()){
                  System.out.println(rs.getInt("id") + "-->" + rs.getString("username") + "-->" + rs.getDate("regTime"));
              }
  
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
              try {
                  conn.rollback();
              } catch (SQLException ex) {
                  ex.printStackTrace();
              }
          } finally {
              // 一定要将三个try catch分开写
              if (rs != null) {
                  try {
                      rs.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
              if (ps != null) {
                  try {
                      ps.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
              if (conn != null) {
                  try {
                      conn.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
          }
      }
  
      public static long str2Date(String dateStr){
          /*将字符串代表的日期转为long数字（格式：yyyy-MM-dd hh:mm:ss）*/
          DateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
          try {
              return format.parse(dateStr).getTime();
          } catch (ParseException e) {
              e.printStackTrace();
              return 0;
          }
      }
  }
  ```

### 6. 大对象操作

#### 6.1 CLOB文本大对象操作

- Character Large Object

- 用于存储大量的文本数据

- 大字段有些特殊，不同数据库处理的方式不一样，大字段的操作常常是以**流的方式**来处理的。而非一般的字段，一次即可读出数据。

- Mysql中相关类型：

  - TINYTEXT最大长度为255(2^[8]-1)字符的TEXT列。
  - TEXT[(M)]最大长度为65535(2^[16]-1)字符的TEXT列。
  - MEDIUMTEXT最大长度为16777215(2^[24]-1)字符的TEXT列。
  - LONGTEXT最大长度为4294967295或4GB(2^[32]-1)字符的TEXT列。

- 测试CLOB文本大对象的使用

- 包含：将字符串、文件内容插入数据库中的CLOB字段，将CLOB字段值取出来操作

  ```java
  package com.sxt.jdbc;
  
  import java.io.*;
  import java.sql.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @desc: | 测试CLOB文本大对象的使用
   * 包含：将字符串、文件内容插入数据库中的CLOB字段，将CLOB字段值取出来操作
   */
  
  public class Demo09 {
      public static void main(String[] args) {
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
          try {
              // 加载驱动类
              Class.forName("com.mysql.cj.jdbc.Driver");
              conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/testjdbc?serverTimezone=UTC", "root", "123456");
  
              ps = conn.prepareStatement("insert into t_user2 (username, myInfo) values (?, ?)");
              ps.setString(1, "狗子");
              // 将文本文件的内容直接输入到数据库中
              // ps.setClob(2, new FileReader(new File("a1.txt")));
              // 通过流的操作写入字符串内容
              // ps.setClob(2, new BufferedReader(new InputStreamReader(new ByteArrayInputStream("aaaabbbb".getBytes()))));
              // ps.executeUpdate();
  
              // 读取Clob字段
              ps = conn.prepareStatement("select * from t_user2 where username=?");
              ps.setObject(1, "狗子");
              rs = ps.executeQuery();
              while (rs.next()) {
                  Clob c = rs.getClob("myInfo");
                  Reader r = c.getCharacterStream();
                  int temp = 0;
                  while((temp = r.read()) != -1){
                      System.out.print((char)temp);
                  }
                  System.out.println();
              }
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
              try {
                  conn.rollback();
              } catch (SQLException ex) {
                  ex.printStackTrace();
              }
          } catch (IOException e) {
              e.printStackTrace();
          } finally {
              // 一定要将三个try catch分开写
              if (rs != null) {
                  try {
                      rs.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
              if (ps != null) {
                  try {
                      ps.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
              if (conn != null) {
                  try {
                      conn.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
          }
      }
  }
  ```

#### 6.2 BLOB二进制大对象操作

- Binary Large Object

- 用于存储大量的二进制数据

- 大字段有些特殊，不同数据库处理的方式不一样，大字段的操作常常是以流的方式来处理的。而非一般的字段，一次即可独处数据。

- Mysql中相关类型与CLOB类似，只是将CLOB改为BLOB

- 测试BLOB二进制大对象的使用

  ```java
  package com.sxt.jdbc;
  
  import java.io.*;
  import java.sql.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @desc: | 测试BLOB二进制大对象的使用
   */
  
  public class Demo10 {
      public static void main(String[] args) {
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
          try {
              // 加载驱动类
              Class.forName("com.mysql.cj.jdbc.Driver");
              conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/testjdbc?serverTimezone=UTC", "root", "123456");
  
              // ps = conn.prepareStatement("insert into t_user2 (username, headImg) values (?, ?)");
              // ps.setString(1, "狗子2");
              // 将图片文件的内容直接输入到数据库中
              // ps.setBlob(2, new FileInputStream("test.png"));
              // ps.executeUpdate();
  
              // 读取Blob字段
              ps = conn.prepareStatement("select * from t_user2 where username=?");
              ps.setObject(1, "狗子2");
              rs = ps.executeQuery();
              while (rs.next()) {
                  Blob b = rs.getBlob("headImg");
                  InputStream is = b.getBinaryStream();
                  OutputStream os = new FileOutputStream("a1_input.png");
                  int temp = 0;
                  while((temp = is.read()) != -1){
                      os.write(temp);
                  }
              }
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
              try {
                  conn.rollback();
              } catch (SQLException ex) {
                  ex.printStackTrace();
              }
          } catch (IOException e) {
              e.printStackTrace();
          } finally {
              // 一定要将三个try catch分开写
              if (rs != null) {
                  try {
                      rs.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
              if (ps != null) {
                  try {
                      ps.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
              if (conn != null) {
                  try {
                      conn.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }
              }
          }
      }
  }
  ```

### 7. 经典JDBC代码总结

- JDBC工具类

- 包括返回数据库驱动连接，关闭各个接口

  ```java
  package com.sxt.jdbc;
  
  import java.io.IOException;
  import java.sql.*;
  import java.util.Properties;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: JDBCUTIL.java
   * @time: 2020/3/8 19:43
   * @desc: |JDBC工具类
   */
  
  public class JDBCUtil {
      // 可以帮助我们读取和处理资源文件中的信息
      private static Properties pros = null;
      static {
          /*静态代码块：只有在加载JDBCUtil类的时候调用一次*/
          pros = new Properties();
          try {
              pros.load(Thread.currentThread().getContextClassLoader().getResourceAsStream("com/sxt/jdbc/db.properties"));
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  
      public static Connection getMysqlConn() {
          /*获取数据库(mysql)驱动连接*/
          // 加载驱动类
          try {
              Class.forName(pros.getProperty("mysqlDriver"));
              return DriverManager.getConnection(
                      pros.getProperty("mysqlURL"),
                      pros.getProperty("mysqlUser"),
                      pros.getProperty("mysqlPwd"));
          } catch (Exception e) {
              e.printStackTrace();
              return null;
          }
      }
  
      public static Connection getOracleConn() {
          /*获取数据库(oracle)驱动连接*/
          // 加载驱动类
          try {
              Class.forName(pros.getProperty("oracleDriver"));
              return DriverManager.getConnection(
                      pros.getProperty("oracleURL"),
                      pros.getProperty("oracleUser"),
                      pros.getProperty("oraclePwd"));
          } catch (Exception e) {
              e.printStackTrace();
              return null;
          }
      }
  
      public static void close(ResultSet rs, Statement ps, Connection conn){
          /*关闭接口方法*/
          try {
              if (rs != null){
                  rs.close();
              }
          } catch (Exception e) {
              e.printStackTrace();
          }
          try {
              if (ps != null){
                  ps.close();
              }
          } catch (Exception e) {
              e.printStackTrace();
          }
          try {
              if (conn != null){
                  conn.close();
              }
          } catch (Exception e) {
              e.printStackTrace();
          }
      }
  
      public static void close(Statement ps, Connection conn){
          /*关闭接口方法，重载*/
          try {
              if (ps != null){
                  ps.close();
              }
          } catch (Exception e) {
              e.printStackTrace();
          }
          try {
              if (conn != null){
                  conn.close();
              }
          } catch (Exception e) {
              e.printStackTrace();
          }
      }
  
      public static void close(Connection conn){
          /*关闭接口方法，重载*/
          try {
              if (conn != null){
                  conn.close();
              }
          } catch (Exception e) {
              e.printStackTrace();
          }
      }
  }
  ```

- 配置文件封装

  ```properties
  mysqlURL=jdbc:mysql://localhost:3306/testjdbc?serverTimezone=UTC
  #mysqlURL=jdbc:mysql://localhost:3306/sorm?serverTimezone=UTC
  mysqlDriver=com.mysql.cj.jdbc.Driver
  mysqlUser=root
  mysqlPwd=123456
  
  oracleDriver=oracle.jdbc.driver.OracleDriver
  oracleURL=jdbc:oracle:thin:@localhost:1521:database
  oracleUser=scott
  oraclePwd=tiger
  ```

- 测试使用JDBCUtil工具类来简化JDBC开发

  ```java
  package com.sxt.jdbc;
  
  import java.sql.*;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @desc: | 测试使用JDBCUtil工具类来简化JDBC开发
   */
  
  public class Demo11 {
      public static void main(String[] args) {
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
  
          try {
              conn = JDBCUtil.getMysqlConn();
              ps = conn.prepareStatement("insert into t_user (username) values (?)");
              ps.setString(1, "hehe");
              ps.execute();
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
              JDBCUtil.close(rs, ps, conn);
          }
      }
  }
  ```

### 8. ORM原理

- ORM的基本思想

  - Object Relationship Mapping：对象关系映射
  - 表结构跟类对应；表中字段和类的属性对应；表中记录和对象对应。
  - 让javabean的属性名和类型尽量和数据库保持一致！
  - 一条记录对应一个对象。将这些查询到的对象放到容器中（List，Set，Map）

- 将表中的一条记录封装到Object数组中

- 将表中的一条记录封装到map中

- 将表中的一条记录封装到javabean对象中

- 测试使用Object数组来封装一条记录，使用List<Object[]>存储多条记录

  ```java
  package com.sxt.testORM;
  
  import com.sxt.jdbc.JDBCUtil;
  
  import java.sql.Connection;
  import java.sql.PreparedStatement;
  import java.sql.ResultSet;
  import java.sql.SQLException;
  import java.util.ArrayList;
  import java.util.List;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @file: Demo01.java
   * @time: 2020/3/10 13:29
   * @desc: |测试使用Object数组来封装一条记录
   * 使用List<Object[]>存储多条记录
   */
  
  public class Demo01 {
      public static void main(String[] args) {
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
          List<Object[]> list = new ArrayList<>();
          try {
              conn = JDBCUtil.getMysqlConn();
              ps = conn.prepareStatement("select empname, salary, age from emp where id > ?");
              ps.setObject(1, 0);
              rs = ps.executeQuery();
              while (rs.next()) {
                  // System.out.println(rs.getString(1) + "-->" + rs.getDouble(2) + "-->" + rs.getInt(3));
                  Object[] objs = new Object[3];
                  objs[0] = rs.getObject(1);
                  objs[1] = rs.getObject(2);
                  objs[2] = rs.getObject(3);
  
                  list.add(objs);
              }
  
          } catch (SQLException e) {
              e.printStackTrace();
          } finally {
              JDBCUtil.close(rs, ps, conn);
          }
  
          for (Object[] objs : list) {
              System.out.println(objs[0] + "-->" + objs[1] + "-->" + objs[2]);
          }
      }
  }
  ```

- 测试使用Map来封装一条记录，使用`List<Map>`存储多条记录（也可用`Map<Map>`）

  ```java
  package com.sxt.testORM;
  
  import com.sxt.jdbc.JDBCUtil;
  
  import java.sql.Connection;
  import java.sql.PreparedStatement;
  import java.sql.ResultSet;
  import java.sql.SQLException;
  import java.util.ArrayList;
  import java.util.HashMap;
  import java.util.List;
  import java.util.Map;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @desc: |测试使用Map来封装一条记录
   * 使用List<Map>存储多条记录（也可用Map<Map>）
   */
  
  public class Demo02 {
      public static void main(String[] args) {
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
          // 使用一个Map封装一条记录
          List<Map<String, Object>> list = new ArrayList<>();
          try {
              conn = JDBCUtil.getMysqlConn();
              ps = conn.prepareStatement("select empname, salary, age from emp where id > ?");
              ps.setObject(1, 0);
              rs = ps.executeQuery();
              while (rs.next()) {
                  // System.out.println(rs.getString(1) + "-->" + rs.getDouble(2) + "-->" + rs.getInt(3));
                  Map<String, Object> row = new HashMap<>();
                  row.put("empname", rs.getString(1));
                  row.put("salary", rs.getString(2));
                  row.put("age", rs.getString(3));
                  list.add(row);
              }
  
          } catch (SQLException e) {
              e.printStackTrace();
          } finally {
              JDBCUtil.close(rs, ps, conn);
          }
  
          // 遍历List和Map
          for (Map<String, Object> row : list) {
              for (String key : row.keySet()) {
                  System.out.print(key + "-->" + row.get(key) + "\t\t");
              }
              System.out.println();
          }
      }
  }
  ```

- 使用Javabean对象来封装一条记录，使用`List<Javabean>`存储多条记录

  ```java
  package com.sxt.testORM;
  
  import com.sxt.jdbc.JDBCUtil;
  
  import java.sql.Connection;
  import java.sql.PreparedStatement;
  import java.sql.ResultSet;
  import java.sql.SQLException;
  import java.util.ArrayList;
  import java.util.List;
  
  /**
   * @author: Li Tian
   * @contact: litian_cup@163.com
   * @software: IntelliJ IDEA
   * @desc: |使用Javabean对象来封装一条记录
   * 使用List<Javabean>存储多条记录
   */
  
  public class Demo03 {
      public static void main(String[] args) {
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
          List<Emp> list = new ArrayList<>();
          try {
              conn = JDBCUtil.getMysqlConn();
              ps = conn.prepareStatement("select empname, salary, age from emp where id > ?");
              ps.setObject(1, 0);
              rs = ps.executeQuery();
              while (rs.next()) {
                  // System.out.println(rs.getString(1) + "-->" + rs.getDouble(2) + "-->" + rs.getInt(3));
                  Emp emp = new Emp(rs.getString(1), rs.getInt(2), rs.getDouble(3));
                  list.add(emp);
              }
  
          } catch (SQLException e) {
              e.printStackTrace();
          } finally {
              JDBCUtil.close(rs, ps, conn);
          }
  
          for (Emp e: list) {
              System.out.println(e);
          }
      }
  }
  ```

- 其中需要为每一个表定义相同结构的类

  - Emp

    ```java
    package com.sxt.testORM;
    
    import java.sql.Date;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Emp.java
     * @time: 2020/3/10 14:35
     * @desc: |表结构和类对应
     */
    
    public class Emp {
        private Integer id;
        private String empname;
        private Integer age;
        private Double salary;
        private Date birthday;
        private Integer deptId;
    
        public Emp(String empname, Integer age, Double salary) {
            this.empname = empname;
            this.age = age;
            this.salary = salary;
        }
    
        public Integer getId() {
            return id;
        }
    
        public void setId(Integer id) {
            this.id = id;
        }
    
        public String getEmpname() {
            return empname;
        }
    
        public void setEmpname(String empname) {
            this.empname = empname;
        }
    
        public Integer getAge() {
            return age;
        }
    
        public void setAge(Integer age) {
            this.age = age;
        }
    
        public Double getSalary() {
            return salary;
        }
    
        public void setSalary(Double salary) {
            this.salary = salary;
        }
    
        public Date getBirthday() {
            return birthday;
        }
    
        public void setBirthday(Date birthday) {
            this.birthday = birthday;
        }
    
        public Integer getDeptId() {
            return deptId;
        }
    
        public void setDeptId(Integer deptId) {
            this.deptId = deptId;
        }
    
        public Emp(String empname, Integer age, Double salary, Date birthday, Integer deptId) {
            this.empname = empname;
            this.age = age;
            this.salary = salary;
            this.birthday = birthday;
            this.deptId = deptId;
        }
    
        public Emp(Integer id, String empname, Integer age, Double salary, Date birthday, Integer deptId) {
            this.id = id;
            this.empname = empname;
            this.age = age;
            this.salary = salary;
            this.birthday = birthday;
            this.deptId = deptId;
        }
    
        public Emp() {
        }
    
        @Override
        public String toString() {
            return empname + "-->" + age + "-->" + salary;
        }
    }
    ```

  - Dept

    ```java
    package com.sxt.testORM;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Dept.java
     * @time: 2020/3/10 14:38
     * @desc: |
     */
    
    public class Dept {
        private Integer id;
        private String dname;
        private String address;
    
        public Dept() {
        }
    
        public Dept(String dname, String address) {
            this.dname = dname;
            this.address = address;
        }
    
        public Dept(Integer id, String dname, String address) {
            this.id = id;
            this.dname = dname;
            this.address = address;
        }
    
        public Integer getId() {
            return id;
        }
    
        public void setId(Integer id) {
            this.id = id;
        }
    
        public String getDname() {
            return dname;
        }
    
        public void setDname(String dname) {
            this.dname = dname;
        }
    
        public String getAddress() {
            return address;
        }
    
        public void setAddress(String address) {
            this.address = address;
        }
    }
    ```

### 9. 手写SORM框架
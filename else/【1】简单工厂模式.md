### 2. 工厂模式（3种）

- 实现了创建者和调用者的分离
- 详细分类：
  - **简单工厂模式**：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）
  - **简单方法模式**：用来生产同一等级结构中的固定产品。（支持增加任意产品）
  - **抽象工厂模式**：用来生产不同产品族的全部产品。（对于增加的新产品，无能为力，支持增加产品族）
- 面向对象设计基本原则：
  - OCP（开闭原则，Open-Closed Principle）：一个软件的实体应当对扩展开放，对修改关闭
  - DIP（依赖倒转原则，Dependence Inversion Principle）：要针对接口编程，不要针对实现编程
  - LoD（迪米特法则，Law of Demeter）：只与你直接的朋友通信，而避免和陌生人通信
- 核心本质：
  - 实例化对象，用工厂方法代替new操作
  - 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。

#### 2.1 简单工厂模式

- 要点：

  - 简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法，通过接受的参数的不同来返回不同的对象实例。
  - 对于增加新产品无能为力！不修改代码的话，是无法扩展的。

- 代码：

  - Car接口

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Car.java
     * @time: 2020/2/5 15:59
     * @desc:
     */
    
    public interface Car {
        void run();
    }
    ```

  - 奥迪车

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Audi.java
     * @time: 2020/2/5 16:00
     * @desc:
     */
    
    public class Audi implements Car {
        @Override
        public void run() {
            System.out.println("奥迪在跑！");
        }
    }
    ```

  - 比亚迪车

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Byd.java
     * @time: 2020/2/5 16:01
     * @desc:
     */
    
    public class Byd implements Car {
        @Override
        public void run() {
            System.out.println("比亚迪在跑！");
        }
    }
    ```

  - 测试在没有工厂模式的情况下

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client01.java
     * @time: 2020/2/5 16:02
     * @desc: 测试在没有工厂模式的情况下
     */
    
    public class Client01 { // 调用者
        public static void main(String[] args){
            Car c1 = new Audi();
            Car c2 = new Byd();
            c1.run();
            c2.run();
        }
    }
    ```

  - 简单工厂类1

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: CarFactory.java
     * @time: 2020/2/5 16:04
     * @desc:
     */
    
    public class CarFactory {
        public static Car createCar(String type){
            if("奥迪".equals(type)){
                return new Audi();
            }else if("比亚迪".equals(type)){
                return new Byd();
            }else{
                // 简单工厂还是有点小问题的，这里如果要加新的车辆的话，就需要改代码，违反了开闭原则OCP
                return null;
            }
        }
    }
    ```

  - 简单工厂2

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: CarFactory.java
     * @time: 2020/2/5 16:04
     * @desc: 简单工厂类2
     */
    
    public class CarFactory2 {
        public static Car createAudi() {
            return new Audi();
        }
    
        public static Car createByd() {
            return new Byd();
        }
    }
    ```

  - 测试在简单工厂模式的情况下

    ```java
    package com.sxt.factory.simplefactor;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client01.java
     * @time: 2020/2/5 16:02
     * @desc: 测试在简单工厂模式的情况下
     */
    
    public class Client02 { // 调用者
        public static void main(String[] args){
            Car c1 = CarFactory.createCar("奥迪");
            Car c2 = CarFactory.createCar("比亚迪");
            c1.run();
            c2.run();
        }
    }
    ```

- UML类图

  ![img](https://img-blog.csdnimg.cn/20200205162526807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

#### 2.2 工厂方法模式

- 为了避免简单工厂模式的缺点，不完全满足OCP。

- 工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。

- 代码：

  - 新增了车的工厂interface

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: CarFactory.java
     * @time: 2020/2/5 19:42
     * @desc:
     */
    
    public interface CarFactory {
        Car createCar();
    }
    ```

  - 实现了车工厂的audi工厂

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: AudiFactory.java
     * @time: 2020/2/5 19:42
     * @desc:
     */
    
    public class AudiFactory implements CarFactory {
        @Override
        public Car createCar() {
            return new Audi();
        }
    }
    ```

  - 实现了车工厂的byd工厂

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: BydFactory.java
     * @time: 2020/2/5 19:43
     * @desc:
     */
    
    public class BydFactory extends Byd implements CarFactory {
        @Override
        public Car createCar() {
            return new Byd();
        }
    }
    ```

  - 客户端

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Client.java
     * @time: 2020/2/5 19:44
     * @desc:
     */
    
    public class Client {
        public static void main(String[] args){
            Car c1 = new AudiFactory().createCar();
            Car c2 = new BydFactory().createCar();
            Car c3 = new BenzFactory().createCar();
    
            c1.run();
            c2.run();
            c3.run();
        }
    }
    ```

  - 如果需要新增车的类型的话，不需要修改原来的代码，只需要增加类就行，即满足了OCP

  - 新增benz类

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Benz.java
     * @time: 2020/2/5 19:45
     * @desc:
     */
    
    public class Benz extends BenzFactory implements Car {
        @Override
        public void run() {
            System.out.println("奔驰在跑！");
        }
    }
    ```

  - 新增benz工厂

    ```java
    package com.sxt.factory.factorymethod;
    
    /**
     * @author: Li Tian
     * @contact: litian_cup@163.com
     * @software: IntelliJ IDEA
     * @file: Benz.java
     * @time: 2020/2/5 19:45
     * @desc:
     */
    
    public class Benz extends BenzFactory implements Car {
        @Override
        public void run() {
            System.out.println("奔驰在跑！");
        }
    }
    ```

- 简单工厂模式和工厂方法模式PK：

  ![img](https://img-blog.csdnimg.cn/20200205201001445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNTc5MDQ1,size_16,color_FFFFFF,t_70)

- 根据设计理论建议：工厂方法模式。但实际上，我们一般都用**简单工厂模式**。

#### 2.3 抽象工厂模式

- 